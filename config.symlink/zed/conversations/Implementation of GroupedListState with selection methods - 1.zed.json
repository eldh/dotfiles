{"id":"15d3cf5b-770c-44eb-9075-33b5e3cf7ca0","zed":"context","version":"0.4.0","text":"```ts linear-app/orbiter/src/components/useGroupedListNavigation.ts\nimport * as  React from \"react\";\nimport { GroupedListRef } from \"./GroupedList\";\nimport { makeObservable } from \"mobx\";\n\nexport function useGroupedListNavigation(listId: string, listRef: React.RefObject<GroupedListRef>) {\n  const [state] = React.useState(() => new GroupedListState({}))\n  React.useEffect(() => {\n    function keyListener(event: KeyboardEvent) {\n      if (event.key === \"ArrowDown\") {\n        console.log(\"ArrowDown\");\n      } else if (event.key === \"ArrowUp\") {\n        console.log(\"ArrowUp\");\n      }\n    }\n    listRef.current?.domRef.current?.addEventListener(\"keypress\", keyListener)\n  }, []);\n}\n\n\nclass GroupedListState {\n  constructor(options: { initialActiveItem?: PathToItem }) {\n    if (options.initialActiveItem) {\n      this.activeItem = options.initialActiveItem;\n    }\n    makeObservable(this);\n  }\n  public focusedItem: PathToItem | null;\n  public activeItem: PathToItem | null;\n  public previouslyActiveItem: PathToItem | null;\n  public keyboardActive: boolean;\n  public selectedItems: PathToItem[];\n  public navigationDirection: Direction;\n\n  /* How many dimensions are displayed in the view. Boards have two, lists only one.  */\n  private dimensions: number;\n  /* Controls which levels that are interactive. Normally, only the leaf nodes are interactive. */\n  private interactiveLevels: boolean[];\n}\n\ntype PathToItem = number[];\n\n// Combined direction for moving active/selection. Up/Down for vertical, Left/Right for horizontal.\nexport const Direction = {\n  UpLeft: \"up/left\",\n  DownRight: \"down/right\",\n} as const;\nexport type Direction = (typeof Direction)[keyof typeof Direction];\n\n\n\n/**\n * Actions for controlling view selection\n */\nexport type ViewSelectionAction =\n  | {\n    // Move the active item in a given direction. If we're at the end of the dimension, the active doesn't move.\n    type: \"moveActive\";\n    payload: {\n      // Which level are we moving.\n      // Boards for example can move both vertically (level 1-2, i.e items & sub-groups) and horizontally (level 0).\n      // Lists can only move vertically.\n      level: number;\n      direction: Direction;\n      toEnd?: boolean;\n      navigate?: boolean;\n      shouldClearSelection?: boolean;\n      isDebounced?: boolean;\n      isPending?: boolean;\n    };\n  }\n  | {\n    // Activate a specific item. Used for hovering the list, pressing up/down on keyboard etc.\n    type: \"activate\";\n    payload: {\n      item: PathToItem;\n      keyboardActive: boolean;\n      navigate?: boolean | \"refresh\";\n      shouldClearSelection?: boolean;\n      maintainDirection?: boolean;\n    };\n  }\n  | {\n    // Add an item to the selection.\n    type: \"addToSelection\"; payload: {\n      direction: Direction;\n      /**\n      * If no item is selected but there's an active item, this flag controls wether to select both the active and the next item,\n      * or just the active item.\n      */\n      selectActiveItemImmediately?: boolean\n    }\n  }\n  | {\n    // Moves the active & focused item one step.\n    type: \"tabPress\"; payload: React.KeyboardEvent | KeyboardEvent\n  }\n  | { type: \"select\"; payload: PathToItem[]; allowWithInPageFind?: boolean }\n  | { type: \"selectBetween\"; payload: [PathToItem, PathToItem] }\n  | { type: \"deactivate\"; allowWithInPageFind?: boolean }\n  | { type: \"focus\"; payload: { item: PathToItem } }\n  | { type: \"navigateToActive\"; payload: { replace: boolean } }\n  | { type: \"clearSelection\" }\n  | { type: \"shiftSelect\"; payload?: PathToItem }\n  | { type: \"cmdSelect\"; payload?: PathToItem }\n  | { type: \"selectAllInGroup\"; payload: PathToItem }\n  | { type: \"selectAll\" }\n  | { type: \"goToEnd\" }\n  | { type: \"goToStart\" }\n  | { type: \"clearKeyboardActive\" }\n  | { type: \"setKeyboardActive\" }\n  | { type: \"activateNextAvailableItem\"; payload: PathToItem }\n  | { type: \"openSelectionInTabs\" };\n```\n```ts linear-app/client/src/hooks/selection/useGroupedViewSelection.ts\nimport * as React from \"react\";\nimport { useDragLayer } from \"react-dnd\";\nimport { useHistory } from \"react-router-dom\";\nimport debounce from \"lodash/debounce\";\nimport uniqBy from \"lodash/uniqBy\";\nimport isEqual from \"lodash/isEqual\";\nimport minBy from \"lodash/minBy\";\nimport { runInAction } from \"mobx\";\nimport type { History, LocationDescriptorObject } from \"history\";\nimport { useAsRef } from \"@linear/orbiter/hooks/useAsRef\";\nimport { usePrevious } from \"@linear/orbiter/hooks/react-use\";\nimport { KeyboardHelper } from \"@linear/orbiter/utils/KeyboardHelper\";\nimport { UnreachableCaseError } from \"@linear/orbiter/errors/UnreachableCaseError\";\nimport { useKeyPressEvent } from \"@linear/orbiter/hooks/useKeyPressEvent\";\nimport { emitEffect, useReducerWithEffects } from \"@linear/orbiter/hooks/useReducerWithEffects\";\nimport { useIsKeyPressedRef } from \"~/hooks/useIsKeyPressedRef\";\nimport { useRegisterAction } from \"~/hooks/useRegisterAction\";\nimport { MiscellaneousActionGroup } from \"~/action/ActionGroups\";\nimport { generateActionId } from \"~/action/Action\";\nimport { useActionManager } from \"~/hooks/useActionManager\";\nimport {\n  unwrapModelFromProviderItem,\n  type AnyGroupedDataProvider,\n} from \"~/components/List/components/dataProviders/GroupedViewDataProvider\";\nimport { waitForTaskQueue } from \"~/utils/async\";\nimport { useBreadcrumbManager } from \"~/hooks/useBreadcrumbManager\";\nimport { ProjectsDataProvider } from \"~/components/List/components/dataProviders/ProjectsDataProvider\";\nimport { IssueViewDataProvider } from \"~/components/List/components/dataProviders/IssueViewDataProvider\";\nimport { useIsCurrentlyUsingInPageFind } from \"~/components/ContentViewHeader/components/InPageFind\";\nimport { isDesktopTabsEnabled } from \"~/components/DesktopTabs/isDesktopTabsEnabled\";\nimport { DesktopTabState } from \"~/components/DesktopTabs/DesktopTabsState\";\nimport { RoutingManager } from \"~/routes/RoutingManager\";\nimport type { CustomHistoryState } from \"~/typings/custom-history-state\";\nimport {\n  type GroupedViewSelectionState,\n  HorizontalDirection,\n  type ItemIndices,\n  type SelectionStateWithActions,\n  VerticalDirection,\n  type ViewSelectionAction,\n  type ViewSelectionProps,\n  type GroupedViewSelectionContext,\n  type GroupedViewSelectionEffect,\n  type ClusterIndices,\n} from \"./GroupedViewSelectionTypes\";\n\n/** ID of the \"Select none\" action */\nexport const selectNoneActionId = generateActionId();\n\n/** ID of the \"Select all\" action */\nexport const selectAllActionId = generateActionId();\n\nconst selectAllInSubGroupActionId = generateActionId();\nconst selectAllInGroupActionId = generateActionId();\nconst selectAllInClusterActionId = generateActionId();\n\n/** The number of milliseconds that a list navigation is debounced by */\nexport const LIST_NAV_DEBOUNCE = 400;\n\n/**\n * Hook to control selection in grouped views.\n *\n * One item can have focus, multiple items can be selected. Typically the focused item is the same as the last item added to the selection.\n *\n * Depending on the type of view (board or list), different actions are used to modify the focus and selection.\n *\n * @param ViewSelectionProps. Data needed to control & calculate selection\n * @returns SelectionState selected & focused items + actions to operate on these\n */\nexport function useGroupedViewSelection(\n  props: ViewSelectionProps\n): [SelectionStateWithActions, React.Dispatch<ViewSelectionAction>] {\n  const { provider, hiddenGroups = [], hiddenSubGroups = [], itemsKey, isSplitView = false, onLeaveList } = props;\n\n  const isBoard = isBoardLayout(provider);\n\n  const isShiftPressed = useIsKeyPressedRef(event => event.key === \"Shift\");\n  const isModPressed = useIsKeyPressedRef(event => KeyboardHelper.isModKey(event, true));\n  const history = useHistory();\n  const providerRef = useAsRef(provider);\n  const breadcrumbManager = useBreadcrumbManager();\n  const { isDragging } = useDragLayer(monitor => ({ isDragging: monitor.isDragging() }));\n  const multiSelectDisabled = Boolean(provider.disableMultiSelect);\n  const allItemsCount = provider.groupCounts.reduce((memo, count) => memo + count, 0);\n  const { isUsingInPageFind } = useIsCurrentlyUsingInPageFind();\n\n  const initialState: GroupedViewSelectionState = {\n    activeItem: props.initialActiveItem ?? null,\n    previouslyActiveItem: null,\n    keyboardActive: false,\n    focusedItem: null,\n    selectedItems: [],\n    initialSelectedItem: null,\n    navigationDirection: VerticalDirection.Down,\n    isGracePeriodActive: false,\n  };\n\n  // Wrapper around the pure reducer to handle any effects that need to be run after the state is updated.\n  function wrappedReducer(oldState: GroupedViewSelectionState, action: ViewSelectionAction): GroupedViewSelectionState {\n    // Prevent changes in the grouping navigation/selection when using in page find\n    if (isUsingInPageFind && !(\"allowWithInPageFind\" in action && action.allowWithInPageFind === true)) {\n      return oldState;\n    }\n\n    const context = {\n      provider,\n      providerRef,\n      hiddenGroups,\n      hiddenSubGroups,\n      isDragging,\n      isSplitView,\n      multiSelectDisabled,\n      initialState,\n      oldState,\n      history,\n    };\n    const [newState, effects] = groupedViewSelectionReducer(action, context);\n    const initialLocationState = { ...(context.history.location.state || {}) };\n\n    effects.forEach(effect => {\n      switch (effect.type) {\n        case \"navigateToActiveItem\":\n          emitEffect((currentState: GroupedViewSelectionState) =>\n            navigateToActiveItem(effect.args[0], currentState, context, initialLocationState)\n          );\n          return;\n        case \"navigateToActiveItemDebounced\":\n          emitEffect((currentState: GroupedViewSelectionState) =>\n            debouncedNavigateToActiveItem(effect.args[0], currentState, context, initialLocationState)\n          );\n          return;\n        case \"prefetch\":\n          emitEffect(() => prefetch({ provider, hiddenGroups, hiddenSubGroups, ...effect.args[0] }));\n          return;\n        case \"updateActiveItem\":\n          emitEffect(() => runInAction(() => breadcrumbManager.updateActiveItem(...effect.args)));\n          return;\n        case \"navigationOverflow\":\n          emitEffect(() => onLeaveList?.(effect.args[0]));\n          return;\n        default:\n          throw new UnreachableCaseError(effect);\n      }\n    });\n    return newState;\n  }\n\n  const [state, dispatch] = useReducerWithEffects<ViewSelectionAction, GroupedViewSelectionState>(\n    wrappedReducer,\n    initialState\n  );\n\n  // Check navigation state for items to select.\n  useHighlightFromNavigationState(provider, dispatch, isSplitView);\n\n  // Move selection to the correct items if the data changes\n  useUpdateSelected(provider, dispatch, state.selectedItems);\n\n  // When the content changes, update active state to be the same model as before\n  useUpdateActive(provider, dispatch, isSplitView, state, providerRef, itemsKey);\n\n  // When a command menu is open, we want to turn off keyboard navigation to avoid layout side effects from actions\n  useDisableKeyboardNavWithCommandMenuOpen(dispatch, state.selectedItems, state.activeItem);\n\n  React.useEffect(() => {\n    if (isUsingInPageFind) {\n      dispatch({ type: \"deactivate\", allowWithInPageFind: true });\n    }\n  }, [isUsingInPageFind]);\n\n  useRegisterAction({\n    id: selectAllActionId,\n    name: \"Select all\",\n    keyboardShortcut: { key: \"a\", mod: true },\n    group: MiscellaneousActionGroup,\n    applicable: () => state.selectedItems.length < allItemsCount,\n    execute: () => selectAllItems(),\n  });\n\n  useRegisterAction({\n    id: selectAllInClusterActionId,\n    name: \"Select all in group\",\n    keyboardShortcut: { key: \"a\", alt: true, mod: true },\n    group: MiscellaneousActionGroup,\n    applicable: () => Boolean(state.selectedItems.length === 0 && state.activeItem),\n    execute: () => {\n      if (state.activeItem) {\n        selectAllItemsInCluster(state.activeItem.groupIndex, state.activeItem.subGroupIndex);\n      }\n    },\n  });\n\n  useRegisterAction({\n    id: selectAllInGroupActionId,\n    name: isBoard ? \"Select all in column\" : \"Select all in group\",\n    keyboardShortcut: { key: [\"s\", \"c\"], alt: true },\n    group: MiscellaneousActionGroup,\n    applicable: () => Boolean(state.selectedItems.length === 0 && state.activeItem),\n    execute: () => {\n      if (state.activeItem) {\n        selectAllItemsInGroup(state.activeItem.groupIndex);\n      }\n    },\n  });\n\n  useRegisterAction({\n    id: selectAllInSubGroupActionId,\n    name: \"Select all in row\",\n    keyboardShortcut: { key: [\"s\", \"r\"], alt: true },\n    group: MiscellaneousActionGroup,\n    applicable: () => Boolean(state.selectedItems.length === 0 && state.activeItem && isBoard),\n    execute: () => {\n      if (state.activeItem?.subGroupIndex !== undefined) {\n        selectAllItemsInSubGroup(state.activeItem.subGroupIndex);\n      }\n    },\n  });\n\n  // This action will not run when pressing Escape, as the hook useKeyPressEvent will run first.\n  // Keeping this action to still show it in the command menu.\n  useRegisterAction({\n    id: selectNoneActionId,\n    name: \"Select none\",\n    keyboardShortcut: { key: \"Escape\" },\n    group: MiscellaneousActionGroup,\n    applicable: () => state.selectedItems.length > 0,\n    execute: () => {\n      dispatch({ type: \"clearSelection\" });\n      (self.document?.activeElement as HTMLElement)?.blur();\n    },\n  });\n\n  // Using useKeyPressEvent in addition to useRegisterAction because we want to call preventDefault on the event.\n  useKeyPressEvent(KeyboardHelper.isEscape, e => {\n    if (state.selectedItems.length > 0) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      dispatch({ type: \"clearSelection\" });\n      (self.document?.activeElement as HTMLElement)?.blur();\n    }\n  });\n\n  const selectAllItems = React.useCallback(() => {\n    if (!multiSelectDisabled) {\n      dispatch({ type: \"selectAll\" });\n    }\n  }, [multiSelectDisabled]);\n\n  const selectAllItemsInCluster = React.useCallback(\n    (groupIndex: number, subGroupIndex?: number) => {\n      if (!multiSelectDisabled) {\n        dispatch({ type: \"selectAllInCluster\", payload: { groupIndex, subGroupIndex } });\n      }\n    },\n    [multiSelectDisabled]\n  );\n\n  const selectAllItemsInGroup = React.useCallback(\n    (groupIndex: number) => {\n      if (!multiSelectDisabled) {\n        dispatch({ type: \"selectAllInGroup\", payload: { groupIndex } });\n      }\n    },\n    [multiSelectDisabled]\n  );\n\n  const selectAllItemsInSubGroup = React.useCallback(\n    (subGroupIndex: number) => {\n      if (!multiSelectDisabled) {\n        dispatch({ type: \"selectAllInSubGroup\", payload: { subGroupIndex } });\n      }\n    },\n    [multiSelectDisabled]\n  );\n\n  const selectItem = React.useCallback(\n    (item: ItemIndices, addToSelection = false) => {\n      !multiSelectDisabled\n        ? isShiftPressed.current && !isModPressed.current\n          ? dispatch({ type: \"shiftSelect\", payload: item })\n          : isModPressed.current || addToSelection\n          ? dispatch({ type: \"cmdSelect\", payload: item })\n          : dispatch({ type: \"select\", payload: [item] })\n        : addToSelection\n        ? dispatch({ type: \"cmdSelect\", payload: item })\n        : dispatch({ type: \"select\", payload: [item] });\n    },\n    [multiSelectDisabled]\n  );\n\n  const activeItemRef = useAsRef(state.activeItem);\n\n  const activateItem = React.useCallback(\n    (item: ItemIndices, options?: { keyboardActive?: boolean; shouldClearSelection?: boolean; navigate?: boolean }) => {\n      const { keyboardActive = false, shouldClearSelection, navigate } = options ?? {};\n      const sameItem = !!activeItemRef.current && areItemsEqual(activeItemRef.current, item);\n\n      if (sameItem) {\n        // In split view, always clear selection when activating the same item\n        if (isSplitView) {\n          dispatch({\n            type: \"activate\",\n            payload: { item, keyboardActive, shouldClearSelection: true, navigate: \"refresh\" },\n          });\n        }\n        return;\n      }\n\n      dispatch({\n        type: \"activate\",\n        payload: {\n          item,\n          keyboardActive,\n          shouldClearSelection,\n          navigate: navigate ?? (isSplitView ? true : undefined),\n        },\n      });\n    },\n    []\n  );\n\n  const getActiveItem = React.useCallback(() => state.activeItem, [state.activeItem]);\n\n  const deactivateItem = React.useCallback(() => {\n    if (activeItemRef.current) {\n      dispatch({ type: \"deactivate\" });\n    }\n  }, []);\n\n  const clearSelection = React.useCallback(() => {\n    dispatch({ type: \"clearSelection\" });\n  }, []);\n\n  const debouncedDispatchMoveActiveVertical = debounce(\n    (direction: VerticalDirection, navigate?: boolean) => {\n      dispatch({\n        type: \"moveActiveVertical\",\n        payload: { direction, shouldClearSelection: isSplitView, navigate, isDebounced: true },\n      });\n    },\n    // A heuristic value that seems to activate the debounce when pressing the arrow keys\n    // continuously or very fast, but not when pressing normally. It also doesn't cause too much\n    // perceived delay after stopping the key presses (when the debounce trailing edge is called)\n    LIST_NAV_DEBOUNCE,\n    { leading: false, trailing: true }\n  );\n\n  const moveActiveVertical = React.useCallback(\n    ({ direction, navigate }: { direction: VerticalDirection; navigate?: boolean }) => {\n      dispatch({\n        type: \"moveActiveVertical\",\n        payload: { direction, shouldClearSelection: isSplitView, isPending: true },\n      });\n      debouncedDispatchMoveActiveVertical(direction, navigate);\n    },\n    [isSplitView]\n  );\n\n  return React.useMemo(() => {\n    return [\n      {\n        getActiveItem,\n        selectItem,\n        activateItem,\n        deactivateItem,\n        selectAllItems,\n        moveActiveVertical,\n        clearSelection,\n        selectAllItemsInSubGroup,\n        selectAllItemsInGroup,\n        selectAllItemsInCluster,\n        multiSelectDisabled,\n        ...state,\n      },\n      dispatch,\n    ];\n  }, [\n    itemToMemoKey(state.focusedItem),\n    itemToMemoKey(state.activeItem),\n    state.isGracePeriodActive,\n    state.selectedItems.map(itemToMemoKey).join(\",\"),\n    activateItem,\n    deactivateItem,\n    getActiveItem,\n    selectItem,\n    selectAllItemsInSubGroup,\n    selectAllItemsInGroup,\n    selectAllItemsInCluster,\n    multiSelectDisabled,\n    selectAllItems,\n    moveActiveVertical,\n    clearSelection,\n  ]);\n}\n\n/**\n * A pure reducer function that handles all the logic for updating the selection state.\n * @param action Action dispatched to the reducer\n * @param context A context object containing all information needed to calculate the new state\n * @returns A tuple containing the next state and a list of effects to run after the state is updated\n */\nexport const groupedViewSelectionReducer = (\n  action: ViewSelectionAction,\n  context: GroupedViewSelectionContext\n): [GroupedViewSelectionState, GroupedViewSelectionEffect[]] => {\n  const {\n    oldState,\n    provider,\n    isDragging,\n    hiddenGroups,\n    hiddenSubGroups,\n    isSplitView,\n    multiSelectDisabled,\n    initialState,\n    providerRef,\n  } = context;\n\n  let newState = oldState;\n  const effects: GroupedViewSelectionEffect[] = [];\n\n  // We don't want to alter the state when dragging an item.\n  // This caused performance issues when dragging an item in a large list as the state would be updated too often.\n  if (isDragging) {\n    return [newState, effects];\n  }\n\n  // Skip early if there are no groups (the view is empty)\n  if (getMinGroup({ provider, hiddenGroups }) < 0) {\n    return [newState, effects];\n  }\n\n  if (action.type === \"moveActiveVertical\") {\n    const oldActiveItem = oldState.activeItem ?? oldState.previouslyActiveItem;\n\n    // To ensure smooth navigation in split view, we can debounce the navigation to the active item.\n    // First, we perform a pending activation that doesn't change the view, and dispatch\n    // non-pending activation using debouncing.\n    const isPending = action.payload.isPending;\n    const isDebounced = action.payload.isDebounced;\n\n    const activeItem = getNextItem({\n      provider,\n      hiddenGroups,\n      hiddenSubGroups,\n      primaryItem: oldActiveItem,\n      fallbackItem: oldState.focusedItem,\n      direction: action.payload.direction,\n      toEnd: action.payload.toEnd,\n      effects: isDebounced ? undefined : effects,\n    });\n\n    // When it's the debounced action, we don't want to adjust state, just navigate.\n    if (!isDebounced) {\n      newState = {\n        ...oldState,\n        keyboardActive: true,\n        activeItem,\n        selectedItems: action.payload.shouldClearSelection ? [] : oldState.selectedItems,\n        initialSelectedItem: action.payload.shouldClearSelection ? null : oldState.initialSelectedItem,\n        navigationDirection: action.payload.direction,\n        previouslyActiveItem: null,\n      };\n    }\n\n    // When the user reaches the end of the list and continues to press the key to go down or up,\n    // we don't want to keep on debouncing the action, but instead immediately activate the item.\n    const reachedEnd = oldActiveItem && areItemsEqual(oldActiveItem, activeItem);\n    const shouldDeferActivation = isPending && !reachedEnd;\n\n    if (!shouldDeferActivation && action.payload.navigate !== false && isSplitView) {\n      effects.push({ type: \"navigateToActiveItem\", args: [true] });\n    }\n  } else if (action.type === \"moveActiveHorizontal\") {\n    const cluster = findNextCluster({\n      provider,\n      hiddenGroups,\n      hiddenSubGroups,\n      current: oldState.activeItem ?? oldState.previouslyActiveItem ?? getMinCluster({ provider, hiddenGroups }),\n      direction: action.payload.direction,\n    });\n\n    const clusterItemCount = getClusterItemCount({ provider, cluster });\n\n    let indexInGroup = Math.min(\n      oldState.activeItem?.indexInGroup ?? oldState.previouslyActiveItem?.indexInGroup ?? 0,\n      clusterItemCount - 1\n    );\n\n    if (\n      cluster.subGroupIndex !== undefined &&\n      oldState.activeItem?.subGroupIndex !== undefined &&\n      cluster.subGroupIndex !== oldState.activeItem?.subGroupIndex\n    ) {\n      indexInGroup = cluster.subGroupIndex < oldState.activeItem?.subGroupIndex ? clusterItemCount - 1 : 0;\n    }\n\n    newState = {\n      ...oldState,\n      keyboardActive: true,\n      activeItem: { ...cluster, indexInGroup },\n      focusedItem: null,\n      initialSelectedItem: null,\n      previouslyActiveItem: null,\n    };\n\n    if (isSplitView) {\n      effects.push({ type: \"navigateToActiveItem\", args: [true] });\n    }\n  } else if (action.type === \"addToSelectionVertical\") {\n    if (multiSelectDisabled) {\n      return [newState, effects];\n    }\n    const basePoint =\n      oldState.initialSelectedItem ?? (oldState.selectedItems.length > 0 ? oldState.focusedItem : undefined);\n    if (basePoint && oldState.focusedItem) {\n      // We have an existing selection, so will need to add to it\n      if (oldState.activeItem && oldState.keyboardActive && !areItemsEqual(oldState.activeItem, oldState.focusedItem)) {\n        // The active item we want to add to the selection is disconnected from the other items, so will need to add a new group to the selection\n        newState = {\n          ...oldState,\n\n          focusedItem: oldState.activeItem,\n          selectedItems: [...oldState.selectedItems, oldState.activeItem].sort(itemSort),\n        };\n      } else {\n        // Add/remove to the selection,\n        const nextPoint = getNextItem({\n          provider,\n          hiddenGroups,\n          hiddenSubGroups,\n          primaryItem: oldState.focusedItem,\n          fallbackItem: oldState.activeItem,\n          direction: action.payload.direction,\n        });\n\n        newState = {\n          ...oldState,\n\n          activeItem: nextPoint,\n          focusedItem: nextPoint,\n          selectedItems: getItemsBetween({\n            from: basePoint,\n            to: nextPoint,\n            preserveGaps: true,\n            provider,\n            selectedItems: oldState.selectedItems,\n            hiddenGroups,\n            hiddenSubGroups,\n          }),\n        };\n        if (isSplitView) {\n          effects.push({ type: \"navigateToActiveItemDebounced\", args: [true] });\n        }\n      }\n    } else {\n      const initialItem = oldState.activeItem ?? { ...getMinCluster({ provider, hiddenGroups }), indexInGroup: 0 };\n\n      if (action.payload.selectActiveItemImmediately) {\n        const nextItem = getNextItem({\n          provider,\n          hiddenGroups,\n          hiddenSubGroups,\n          primaryItem: oldState.activeItem,\n          fallbackItem: null,\n          direction: action.payload.direction,\n        });\n        newState = {\n          ...oldState,\n          activeItem: nextItem,\n          initialSelectedItem: initialItem,\n          focusedItem: nextItem,\n          selectedItems: [nextItem, initialItem].concrete(),\n        };\n      } else {\n        newState = {\n          ...oldState,\n          activeItem: initialItem,\n          initialSelectedItem: initialItem,\n          focusedItem: initialItem,\n          selectedItems: [initialItem],\n        };\n      }\n      if (isSplitView) {\n        effects.push({ type: \"navigateToActiveItemDebounced\", args: [true] });\n      }\n    }\n  } else if (action.type === \"select\") {\n    if (multiSelectDisabled) {\n      return [oldState, effects];\n    } else if (action.payload.length === 0) {\n      return [initialState, effects];\n    }\n    newState = {\n      ...oldState,\n      activeItem: action.payload[0],\n      focusedItem: action.payload[0],\n      selectedItems: action.payload,\n      initialSelectedItem: action.payload[0],\n      previouslyActiveItem: null,\n    };\n    if (isSplitView) {\n      effects.push({ type: \"navigateToActiveItem\", args: [true] });\n    }\n  } else if (action.type === \"activate\") {\n    if (action.payload.item) {\n      effects.push({\n        type: \"prefetch\",\n        args: [{ primaryItem: action.payload.item, fallbackItem: oldState.focusedItem }],\n      });\n    }\n    const direction =\n      action.payload.maintainDirection !== true && action.payload.item && oldState.activeItem\n        ? isAbove(action.payload.item, oldState.activeItem)\n          ? VerticalDirection.Up\n          : VerticalDirection.Down\n        : oldState.navigationDirection;\n    newState = {\n      ...oldState,\n      selectedItems: action.payload.shouldClearSelection ? [] : oldState.selectedItems,\n      initialSelectedItem: action.payload.shouldClearSelection ? null : oldState.initialSelectedItem,\n      keyboardActive: action.payload.keyboardActive,\n      activeItem: action.payload.item,\n      navigationDirection: direction,\n      previouslyActiveItem: null,\n    };\n\n    if (action.payload.navigate) {\n      effects.push({ type: \"navigateToActiveItem\", args: [action.payload.navigate] });\n    }\n  } else if (action.type === \"deactivate\") {\n    return [\n      {\n        ...oldState,\n        previouslyActiveItem: oldState.activeItem,\n        keyboardActive: false,\n        activeItem: null,\n      },\n      effects,\n    ];\n  } else if (action.type === \"focus\") {\n    effects.push({\n      type: \"prefetch\",\n      args: [{ primaryItem: action.payload.item, fallbackItem: oldState.focusedItem }],\n    });\n    newState = {\n      ...oldState,\n      keyboardActive: true,\n      previouslyActiveItem: null,\n      activeItem: action.payload.item,\n      focusedItem: action.payload.item,\n    };\n    if (isSplitView) {\n      effects.push({ type: \"navigateToActiveItem\", args: [true] });\n    }\n  } else if (action.type === \"clearKeyboardActive\") {\n    newState = {\n      ...oldState,\n      keyboardActive: false,\n    };\n  } else if (action.type === \"setKeyboardActive\") {\n    newState = {\n      ...oldState,\n      keyboardActive: true,\n    };\n  } else if (action.type === \"clearSelection\") {\n    newState = {\n      ...oldState,\n      selectedItems: [],\n      keyboardActive: false,\n      focusedItem: null,\n      initialSelectedItem: null,\n      previouslyActiveItem: null,\n    };\n  } else if (action.type === \"tabPress\") {\n    const moveForward = action.payload.shiftKey;\n    if (oldState.activeItem) {\n      let nextFocusedItem: ItemIndices | null;\n      if (moveForward) {\n        nextFocusedItem = getNextItem({\n          provider,\n          hiddenGroups,\n          hiddenSubGroups,\n          primaryItem: oldState.focusedItem,\n          fallbackItem: oldState.activeItem,\n          direction: VerticalDirection.Up,\n        });\n      } else {\n        nextFocusedItem = getNextItem({\n          provider,\n          hiddenGroups,\n          hiddenSubGroups,\n          primaryItem: oldState.focusedItem,\n          fallbackItem: oldState.activeItem,\n          direction: VerticalDirection.Down,\n        });\n      }\n      if (\n        !areClustersEqual(oldState.activeItem, nextFocusedItem) ||\n        areItemsEqual(oldState.activeItem, nextFocusedItem)\n      ) {\n        return [initialState, effects];\n      }\n      action.payload.preventDefault();\n      newState = {\n        ...oldState,\n\n        activeItem: nextFocusedItem,\n        selectedItems: [],\n        keyboardActive: true,\n        initialSelectedItem: null,\n        focusedItem: nextFocusedItem,\n        previouslyActiveItem: null,\n      };\n    }\n  } else if (action.type === \"shiftSelect\") {\n    const startShiftSelectItem = action.payload ?? oldState.activeItem;\n    if (!startShiftSelectItem || multiSelectDisabled) {\n      return [oldState, effects];\n    }\n    newState = {\n      ...oldState,\n      previouslyActiveItem: null,\n      initialSelectedItem: oldState.initialSelectedItem || startShiftSelectItem,\n      activeItem: startShiftSelectItem,\n      focusedItem: startShiftSelectItem,\n      selectedItems: oldState.initialSelectedItem\n        ? getItemsBetween({\n            from: startShiftSelectItem,\n            to: oldState.initialSelectedItem,\n            preserveGaps: false,\n            provider,\n            selectedItems: oldState.selectedItems,\n            hiddenGroups,\n            hiddenSubGroups,\n          })\n        : [startShiftSelectItem],\n    };\n    if (isSplitView) {\n      effects.push({ type: \"navigateToActiveItem\", args: [true] });\n    }\n  } else if (action.type === \"selectBetween\") {\n    const startItem = action.payload[0];\n    const endItem = action.payload[1];\n\n    newState = {\n      ...oldState,\n      previouslyActiveItem: null,\n      initialSelectedItem: startItem,\n      activeItem: endItem,\n      focusedItem: endItem,\n      selectedItems: getItemsBetween({\n        from: startItem,\n        to: endItem,\n        preserveGaps: false,\n        provider,\n        selectedItems: oldState.selectedItems,\n        hiddenGroups,\n        hiddenSubGroups,\n      }),\n    };\n    if (isSplitView) {\n      effects.push({ type: \"navigateToActiveItem\", args: [true] });\n    }\n  } else if (action.type === \"cmdSelect\") {\n    const startCmdSelectItem = action.payload ?? oldState.activeItem;\n    if (!startCmdSelectItem || multiSelectDisabled) {\n      return [oldState, effects];\n    }\n    const oldSelectedItems =\n      isSplitView && oldState.activeItem\n        ? uniqBy(\n            [...oldState.selectedItems, oldState.activeItem],\n            i => `${i.groupIndex}-${i.subGroupIndex ?? 0}-${i.indexInGroup}`\n          )\n        : oldState.selectedItems;\n    if (oldSelectedItems.some(item => areItemsEqual(item, startCmdSelectItem))) {\n      const selectedItems = oldSelectedItems.filter(item => !areItemsEqual(item, startCmdSelectItem)).sort(itemSort);\n      if (selectedItems.length > 0) {\n        newState = {\n          ...oldState,\n\n          focusedItem: selectedItems[selectedItems.length - 1],\n          selectedItems,\n        };\n      } else {\n        newState = {\n          ...oldState,\n\n          focusedItem: null,\n          initialSelectedItem: null,\n          selectedItems: [],\n        };\n      }\n    } else {\n      newState = {\n        ...oldState,\n\n        activeItem: startCmdSelectItem,\n        focusedItem: startCmdSelectItem,\n        initialSelectedItem: startCmdSelectItem,\n        selectedItems: [...oldSelectedItems, startCmdSelectItem].sort(itemSort),\n      };\n    }\n    if (isSplitView) {\n      effects.push({ type: \"navigateToActiveItem\", args: [true] });\n    }\n  } else if (action.type === \"selectAllInGroup\") {\n    const groupIndex = action.payload.groupIndex;\n\n    const minSubGroupIndex = getMinSubGroup({ provider, hiddenGroups, hiddenSubGroups, groupIndex });\n    const maxSubGroupIndex = getMaxSubGroup({ provider, hiddenGroups, hiddenSubGroups, groupIndex });\n    const maxClusterItemCount = getClusterItemCount({\n      provider,\n      cluster: { groupIndex, subGroupIndex: maxSubGroupIndex },\n    });\n\n    newState = {\n      ...oldState,\n      keyboardActive: false,\n      selectedItems: getItemsBetween({\n        from: { indexInGroup: 0, groupIndex, subGroupIndex: minSubGroupIndex },\n        to: { indexInGroup: maxClusterItemCount - 1, groupIndex, subGroupIndex: maxSubGroupIndex },\n        preserveGaps: false,\n        provider,\n        selectedItems: oldState.selectedItems,\n        hiddenGroups,\n        hiddenSubGroups,\n      }),\n    };\n  } else if (action.type === \"selectAllInSubGroup\") {\n    const subGroupIndex = action.payload.subGroupIndex;\n\n    const minGroupIndex = getMinGroup({ provider, hiddenGroups, hiddenSubGroups, subGroupIndex });\n    const maxGroupIndex = getMaxGroup({ provider, hiddenGroups, hiddenSubGroups, subGroupIndex });\n    const maxClusterItemCount = getClusterItemCount({\n      provider,\n      cluster: { groupIndex: maxGroupIndex, subGroupIndex },\n    });\n\n    newState = {\n      ...oldState,\n      keyboardActive: false,\n      selectedItems: getItemsBetween({\n        from: { indexInGroup: 0, groupIndex: minGroupIndex, subGroupIndex },\n        to: { indexInGroup: maxClusterItemCount - 1, groupIndex: maxGroupIndex, subGroupIndex },\n        preserveGaps: false,\n        provider,\n        selectedItems: oldState.selectedItems,\n        hiddenGroups,\n        hiddenSubGroups,\n      }),\n    };\n  } else if (action.type === \"selectAllInCluster\") {\n    const lastIndex = getClusterItemCount({ provider, cluster: action.payload }) - 1;\n\n    newState = {\n      ...oldState,\n      keyboardActive: false,\n      selectedItems: getItemsBetween({\n        from: { indexInGroup: 0, ...action.payload },\n        to: { indexInGroup: lastIndex, ...action.payload },\n        preserveGaps: false,\n        provider,\n        selectedItems: oldState.selectedItems,\n        hiddenGroups,\n        hiddenSubGroups,\n      }),\n    };\n  } else if (action.type === \"selectAll\") {\n    const maxCluster = {\n      groupIndex: provider.groupCounts.length - 1,\n      subGroupIndex: (provider.subGroupCounts?.length ?? 1) - 1,\n    } satisfies ClusterIndices;\n    const lastIndex = getClusterItemCount({ provider, cluster: maxCluster }) - 1;\n    newState = {\n      ...oldState,\n      keyboardActive: false,\n      selectedItems: getItemsBetween({\n        from: { groupIndex: 0, subGroupIndex: 0, indexInGroup: 0 },\n        to: { ...maxCluster, indexInGroup: lastIndex },\n        preserveGaps: false,\n        provider,\n        selectedItems: oldState.selectedItems,\n        hiddenGroups,\n        hiddenSubGroups,\n      }),\n    };\n  } else if (action.type === \"navigateToActive\") {\n    effects.push({ type: \"navigateToActiveItem\", args: [action.payload.replace] });\n  } else if (action.type === \"goToTop\") {\n    const minGroupIndex = getMinGroup({ provider, hiddenGroups });\n    newState = {\n      ...oldState,\n      keyboardActive: true,\n      activeItem: {\n        indexInGroup: 0,\n        groupIndex: minGroupIndex,\n        subGroupIndex: getMinSubGroup({ provider, groupIndex: minGroupIndex, hiddenGroups, hiddenSubGroups }),\n      },\n      focusedItem: null,\n      selectedItems: [],\n      initialSelectedItem: null,\n    };\n    if (isSplitView) {\n      effects.push({ type: \"navigateToActiveItem\", args: [true] });\n    }\n  } else if (action.type === \"goToBottom\") {\n    const maxGroupIndex = getMaxGroup({ provider, hiddenGroups });\n    newState = {\n      ...oldState,\n      keyboardActive: true,\n      activeItem: {\n        indexInGroup: provider.groupCounts[maxGroupIndex] - 1,\n        groupIndex: maxGroupIndex,\n        subGroupIndex: getMaxSubGroup({ provider, groupIndex: maxGroupIndex, hiddenGroups, hiddenSubGroups }),\n      },\n      focusedItem: null,\n      selectedItems: [],\n      initialSelectedItem: null,\n    };\n    if (isSplitView) {\n      effects.push({ type: \"navigateToActiveItem\", args: [true] });\n    }\n  } else if (action.type === \"startGracePeriod\") {\n    newState = { ...oldState, isGracePeriodActive: true };\n  } else if (action.type === \"clearGracePeriod\") {\n    newState = { ...oldState, isGracePeriodActive: false };\n  } else if (action.type === \"activateNextAvailableItem\") {\n    const item = action.payload;\n    const clusterItemsCount = getClusterItemCount({ provider, cluster: item });\n\n    const doesItemExistAtIndex = item.indexInGroup < clusterItemsCount;\n\n    if (doesItemExistAtIndex) {\n      newState = {\n        ...oldState,\n        activeItem: item,\n        previouslyActiveItem: null,\n      };\n    } else {\n      const nextFocusableItem = getNextItem({\n        provider: providerRef.current,\n        hiddenGroups,\n        hiddenSubGroups,\n        primaryItem: action.payload,\n        fallbackItem: null,\n        direction: item.indexInGroup === 0 ? VerticalDirection.Down : VerticalDirection.Up,\n      });\n      if (nextFocusableItem) {\n        newState = {\n          ...oldState,\n          activeItem: nextFocusableItem,\n          previouslyActiveItem: null,\n        };\n      }\n    }\n  } else if (action.type === \"openSelectionInTabs\") {\n    const anySelected = oldState.selectedItems.length > 0;\n    const items = (anySelected ? oldState.selectedItems : [oldState.activeItem]).filter(Boolean);\n    const hasDesktopTabs = isDesktopTabsEnabled();\n\n    for (const item of items) {\n      const itemPath = provider.path(item);\n      const pathname = typeof itemPath === \"string\" ? itemPath : itemPath?.pathname;\n\n      if (pathname) {\n        if (hasDesktopTabs) {\n          DesktopTabState.instance.addTabFromPath(pathname.toString(), false);\n        } else {\n          // Browsers may prevent opening multiple tabs in sequence\n          // and just open the first. That's fine, we cannot control it.\n          RoutingManager.navigateExternal(pathname.toString(), { useWindow: true });\n        }\n      }\n    }\n  } else {\n    throw new UnreachableCaseError(action);\n  }\n  // If the active item changed, update it in the breadcrumb manager to restore it on subsequent navigation here\n  if (newState.activeItem && newState.activeItem !== oldState.activeItem) {\n    const activeId = provider.modelForItem(newState.activeItem)?.id;\n    effects.push({ type: \"updateActiveItem\", args: [activeId] });\n  } else if (!newState.activeItem && oldState.activeItem) {\n    effects.push({ type: \"updateActiveItem\", args: [] });\n  }\n\n  return [newState, effects];\n};\n\n/**\n * Check navigation state for items to select.\n * This happens for example when we undo actions and want to highlight the affected items\n * @param provider Grouped view data provider\n * @param dispatch Grouped view reducer dispatcher\n * @param isSplitView Is the view split (e.g. inbox)\n */\nfunction useHighlightFromNavigationState(\n  provider: AnyGroupedDataProvider,\n  dispatch: (action: ViewSelectionAction) => void,\n  isSplitView: boolean\n) {\n  const history = useHistory();\n\n  React.useLayoutEffect(() => {\n    const navigationStateSelectedIds: string[] | undefined = history.location.state?.selectedIds;\n\n    if (!navigationStateSelectedIds) {\n      return;\n    }\n\n    if (navigationStateSelectedIds.length === 0) {\n      dispatch({ type: \"clearSelection\" });\n      return;\n    }\n\n    const newState = { ...history.location.state };\n    delete newState.selectedIds;\n    replaceHistory(history, {\n      newLocation: {\n        ...history.location,\n        state: newState,\n      },\n    });\n\n    const itemsToSelect = navigationStateSelectedIds.reduce<ItemIndices[]>((memo, id) => {\n      const item = provider.indicesForId(id);\n      return item ? [...memo, item] : memo;\n    }, []);\n\n    if (itemsToSelect.length === 0) {\n      return;\n    }\n\n    if (isSplitView && itemsToSelect.length === 1) {\n      dispatch({\n        type: \"activate\",\n        payload: { item: itemsToSelect[0], keyboardActive: true, maintainDirection: true, navigate: true },\n      });\n      return;\n    }\n\n    // We still need to manually add to selection\n    dispatch({ type: \"select\", payload: itemsToSelect });\n  }, [history.location.state?.selectedIds?.join(\"\")]);\n}\n\n/**\n * Hook to update the selected items when the provider content changes\n * @param provider Grouped view data provider\n * @param dispatch Grouped view reducer dispatcher\n * @param selectedItems Currently selected items\n */\nfunction useUpdateSelected(\n  provider: AnyGroupedDataProvider,\n  dispatch: (action: ViewSelectionAction) => void,\n  selectedItems: ItemIndices[]\n) {\n  // Store the previous selected items, so we can move the selection when props change.\n  const selectedModels = selectedItems.map(item => provider.modelForItem(item));\n  const itemIdsHash = selectedModels.reduce((memo, model) => (model ? memo + model.id : memo), \"\");\n  const prevSelectedModels = usePrevious(selectedModels);\n  const prevSelectedItems = usePrevious(selectedItems);\n\n  React.useLayoutEffect(() => {\n    // If indices are the same but models have changed we try to find new models to select\n    if (prevSelectedModels && prevSelectedModels.length > 0 && isEqual(prevSelectedItems, selectedItems)) {\n      const newIndicesToSelect: ItemIndices[] = prevSelectedModels\n        .reduce((memo, model) => {\n          if (!model) {\n            return memo;\n          }\n          // This might fail if the indices are not matching the new props\n          try {\n            const item = provider.indicesForId(model.id);\n            return item ? [...memo, item] : memo;\n          } catch (error) {\n            return memo;\n          }\n        }, [])\n        .sort(itemSort);\n      dispatch({ type: \"select\", payload: newIndicesToSelect, allowWithInPageFind: true });\n    }\n  }, [itemIdsHash]);\n}\n\n/**\n * Hook to update the active item when the provider content changes\n * @param provider Grouped view data provider\n * @param dispatch Grouped view reducer dispatcher\n * @param isSplitView Is the view split (e.g. inbox)\n * @param state Grouped view selection state\n * @param providerRef Ref to the current version of the grouped view provider\n * @param itemsKey Key to trigger a re-render when the items change\n */\nfunction useUpdateActive(\n  provider: AnyGroupedDataProvider,\n  dispatch: (action: ViewSelectionAction) => void,\n  isSplitView: boolean,\n  state: GroupedViewSelectionState,\n  providerRef: React.MutableRefObject<AnyGroupedDataProvider>,\n  itemsKey?: string\n) {\n  // Store the previous selected items, so we can move the selection when props change.\n  const prevSelectedItems = usePrevious(state.selectedItems);\n\n  const activeModelId = state.activeItem && provider.modelForItem(state.activeItem)?.id;\n  const previousActiveItem = usePrevious(state.activeItem);\n  const prevActiveModelId = usePrevious(activeModelId);\n\n  // When the content changes, update active state to be the same model as before\n  React.useLayoutEffect(() => {\n    if (!prevActiveModelId) {\n      return;\n    }\n\n    if (prevActiveModelId === activeModelId) {\n      return;\n    }\n\n    // If the item is still here, make it active\n    const item = providerRef.current.indicesForId(prevActiveModelId);\n    if (item) {\n      dispatch({\n        type: \"activate\",\n        payload: {\n          maintainDirection: true,\n          keyboardActive: isSplitView ? false : state.keyboardActive,\n          item,\n          navigate: isSplitView,\n        },\n      });\n      return;\n    }\n\n    // If the item is no longer there it's more complex, we need to figure out what item to activate in it's place.\n\n    // For a selection or single item, it's reasonable to select the item that is now where the selection started\n    // before (or where the single item was).\n    const itemToSelect = minBy(prevSelectedItems, i => i.groupIndex * 100000000 + i.indexInGroup) ?? previousActiveItem;\n    if (!itemToSelect) {\n      return;\n    }\n\n    // If there actually is an item where the selection used to be\n    if (providerRef.current.modelForItem(itemToSelect)) {\n      dispatch({\n        type: \"activate\",\n        payload: {\n          maintainDirection: true,\n          keyboardActive: state.keyboardActive,\n          item: itemToSelect,\n          navigate: isSplitView,\n        },\n      });\n      return;\n    }\n\n    // Otherwise we activate the last item in the list (as the selection must have been at the end of the list)\n    const itemsInGroup = providerRef.current.groupCounts[itemToSelect.groupIndex] ?? 0;\n    if (itemsInGroup > 0) {\n      dispatch({\n        type: \"activate\",\n        payload: {\n          maintainDirection: true,\n          keyboardActive: state.keyboardActive,\n          item: { ...itemToSelect, indexInGroup: itemsInGroup - 1 },\n          navigate: isSplitView,\n        },\n      });\n    }\n  }, [itemsKey]);\n}\n\n/**\n * Hook to disable keyboard navigation when the command menu is open\n * @param dispatch Grouped view reducer dispatcher\n * @param selectedItems Currently selected items\n * @param activeItem Currently active item\n */\nfunction useDisableKeyboardNavWithCommandMenuOpen(\n  dispatch: (action: ViewSelectionAction) => void,\n  selectedItems: ItemIndices[],\n  activeItem: ItemIndices | null\n) {\n  const actionManager = useActionManager();\n  const selectedItemsRef = useAsRef(selectedItems);\n  const activeItemRef = useAsRef(activeItem);\n\n  React.useLayoutEffect(() => {\n    let activeItemWhenOpened: ItemIndices | null = null;\n    function onOpenHandler() {\n      // If there are selected items, the focus should follow them\n      if (selectedItemsRef.current.length === 0) {\n        activeItemWhenOpened = activeItemRef.current;\n      }\n      dispatch({ type: \"clearKeyboardActive\" });\n    }\n\n    function onClosedHandler() {\n      if (actionManager.isActionMenuOpen() === true) {\n        return;\n      }\n\n      // If an item was active when the menu was opened, we should refocus its index\n      // so the user stays in the same place in the list\n      if (activeItemWhenOpened) {\n        dispatch({ type: \"activateNextAvailableItem\", payload: activeItemWhenOpened });\n\n        activeItemWhenOpened = null;\n      }\n    }\n\n    actionManager.onOpen.subscribe(onOpenHandler);\n    actionManager.onClosed.subscribe(onClosedHandler);\n\n    return () => {\n      actionManager.onOpen.unsubscribe(onOpenHandler);\n      actionManager.onClosed.unsubscribe(onClosedHandler);\n    };\n  }, [actionManager]);\n}\n\n/**  Helper to navigate to the current active item */\nasync function navigateToActiveItem(\n  replace: boolean | \"refresh\" = true,\n  state: GroupedViewSelectionState,\n  context: GroupedViewSelectionContext,\n  initialLocationState: CustomHistoryState\n) {\n  await waitForTaskQueue(2);\n\n  if (!state.activeItem) {\n    return;\n  }\n\n  const { providerRef, history, provider, hiddenGroups, hiddenSubGroups, oldState } = context;\n\n  const pathname = providerRef.current.path(state.activeItem);\n  if (!pathname) {\n    return;\n  }\n\n  const existingHistoryState = { ...(history.location.state || {}) };\n  delete existingHistoryState.favoriteId;\n  const newHistoryState = { ...existingHistoryState };\n\n  if (replace === false) {\n    typeof pathname === \"string\" ? history.push({ pathname, state: newHistoryState }) : history.push(pathname);\n  } else if (replace === true) {\n    typeof pathname === \"string\"\n      ? replaceHistory(history, {\n          newLocation: { pathname, state: newHistoryState },\n        })\n      : replaceHistory(history, { newLocation: pathname });\n  } else if (replace === \"refresh\") {\n    // If the state changed we don't want to refresh the page. This is to prevent navigating back to inbox after double clicking away for example.\n    if (history.location.state && isEqual(history.location.state, initialLocationState)) {\n      if (typeof pathname === \"string\") {\n        refreshHistoryIfSamePath(history, {\n          location: { pathname, state: initialLocationState },\n        });\n      } else {\n        refreshHistoryIfSamePath(history, { location: pathname });\n      }\n    }\n  }\n  prefetch({\n    provider,\n    hiddenGroups,\n    hiddenSubGroups,\n    primaryItem: state.activeItem,\n    fallbackItem: oldState.focusedItem,\n  });\n  providerRef.current.handleNavigateToItem?.(state.activeItem);\n}\n\nconst debouncedNavigateToActiveItem = debounce(navigateToActiveItem, LIST_NAV_DEBOUNCE, {\n  leading: false,\n  trailing: true,\n});\n\n/**\n * Get all items between two points (for selection)\n * @param args.from Initial point\n * @param args.to End point\n * @param args.selectedItems Currently selected items\n * @param args.provider Grouped view data provider\n * @param args.preserveGaps Should it preserve gaps in the existing selection\n * @returns Items between the two points for selection\n */\nexport function getItemsBetween(args: {\n  from: ItemIndices;\n  to: ItemIndices;\n  preserveGaps: boolean;\n  provider: AnyGroupedDataProvider;\n  selectedItems: ItemIndices[];\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n}): ItemIndices[] {\n  const { from, to, preserveGaps, provider, selectedItems, hiddenGroups, hiddenSubGroups } = args;\n\n  // Sort the items\n  const [firstItem, lastItem] = (() => {\n    if (from.groupIndex !== to.groupIndex) {\n      return from.groupIndex > to.groupIndex ? [to, from] : [from, to];\n    }\n    if (from.subGroupIndex !== to.subGroupIndex && from.subGroupIndex !== undefined && to.subGroupIndex !== undefined) {\n      return from.subGroupIndex > to.subGroupIndex ? [to, from] : [from, to];\n    }\n    return from.indexInGroup > to.indexInGroup ? [to, from] : [from, to];\n  })();\n\n  // Get all items for clusters in between\n  const allItems = [];\n\n  // Get the groups in between\n  const groupsCount = Math.abs(firstItem.groupIndex - lastItem.groupIndex) + 1;\n  const groups = Array.from({ length: groupsCount }).map(\n    (_, i) => i + Math.min(firstItem.groupIndex, lastItem.groupIndex)\n  );\n\n  for (let i = 0; i < groups.length; i++) {\n    const groupIndex = groups[i];\n    const hasSubGroups =\n      !!provider.subGroupCounts && firstItem.subGroupIndex !== undefined && lastItem.subGroupIndex !== undefined;\n    const subGroupCount = provider.subGroupCounts?.length ?? 1;\n\n    const lowestSubGroupIndex = Math.min(firstItem.subGroupIndex ?? 0, lastItem.subGroupIndex ?? 0) ?? 0;\n    const highestSubGroupIndex = Math.max(\n      firstItem.subGroupIndex ?? subGroupCount - 1,\n      lastItem.subGroupIndex ?? subGroupCount - 1\n    );\n\n    // Get the sub groups in between\n    const subGroupsBetweenCount = Math.abs(highestSubGroupIndex - lowestSubGroupIndex) + 1;\n    const subGroups = Array.from({ length: subGroupsBetweenCount }).map((_, index) => index + lowestSubGroupIndex);\n\n    for (let j = 0; j < subGroups.length; j++) {\n      const subGroupIndex = hasSubGroups ? subGroups[j] : undefined;\n      const cluster = { groupIndex, subGroupIndex };\n\n      if (clusterIsHidden({ cluster, hiddenGroups, provider, hiddenSubGroups })) {\n        continue;\n      }\n\n      const clusterItemCount = getClusterItemCount({ provider, cluster });\n      const highestIndexInCluster = areClustersEqual(lastItem, cluster) ? lastItem.indexInGroup : clusterItemCount - 1;\n      const lowestIndexInCluster = areClustersEqual(firstItem, cluster) ? firstItem.indexInGroup : 0;\n\n      const itemsInClusterCount = highestIndexInCluster - lowestIndexInCluster + 1;\n      const itemsInCluster = Array.from({ length: itemsInClusterCount }).map((_, index) => {\n        const item: ItemIndices = { indexInGroup: index + lowestIndexInCluster, groupIndex };\n        if (hasSubGroups) {\n          item.subGroupIndex = subGroupIndex;\n        }\n        return item;\n      });\n      allItems.push(...itemsInCluster);\n    }\n  }\n\n  if (preserveGaps && selectedItems.length > 1) {\n    const lastSelected = selectedItems[selectedItems.length - 1];\n    const firstSelected = selectedItems[0];\n\n    return allItems\n      .filter(item => {\n        const isAfterLast = (() => {\n          if (item.groupIndex === lastSelected.groupIndex) {\n            if (\n              item.subGroupIndex === lastSelected.subGroupIndex ||\n              lastSelected.subGroupIndex === undefined ||\n              item.subGroupIndex === undefined\n            ) {\n              return item.indexInGroup >= lastSelected.indexInGroup;\n            }\n            return item.subGroupIndex > lastSelected.subGroupIndex;\n          }\n          return item.groupIndex > lastSelected.groupIndex;\n        })();\n\n        const isBeforeFirst = (() => {\n          if (item.groupIndex === firstSelected.groupIndex) {\n            if (\n              item.subGroupIndex === lastSelected.subGroupIndex ||\n              lastSelected.subGroupIndex === undefined ||\n              item.subGroupIndex === undefined\n            ) {\n              return item.indexInGroup <= firstSelected.indexInGroup;\n            }\n            return item.subGroupIndex < lastSelected.subGroupIndex;\n          }\n          return item.groupIndex < firstSelected.groupIndex;\n        })();\n\n        if (isAfterLast || isBeforeFirst) {\n          return true;\n        } else if (!selectedItems.some(i => areItemsEqual(i, item))) {\n          return false;\n        }\n        return true;\n      })\n      .sort(itemSort);\n  } else {\n    return allItems.sort(itemSort);\n  }\n}\n\n/**\n * Sort functions for items\n *\n * @param a ItemIndices\n * @param b ItemIndices\n * @returns number\n */\nfunction itemSort(a: ItemIndices, b: ItemIndices): number {\n  if (areClustersEqual(a, b)) {\n    return a.indexInGroup - b.indexInGroup;\n  }\n  if (a.groupIndex === b.groupIndex && a.subGroupIndex !== undefined && b.subGroupIndex !== undefined) {\n    return a.subGroupIndex - b.subGroupIndex;\n  }\n  return a.groupIndex - b.groupIndex;\n}\n\n/**\n * Compares location of two items in a grouped view\n * @returns true if the two coordinates point to the same location in the view\n */\nexport function areItemsEqual(a: ItemIndices, b: ItemIndices): boolean {\n  return (\n    a.groupIndex === b.groupIndex &&\n    (a.subGroupIndex ?? 0) === (b.subGroupIndex ?? 0) &&\n    a.indexInGroup === b.indexInGroup\n  );\n}\n\n/**\n * Compares location of two clusters in a grouped view\n * @returns true if the two coordinates point to the same cluster in the view\n */\nexport function areClustersEqual(a: ClusterIndices, b: ClusterIndices): boolean {\n  return a.groupIndex === b.groupIndex && a.subGroupIndex === b.subGroupIndex;\n}\n\n/** Checks if a cluster is hidden */\nfunction clusterIsHidden(args: {\n  provider: AnyGroupedDataProvider;\n  cluster: ClusterIndices;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n}) {\n  const { provider, cluster, hiddenGroups, hiddenSubGroups } = args;\n  return (\n    groupIsHidden({ provider, groupIndex: cluster.groupIndex, hiddenGroups }) ||\n    subGroupIsHidden({ provider, hiddenSubGroups, subGroupIndex: cluster.subGroupIndex })\n  );\n}\n\n/** Checks if a group is hidden */\nfunction groupIsHidden(args: { provider: AnyGroupedDataProvider; groupIndex: number; hiddenGroups: string[] }) {\n  const { provider, groupIndex, hiddenGroups } = args;\n  const groupModel = provider.modelForGroup(groupIndex);\n  const groupId = groupModel?.id;\n  return groupId ? hiddenGroups.includes(groupId) : false;\n}\n\n/** Checks if a sub group is hidden */\nfunction subGroupIsHidden(args: {\n  provider: AnyGroupedDataProvider;\n  subGroupIndex?: number;\n  hiddenSubGroups?: string[];\n}) {\n  const { provider, subGroupIndex, hiddenSubGroups } = args;\n  const subGroupModel = provider.modelForSubGroup(subGroupIndex);\n  const subGroupId = subGroupModel?.id;\n  return subGroupId ? Boolean(hiddenSubGroups?.includes(subGroupId)) : false;\n}\n\n/**\n * Check if we can move focus to a cluster (group index + sub group index). Hidden and empty groups/sub-groups can not receive focus.\n *\n * @param provider Grouped view data provider\n * @param cluster Coordinates of the cluster in the view\n * @param hiddenGroups Hidden group IDs\n * @param hiddenSubGroups Hidden subgroup IDs\n *\n * @returns boolean True if focus can be moved to the cluster, false otherwise\n * */\nfunction canMoveToCluster(args: {\n  provider: AnyGroupedDataProvider;\n  cluster: ClusterIndices;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n}) {\n  const { provider, cluster } = args;\n  if (clusterIsHidden(args)) {\n    return false;\n  }\n  const clusterItemCount = getClusterItemCount({ provider, cluster });\n  return clusterItemCount > 0;\n}\n\n/**\n * Check if we can potentially move focus to a group. Hidden and empty groups can not receive focus.\n *\n * @param provider Grouped view data provider\n * @param groupIndex Index of the group\n * @param hiddenGroups Hidden group IDs\n *\n * @returns boolean True if focus can be moved to the group, false otherwise\n * */\nfunction canMoveToGroup(args: { provider: AnyGroupedDataProvider; groupIndex: number; hiddenGroups: string[] }) {\n  const { provider, groupIndex } = args;\n  if (groupIsHidden(args)) {\n    return false;\n  }\n  const groupItemCount = provider.groupCounts[groupIndex];\n  return groupItemCount > 0;\n}\n\n/**\n * Get the first focusable cluster\n * @param args.provider Grouped view data provider\n * @param args.hiddenGroups Hidden group IDs\n * @param args.hiddenSubGroups Hidden sub group IDs\n * @returns groupIndex/subGroupIndex coordinates of the first focusable cluster\n */\nconst getMinCluster = (args: {\n  provider: AnyGroupedDataProvider;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n}): ClusterIndices => {\n  const { provider, hiddenSubGroups } = args;\n\n  const minGroupIndex = getMinGroup(args);\n  if (!provider.subGroupCounts || !hiddenSubGroups) {\n    return { groupIndex: minGroupIndex };\n  }\n\n  const minSubGroupIndex = getMinSubGroup({ ...args, groupIndex: minGroupIndex });\n  if (minSubGroupIndex !== -1) {\n    return { groupIndex: minGroupIndex, subGroupIndex: minSubGroupIndex };\n  }\n\n  return { groupIndex: minGroupIndex };\n};\n\n/**\n * Get first potentially focusable group in the board\n * @param args.provider Grouped view data provider\n * @param args.hiddenGroups Hidden group IDs\n * @returns groupIndex coordinates of the first potentially focusable group\n */\nconst getMinGroup = (args: {\n  provider: AnyGroupedDataProvider;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n  subGroupIndex?: number;\n}): number => {\n  const { provider, subGroupIndex } = args;\n  const firstFocusableGroupIndex = provider.groupCounts.findIndex((_, groupIndex) => {\n    return subGroupIndex !== undefined\n      ? canMoveToCluster({ ...args, cluster: { groupIndex, subGroupIndex } })\n      : canMoveToGroup({ ...args, groupIndex });\n  });\n  return firstFocusableGroupIndex;\n};\n\n/**\n * Get the first focusable subgroup within a given group\n * @param args.provider Grouped view data provider\n * @param args.groupIndex Group to look in\n * @param args.hiddenGroups Hidden group IDs\n * @param args.hiddenSubGroups Hidden sub group IDs\n * @returns subGroupIndex of the first focusable sub group within the group\n */\nconst getMinSubGroup = (args: {\n  provider: AnyGroupedDataProvider;\n  groupIndex: number;\n  hiddenSubGroups?: string[];\n  hiddenGroups: string[];\n}): number | undefined => {\n  const { provider, groupIndex, hiddenSubGroups } = args;\n\n  const subGroupsCount = provider.subGroupCounts?.length ?? 0;\n\n  if (subGroupsCount === 0 || !hiddenSubGroups) {\n    return undefined;\n  }\n\n  for (let subGroupIndex = 0; subGroupIndex < subGroupsCount; subGroupIndex++) {\n    if (canMoveToCluster({ ...args, cluster: { groupIndex, subGroupIndex } })) {\n      return subGroupIndex;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Get the last potentially focusable group\n * @param args.provider Grouped view data provider\n * @param args.hiddenGroups Hidden group IDs\n * @returns groupIndex of the last potentially focusable group\n */\nconst getMaxGroup = (args: {\n  provider: AnyGroupedDataProvider;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n  subGroupIndex?: number;\n}): number => {\n  const { provider, subGroupIndex } = args;\n  const lastFocusableGroupIndex =\n    provider.groupCounts.length -\n    1 -\n    [...provider.groupCounts].reverse().findIndex((_, reverseIndex) => {\n      const groupIndex = provider.groupCounts.length - 1 - reverseIndex;\n      return subGroupIndex !== undefined\n        ? canMoveToCluster({ ...args, cluster: { groupIndex, subGroupIndex } })\n        : canMoveToGroup({ ...args, groupIndex });\n    });\n  return lastFocusableGroupIndex;\n};\n\n/**\n * Get the last focusable sub group within given group\n * @param args.provider Grouped view data provider\n * @param args.groupIndex Group to look in\n * @param args.hiddenGroups Hidden group IDs\n * @param args.hiddenSubGroups Hidden sub group IDs\n * @returns subGroupIndex of the last focusable sub group in the given group\n */\nconst getMaxSubGroup = (args: {\n  provider: AnyGroupedDataProvider;\n  groupIndex: number;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n}): number | undefined => {\n  const { provider, groupIndex, hiddenSubGroups } = args;\n  const subGroupsCount = provider.subGroupCounts?.length ?? 0;\n\n  if (subGroupsCount === 0 || !hiddenSubGroups) {\n    return undefined;\n  }\n\n  for (let subGroupIndex = subGroupsCount - 1; subGroupIndex >= 0; subGroupIndex--) {\n    if (canMoveToCluster({ ...args, cluster: { groupIndex, subGroupIndex } })) {\n      return subGroupIndex;\n    }\n  }\n\n  return undefined;\n};\n\nfunction clusterClamp(args: {\n  provider: AnyGroupedDataProvider;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n  direction: HorizontalDirection | VerticalDirection;\n  cluster: ClusterIndices;\n}): ClusterIndices {\n  const { provider, hiddenGroups, hiddenSubGroups, cluster, direction } = args;\n\n  let constantSubGroupIndex;\n  if (direction === HorizontalDirection.Left || direction === HorizontalDirection.Right) {\n    constantSubGroupIndex = cluster.subGroupIndex;\n  }\n\n  const maxGroupIndex = getMaxGroup({ provider, hiddenGroups, hiddenSubGroups, subGroupIndex: constantSubGroupIndex });\n  const minGroupIndex = getMinGroup({ provider, hiddenGroups, hiddenSubGroups, subGroupIndex: constantSubGroupIndex });\n\n  const groupIndex = Math.max(Math.min(cluster.groupIndex, maxGroupIndex), minGroupIndex);\n\n  if (cluster.subGroupIndex === undefined) {\n    return { groupIndex };\n  }\n\n  if (constantSubGroupIndex !== undefined) {\n    return { groupIndex, subGroupIndex: constantSubGroupIndex };\n  }\n\n  if (direction === HorizontalDirection.Left || direction === HorizontalDirection.Right) {\n    return { groupIndex, subGroupIndex: cluster.subGroupIndex };\n  }\n\n  const minSubGroupIndex = getMinSubGroup({ provider, groupIndex, hiddenGroups, hiddenSubGroups }) ?? 0;\n  const maxSubGroupIndex = getMaxSubGroup({ provider, groupIndex, hiddenGroups, hiddenSubGroups }) ?? 0;\n\n  const subGroupIndex = Math.max(Math.min(cluster.subGroupIndex, maxSubGroupIndex), minSubGroupIndex);\n  return { groupIndex, subGroupIndex };\n}\n\n/** Get the closest focusable cluster */\nfunction findNextCluster(args: {\n  provider: AnyGroupedDataProvider;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n  current: ClusterIndices;\n  direction: HorizontalDirection | VerticalDirection;\n  allowGroupChange?: boolean;\n}): ClusterIndices {\n  const { provider, hiddenGroups, hiddenSubGroups, current, direction, allowGroupChange = true } = args;\n\n  const groupOffset = direction === HorizontalDirection.Right || direction === VerticalDirection.Down ? 1 : -1;\n  const subGroupOffset = direction === VerticalDirection.Down ? 1 : direction === VerticalDirection.Up ? -1 : 0;\n\n  const subGroupCount = provider.subGroupCounts?.length ?? 0;\n  const nextSubGroup = (current.subGroupIndex ?? 0) + subGroupOffset;\n  const canChangeSubGroup =\n    !!subGroupOffset && current.subGroupIndex !== undefined && nextSubGroup >= 0 && nextSubGroup < subGroupCount;\n\n  if (!canChangeSubGroup && !allowGroupChange) {\n    return current;\n  }\n\n  const newCluster = clusterClamp({\n    provider,\n    hiddenGroups,\n    hiddenSubGroups,\n    direction,\n    cluster: canChangeSubGroup\n      ? { ...current, subGroupIndex: nextSubGroup }\n      : { ...current, groupIndex: current.groupIndex + groupOffset },\n  });\n\n  // If the calculated cluster didn't change (i.e. in the direction we're moving, there is no more focusable\n  // clusters), we try to move to the next cluster in the approximate direction (e.g. next row up/down or next column\n  // left/right that is focusable)\n  if (areClustersEqual(newCluster, current)) {\n    return getNextClusterInApproximateDirection({\n      direction,\n      cluster: current,\n      provider,\n      hiddenGroups,\n      hiddenSubGroups,\n    });\n  }\n\n  return areClustersEqual(newCluster, current) ||\n    canMoveToCluster({ provider, hiddenGroups, hiddenSubGroups, cluster: newCluster })\n    ? newCluster\n    : findNextCluster({ provider, hiddenGroups, hiddenSubGroups, current: newCluster, direction, allowGroupChange });\n}\n\n/**\n *\n * @param axis.direction Direction in which to find the next item\n * @param args.cluster Cluster that we start looking from\n * @param args.provider Grouped view data provider\n * @param args.hiddenGroups Hidden group IDs\n * @param args.hiddenSubGroups Hidden sub group IDs\n * @returns\n */\nfunction getNextClusterInApproximateDirection(args: {\n  direction: VerticalDirection | HorizontalDirection;\n  cluster: ClusterIndices;\n  provider: AnyGroupedDataProvider;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n}) {\n  const { direction, cluster, provider, hiddenGroups, hiddenSubGroups } = args;\n\n  const vector =\n    direction === VerticalDirection.Up || direction === HorizontalDirection.Left ? \"decreasing\" : \"increasing\";\n  const mainAxis =\n    direction === VerticalDirection.Up || direction === VerticalDirection.Down ? \"subGroupIndex\" : \"groupIndex\";\n\n  const secondaryAxis = mainAxis === \"groupIndex\" ? \"subGroupIndex\" : \"groupIndex\";\n  const mainAxisIndex = cluster[mainAxis];\n  const secondaryAxisIndex = cluster[secondaryAxis];\n  const subGroupCount = provider.subGroupCounts?.length ?? 0;\n  const groupCount = provider.groupCounts.length;\n  const mainItemMaxIndex = (mainAxis === \"groupIndex\" ? groupCount : subGroupCount) - 1;\n  const secondaryAxisMaxIndex = (mainAxis === \"groupIndex\" ? subGroupCount : groupCount) - 1;\n\n  if (mainAxisIndex === undefined || secondaryAxisIndex === undefined) {\n    return cluster;\n  }\n\n  for (\n    let mainAxisOffset = 1;\n    (vector === \"increasing\" && mainAxisIndex + mainAxisOffset <= mainItemMaxIndex) ||\n    (vector === \"decreasing\" && mainAxisIndex - mainAxisOffset >= 0);\n    mainAxisOffset++\n  ) {\n    const nextMainAxisIndex = mainAxisIndex + (vector === \"decreasing\" ? -mainAxisOffset : mainAxisOffset);\n\n    for (\n      let offset = 1;\n      secondaryAxisIndex + offset <= secondaryAxisMaxIndex || secondaryAxisIndex - offset >= 0;\n      offset++\n    ) {\n      for (const order of [\"before\", \"after\"]) {\n        // @ts-expect-error TS can't know that this will be valid\n        const clusterGuess = {\n          [secondaryAxis]: secondaryAxisIndex + (order === \"before\" ? -offset : offset),\n          [mainAxis]: nextMainAxisIndex,\n        } as ClusterIndices;\n\n        const isValidBefore = order === \"after\" && secondaryAxisIndex + offset <= secondaryAxisMaxIndex;\n        const isValidAfter = order === \"before\" && secondaryAxisIndex - offset >= 0;\n\n        if (\n          (isValidBefore || isValidAfter) &&\n          canMoveToCluster({ provider, hiddenGroups, hiddenSubGroups, cluster: clusterGuess })\n        ) {\n          return clusterGuess;\n        }\n      }\n    }\n  }\n\n  return cluster;\n}\n\n/**\n * Get the next vertical item.\n * @param args.provider Grouped view data provider\n * @param args.hiddenGroups Hidden group IDs\n * @param args.primaryItem Item from which to start looking for the next item\n * @param args.fallbackItem Used as starting point if primary item is not available\n * @param args.direction Direction in which to find the next item\n * @param args.toEnd Should we move to the end of the list\n * @param args.effects Optional effects array if overflow effects should be appended\n * @returns\n */\nexport function getNextItem(args: {\n  provider: AnyGroupedDataProvider;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n  primaryItem: ItemIndices | null;\n  fallbackItem: ItemIndices | null;\n  direction: VerticalDirection;\n  toEnd?: boolean;\n  effects?: GroupedViewSelectionEffect[];\n}): ItemIndices {\n  const { provider, hiddenGroups, hiddenSubGroups, primaryItem, fallbackItem, direction, toEnd = false } = args;\n\n  const isBoard = isBoardLayout(provider);\n\n  const indexOffset = direction === VerticalDirection.Down ? 1 : -1;\n\n  const naiveIndex =\n    primaryItem?.indexInGroup !== undefined\n      ? primaryItem.indexInGroup + indexOffset\n      : fallbackItem?.indexInGroup !== undefined\n      ? fallbackItem.indexInGroup + indexOffset\n      : 0;\n\n  const minGroupIndex = getMinGroup({ provider, hiddenGroups });\n  const minSubGroupIndex = getMinSubGroup({ provider, groupIndex: minGroupIndex, hiddenGroups, hiddenSubGroups });\n  const groupIndexGuess = primaryItem?.groupIndex ?? fallbackItem?.groupIndex ?? minGroupIndex;\n  let subGroupIndexGuess = primaryItem?.subGroupIndex ?? fallbackItem?.subGroupIndex;\n  if (!primaryItem && !fallbackItem && hiddenSubGroups) {\n    subGroupIndexGuess = minSubGroupIndex;\n  }\n\n  const naiveCluster = clusterClamp({\n    provider,\n    hiddenGroups,\n    hiddenSubGroups,\n    direction,\n    cluster: { groupIndex: groupIndexGuess, subGroupIndex: subGroupIndexGuess },\n  });\n\n  const naiveClusterItemsCount = getClusterItemCount({ provider, cluster: naiveCluster });\n  let cluster = naiveCluster;\n\n  if (naiveIndex < 0 || naiveIndex >= naiveClusterItemsCount) {\n    cluster = findNextCluster({\n      provider,\n      hiddenGroups,\n      hiddenSubGroups,\n      current: naiveCluster,\n      direction: naiveIndex < 0 ? VerticalDirection.Up : VerticalDirection.Down,\n      allowGroupChange: !isBoard,\n    });\n  }\n\n  const clusterItemsCount = getClusterItemCount({ provider, cluster });\n  const clusterDidNotChange = areClustersEqual(naiveCluster, cluster);\n  const indexInGroup = (() => {\n    if (toEnd) {\n      return direction === VerticalDirection.Down ? clusterItemsCount - 1 : 0;\n    }\n    if (clusterDidNotChange) {\n      return Math.max(Math.min(naiveIndex, naiveClusterItemsCount - 1), 0);\n    }\n    if (naiveIndex < 0) {\n      return clusterItemsCount - 1;\n    }\n    if (naiveIndex >= naiveClusterItemsCount) {\n      return 0;\n    }\n    return naiveIndex;\n  })();\n\n  // If the next item would have move off the top or end of the list add a navigationOverflow effect\n  if (args.effects && clusterDidNotChange && (naiveIndex < 0 || naiveIndex >= naiveClusterItemsCount)) {\n    args.effects.push({ type: \"navigationOverflow\", args: [naiveIndex] });\n  }\n\n  const nextItem = { ...cluster, indexInGroup };\n\n  if (provider.isItemFocusable && !provider.isItemFocusable(nextItem)) {\n    return getNextItem({\n      ...args,\n      primaryItem: nextItem,\n      fallbackItem: null,\n    });\n  }\n  return nextItem;\n}\n\n/** Prefetch models around the selected model. */\nfunction prefetch(args: {\n  provider: AnyGroupedDataProvider;\n  hiddenGroups: string[];\n  hiddenSubGroups?: string[];\n  primaryItem: ItemIndices | null;\n  fallbackItem: ItemIndices | null;\n}) {\n  const { provider } = args;\n  for (const direction of [VerticalDirection.Up, VerticalDirection.Down]) {\n    const adjacentItem = getNextItem({ ...args, direction });\n    void unwrapModelFromProviderItem(provider.modelForItem(adjacentItem))?.hydrate({\n      onlyIfLocallyAvailable: true,\n    });\n  }\n}\n\n// Helper to call history.replace only when the path or state has changed\nfunction replaceHistory(\n  history: History,\n  options: {\n    newLocation: LocationDescriptorObject;\n  }\n): void {\n  const { newLocation } = options;\n\n  if (RoutingManager.instance.areLocationsIdentical(options.newLocation, history.location)) {\n    return;\n  }\n  return history.replace(newLocation);\n}\n\n// Helper to call history.replace only when the path and hash didn't change\nfunction refreshHistoryIfSamePath(history: History, options: { location: LocationDescriptorObject }): void {\n  const { location } = options;\n  if (location.pathname === history.location.pathname) {\n    return history.replace(location);\n  }\n}\n\nfunction isAbove(a: ItemIndices, b: ItemIndices): boolean {\n  return itemSort(a, b) < 0;\n}\n\nfunction getClusterItemCount(args: { provider: AnyGroupedDataProvider; cluster: ClusterIndices }) {\n  const { provider, cluster } = args;\n  return (\n    (provider.clusterCounts && cluster.subGroupIndex !== undefined\n      ? provider.clusterCounts[cluster.groupIndex]?.[cluster.subGroupIndex]\n      : provider.groupCounts[cluster.groupIndex]) ?? 0\n  );\n}\n\n/**\n * Helper to convert an item to a memo key\n */\nexport function itemToMemoKey(item: ItemIndices | null) {\n  if (!item) {\n    return null;\n  }\n  return `${item.groupIndex}-${item.subGroupIndex ?? \"\"}-${item.indexInGroup}`;\n}\n\nfunction isBoardLayout(provider: AnyGroupedDataProvider) {\n  if (provider instanceof ProjectsDataProvider || provider instanceof IssueViewDataProvider) {\n    return provider.layout === \"board\";\n  }\n  return false;\n}\n```\ncan you implement a method on GroupedViewState that takes a GroupedViewAction and modifies the state accordingly?\nCertainly! I can help you implement a method on `GroupedListState` that takes a `ViewSelectionAction` and modifies the state accordingly. Here's an implementation based on the provided code:\n\n```typescript\nimport { makeObservable, action } from \"mobx\";\n\nclass GroupedListState {\n  constructor(options: { initialActiveItem?: PathToItem }) {\n    if (options.initialActiveItem) {\n      this.activeItem = options.initialActiveItem;\n    }\n    makeObservable(this, {\n      updateState: action,\n    });\n  }\n\n  public focusedItem: PathToItem | null = null;\n  public activeItem: PathToItem | null = null;\n  public previouslyActiveItem: PathToItem | null = null;\n  public keyboardActive: boolean = false;\n  public selectedItems: PathToItem[] = [];\n  public navigationDirection: Direction = Direction.DownRight;\n\n  /* How many dimensions are displayed in the view. Boards have two, lists only one.  */\n  private dimensions: number = 1;\n  /* Controls which levels that are interactive. Normally, only the leaf nodes are interactive. */\n  private interactiveLevels: boolean[] = [];\n\n  public updateState(action: ViewSelectionAction): void {\n    switch (action.type) {\n      case \"moveActive\":\n        this.moveActive(action.payload);\n        break;\n      case \"activate\":\n        this.activate(action.payload);\n        break;\n      case \"addToSelection\":\n        this.addToSelection(action.payload);\n        break;\n      case \"tabPress\":\n        this.handleTabPress(action.payload);\n        break;\n      case \"select\":\n        this.select(action.payload);\n        break;\n      case \"selectBetween\":\n        this.selectBetween(action.payload);\n        break;\n      case \"deactivate\":\n        this.deactivate();\n        break;\n      case \"focus\":\n        this.focus(action.payload);\n        break;\n      case \"navigateToActive\":\n        // This action might require external handling\n        break;\n      case \"clearSelection\":\n        this.clearSelection();\n        break;\n      case \"shiftSelect\":\n        this.shiftSelect(action.payload);\n        break;\n      case \"cmdSelect\":\n        this.cmdSelect(action.payload);\n        break;\n      case \"selectAllInGroup\":\n        this.selectAllInGroup(action.payload);\n        break;\n      case \"selectAll\":\n        this.selectAll();\n        break;\n      case \"goToEnd\":\n        this.goToEnd();\n        break;\n      case \"goToStart\":\n        this.goToStart();\n        break;\n      case \"clearKeyboardActive\":\n        this.clearKeyboardActive();\n        break;\n      case \"setKeyboardActive\":\n        this.setKeyboardActive();\n        break;\n      case \"activateNextAvailableItem\":\n        this.activateNextAvailableItem(action.payload);\n        break;\n      case \"openSelectionInTabs\":\n        // This action might require external handling\n        break;\n      default:\n        console.warn(\"Unhandled action type:\", (action as any).type);\n    }\n  }\n\n  private moveActive(payload: { level: number; direction: Direction; toEnd?: boolean; navigate?: boolean; shouldClearSelection?: boolean; isDebounced?: boolean; isPending?: boolean }) {\n    // Implement move active logic\n  }\n\n  private activate(payload: { item: PathToItem; keyboardActive: boolean; navigate?: boolean | \"refresh\"; shouldClearSelection?: boolean; maintainDirection?: boolean }) {\n    this.activeItem = payload.item;\n    this.keyboardActive = payload.keyboardActive;\n    if (payload.shouldClearSelection) {\n      this.selectedItems = [];\n    }\n  }\n\n  private addToSelection(payload: { direction: Direction; selectActiveItemImmediately?: boolean }) {\n    // Implement add to selection logic\n  }\n\n  private handleTabPress(event: React.KeyboardEvent | KeyboardEvent) {\n    // Implement tab press logic\n  }\n\n  private select(items: PathToItem[]) {\n    this.selectedItems = items;\n    if (items.length > 0) {\n      this.activeItem = items[0];\n      this.focusedItem = items[0];\n    }\n  }\n\n  private selectBetween(items: [PathToItem, PathToItem]) {\n    // Implement select between logic\n  }\n\n  private deactivate() {\n    this.previouslyActiveItem = this.activeItem;\n    this.activeItem = null;\n    this.keyboardActive = false;\n  }\n\n  private focus(payload: { item: PathToItem }) {\n    this.focusedItem = payload.item;\n    this.activeItem = payload.item;\n    this.keyboardActive = true;\n  }\n\n  private clearSelection() {\n    this.selectedItems = [];\n    this.focusedItem = null;\n    this.keyboardActive = false;\n  }\n\n  private shiftSelect(item?: PathToItem) {\n    // Implement shift select logic\n  }\n\n  private cmdSelect(item?: PathToItem) {\n    // Implement command select logic\n  }\n\n  private selectAllInGroup(payload: PathToItem) {\n    // Implement select all in group logic\n  }\n\n  private selectAll() {\n    // Implement select all logic\n  }\n\n  private goToEnd() {\n    // Implement go to end logic\n  }\n\n  private goToStart() {\n    // Implement go to start logic\n  }\n\n  private clearKeyboardActive() {\n    this.keyboardActive = false;\n  }\n\n  private setKeyboardActive() {\n    this.keyboardActive = true;\n  }\n\n  private activateNextAvailableItem(item: PathToItem) {\n    // Implement activate next available item logic\n  }\n}\n```\n\nThis implementation adds an `updateState` method to the `GroupedListState` class. This method takes a `ViewSelectionAction` as an argument and updates the state based on the action type. \n\nEach action type is handled in a separate private method, which allows for better organization and easier maintenance of the code. Some of the methods (like `moveActive`, `addToSelection`, etc.) are left as placeholders, as their implementation would depend on the specific requirements of your application.\n\nNote that some actions (like `navigateToActive` and `openSelectionInTabs`) might require external handling, as they seem to involve operations outside the scope of just updating the state.\n\nAlso, I've made the `updateState` method an action using MobX's `action` decorator to ensure that all state modifications are tracked properly by MobX.\n\nYou can use this method like this:\n\n```typescript\nconst state = new GroupedListState({});\nstate.updateState({ type: \"activate\", payload: { item: [0, 1], keyboardActive: true } });\n```\n\nThis will update the state according to the \"activate\" action. You'll need to implement the logic for each action type based on your specific requirements.\ncan you implement the shiftSelect method? Look at the logic in useGroupedViewSelection.\nCertainly! I'll implement the `shiftSelect` method based on the logic in the `useGroupedViewSelection` hook. Here's how we can implement it:\n\n```typescript\nimport { makeObservable, action, observable } from \"mobx\";\n\nclass GroupedListState {\n  @observable public focusedItem: PathToItem | null = null;\n  @observable public activeItem: PathToItem | null = null;\n  @observable public previouslyActiveItem: PathToItem | null = null;\n  @observable public keyboardActive: boolean = false;\n  @observable public selectedItems: PathToItem[] = [];\n  @observable public navigationDirection: Direction = Direction.DownRight;\n  @observable public initialSelectedItem: PathToItem | null = null;\n\n  constructor(options: { initialActiveItem?: PathToItem }) {\n    if (options.initialActiveItem) {\n      this.activeItem = options.initialActiveItem;\n    }\n    makeObservable(this);\n  }\n\n  @action\n  private shiftSelect(item?: PathToItem) {\n    const startShiftSelectItem = item ?? this.activeItem;\n    if (!startShiftSelectItem) {\n      return;\n    }\n\n    this.previouslyActiveItem = null;\n    this.initialSelectedItem = this.initialSelectedItem || startShiftSelectItem;\n    this.activeItem = startShiftSelectItem;\n    this.focusedItem = startShiftSelectItem;\n\n    if (this.initialSelectedItem) {\n      this.selectedItems = this.getItemsBetween(\n        startShiftSelectItem,\n        this.initialSelectedItem\n      );\n    } else {\n      this.selectedItems = [startShiftSelectItem];\n    }\n  }\n\n  private getItemsBetween(from: PathToItem, to: PathToItem): PathToItem[] {\n    // This is a simplified version. You'll need to implement the full logic\n    // based on your specific data structure and requirements.\n    const start = Math.min(from[0], to[0]);\n    const end = Math.max(from[0], to[0]);\n    const items: PathToItem[] = [];\n\n    for (let i = start; i <= end; i++) {\n      items.push([i]);\n    }\n\n    return items;\n  }\n\n  @action\n  public updateState(action: ViewSelectionAction): void {\n    switch (action.type) {\n      case \"shiftSelect\":\n        this.shiftSelect(action.payload);\n        break;\n      // ... other cases ...\n    }\n  }\n\n  // ... other methods ...\n}\n```\n\nIn this implementation:\n\n1. We've added an `initialSelectedItem` property to keep track of the starting point for shift-select operations.\n\n2. The `shiftSelect` method now closely follows the logic from the `useGroupedViewSelection` hook:\n   - It uses the provided item or falls back to the current `activeItem`.\n   - It updates `previouslyActiveItem`, `initialSelectedItem`, `activeItem`, and `focusedItem`.\n   - It calculates the selected items using a `getItemsBetween` method.\n\n3. The `getItemsBetween` method is a simplified version. In a real implementation, you'd need to adapt this to your specific data structure and requirements. It should handle different dimensions (for boards vs. lists), consider hidden groups and subgroups, and possibly preserve gaps in the existing selection.\n\n4. We've made the relevant properties `observable` and the methods `action` to work with MobX.\n\n5. The `updateState` method now includes the case for \"shiftSelect\" action.\n\nTo use this in your application:\n\n```typescript\nconst state = new GroupedListState({});\nstate.updateState({ type: \"shiftSelect\", payload: [1, 0] });\n```\n\nThis will perform a shift-select operation starting from the item at path [1, 0].\n\nNote that this implementation is still somewhat simplified. Depending on your exact requirements, you might need to:\n\n1. Implement a more sophisticated `getItemsBetween` method that considers your full data structure.\n2. Add logic to handle hidden groups and subgroups.\n3. Implement logic to preserve gaps in existing selections if that's a requirement.\n4. Add checks to prevent selection if multi-select is disabled.\n5. Implement navigation effects if needed in a split-view scenario.\n\nYou would need to adapt these based on your specific application structure and requirements.\ndo the same for cmdSelect please\nCertainly! I'll implement the `cmdSelect` method based on the logic in the `useGroupedViewSelection` hook. Here's how we can implement it:\n\n```typescript\nimport { makeObservable, action, observable } from \"mobx\";\n\nclass GroupedListState {\n  @observable public focusedItem: PathToItem | null = null;\n  @observable public activeItem: PathToItem | null = null;\n  @observable public previouslyActiveItem: PathToItem | null = null;\n  @observable public keyboardActive: boolean = false;\n  @observable public selectedItems: PathToItem[] = [];\n  @observable public navigationDirection: Direction = Direction.DownRight;\n  @observable public initialSelectedItem: PathToItem | null = null;\n\n  private isSplitView: boolean = false;\n  private multiSelectDisabled: boolean = false;\n\n  constructor(options: { \n    initialActiveItem?: PathToItem,\n    isSplitView?: boolean,\n    multiSelectDisabled?: boolean\n  }) {\n    if (options.initialActiveItem) {\n      this.activeItem = options.initialActiveItem;\n    }\n    this.isSplitView = options.isSplitView || false;\n    this.multiSelectDisabled = options.multiSelectDisabled || false;\n    makeObservable(this);\n  }\n\n  @action\n  private cmdSelect(item?: PathToItem) {\n    const startCmdSelectItem = item ?? this.activeItem;\n    if (!startCmdSelectItem || this.multiSelectDisabled) {\n      return;\n    }\n\n    const oldSelectedItems = this.isSplitView && this.activeItem\n      ? this.uniqueItems([...this.selectedItems, this.activeItem])\n      : this.selectedItems;\n\n    if (this.isItemInSelection(startCmdSelectItem, oldSelectedItems)) {\n      const selectedItems = oldSelectedItems.filter(i => !this.areItemsEqual(i, startCmdSelectItem));\n      if (selectedItems.length > 0) {\n        this.focusedItem = selectedItems[selectedItems.length - 1];\n        this.selectedItems = selectedItems;\n      } else {\n        this.focusedItem = null;\n        this.initialSelectedItem = null;\n        this.selectedItems = [];\n      }\n    } else {\n      this.activeItem = startCmdSelectItem;\n      this.focusedItem = startCmdSelectItem;\n      this.initialSelectedItem = startCmdSelectItem;\n      this.selectedItems = [...oldSelectedItems, startCmdSelectItem].sort(this.itemSort);\n    }\n  }\n\n  private uniqueItems(items: PathToItem[]): PathToItem[] {\n    return items.filter((item, index, self) =>\n      index === self.findIndex((t) => this.areItemsEqual(t, item))\n    );\n  }\n\n  private isItemInSelection(item: PathToItem, selection: PathToItem[]): boolean {\n    return selection.some(selectedItem => this.areItemsEqual(selectedItem, item));\n  }\n\n  private areItemsEqual(a: PathToItem, b: PathToItem): boolean {\n    return a.length === b.length && a.every((value, index) => value === b[index]);\n  }\n\n  private itemSort(a: PathToItem, b: PathToItem): number {\n    for (let i = 0; i < Math.min(a.length, b.length); i++) {\n      if (a[i] !== b[i]) return a[i] - b[i];\n    }\n    return a.length - b.length;\n  }/\n\n  @action\n  public updateState(action: ViewSelectionAction): void {\n    switch (action.type) {\n      case \"cmdSelect\":\n        this.cmdSelect(action.payload);\n        break;\n      // ... other cases ...\n    }\n  }\n\n  // ... other methods ...\n}\n```\n\nIn this implementation:\n\n1. We've added `isSplitView` and `multiSelectDisabled` properties to the class, as these are used in the `cmdSelect` logic. They're set in the constructor.\n\n2. The `cmdSelect` method now closely follows the logic from the `useGroupedViewSelection` hook:\n   - It uses the provided item or falls back to the current `activeItem`.\n   - It checks if multi-select is disabled.\n   - It handles the special case for split view.\n   - It toggles the selection of the item: if it's already selected, it's removed; if it's not selected, it's added.\n   - It updates `activeItem`, `focusedItem`, `initialSelectedItem`, and `selectedItems` accordingly.\n\n3. We've added several helper methods:\n   - `uniqueItems`: Removes duplicate items from an array.\n   - `isItemInSelection`: Checks if an item is in the selection.\n   - `areItemsEqual`: Compares two items for equality.\n   - `itemSort`: Sorts items for consistent ordering.\n\n4. The `updateState` method now includes the case for \"cmdSelect\" action.\n\nTo use this in your application:\n\n```typescript\nconst state = new GroupedListState({ isSplitView: true, multiSelectDisabled: false });\nstate.updateState({ type: \"cmdSelect\", payload: [1, 0] });\n```\n\nThis will perform a command-select operation on the item at path [1, 0].\n\nNote that this implementation assumes that:\n\n1. `PathToItem` is an array of numbers (like [1, 0, 2]).\n2. The sorting of items is based on their path values.\n\nYou might need to adjust these assumptions based on your specific data structure and requirements. Also, remember that this implementation doesn't include any navigation effects that might be needed in a split-view scenario - you'd need to handle those separately if required.\nimplement the getItemsBetween method\nCertainly! I'll implement the `getItemsBetween` method based on the logic from the `useGroupedViewSelection` hook. This method is more complex as it needs to handle various scenarios, including hidden groups and subgroups, and potentially preserving gaps in the selection. Here's an implementation:\n\n```typescript\nimport { makeObservable, action, observable } from \"mobx\";\n\nclass GroupedListState {\n  @observable public focusedItem: PathToItem | null = null;\n  @observable public activeItem: PathToItem | null = null;\n  @observable public previouslyActiveItem: PathToItem | null = null;\n  @observable public keyboardActive: boolean = false;\n  @observable public selectedItems: PathToItem[] = [];\n  @observable public navigationDirection: Direction = Direction.DownRight;\n  @observable public initialSelectedItem: PathToItem | null = null;\n\n  private provider: AnyGroupedDataProvider;\n  private hiddenGroups: string[];\n  private hiddenSubGroups: string[];\n\n  constructor(options: {\n    initialActiveItem?: PathToItem;\n    provider: AnyGroupedDataProvider;\n    hiddenGroups: string[];\n    hiddenSubGroups: string[];\n  }) {\n    this.provider = options.provider;\n    this.hiddenGroups = options.hiddenGroups;\n    this.hiddenSubGroups = options.hiddenSubGroups;\n    if (options.initialActiveItem) {\n      this.activeItem = options.initialActiveItem;\n    }\n    makeObservable(this);\n  }\n\n  private getItemsBetween(args: {\n    from: PathToItem;\n    to: PathToItem;\n    preserveGaps: boolean;\n  }): PathToItem[] {\n    const { from, to, preserveGaps } = args;\n\n    // Sort the items\n    const [firstItem, lastItem] = this.sortItems(from, to);\n\n    // Get all items for clusters in between\n    const allItems: PathToItem[] = [];\n\n    // Get the groups in between\n    const groupsCount = Math.abs(firstItem[0] - lastItem[0]) + 1;\n    const groups = Array.from({ length: groupsCount }).map(\n      (_, i) => i + Math.min(firstItem[0], lastItem[0])\n    );\n\n    for (const groupIndex of groups) {\n      const hasSubGroups = firstItem.length > 1 && lastItem.length > 1;\n      const subGroupCount = this.provider.subGroupCounts?.length ?? 1;\n\n      const lowestSubGroupIndex = Math.min(firstItem[1] ?? 0, lastItem[1] ?? 0);\n      const highestSubGroupIndex = Math.max(\n        firstItem[1] ?? subGroupCount - 1,\n        lastItem[1] ?? subGroupCount - 1\n      );\n\n      // Get the sub groups in between\n      const subGroupsBetweenCount = Math.abs(highestSubGroupIndex - lowestSubGroupIndex) + 1;\n      const subGroups = Array.from({ length: subGroupsBetweenCount }).map((_, index) => index + lowestSubGroupIndex);\n\n      for (const subGroupIndex of subGroups) {\n        const cluster = hasSubGroups ? [groupIndex, subGroupIndex] : [groupIndex];\n\n        if (this.clusterIsHidden(cluster)) {\n          continue;\n        }\n\n        const clusterItemCount = this.getClusterItemCount(cluster);\n        const highestIndexInCluster = this.areItemsEqual(lastItem, cluster)\n          ? lastItem[lastItem.length - 1]\n          : clusterItemCount - 1;\n        const lowestIndexInCluster = this.areItemsEqual(firstItem, cluster)\n          ? firstItem[firstItem.length - 1]\n          : 0;\n\n        const itemsInClusterCount = highestIndexInCluster - lowestIndexInCluster + 1;\n        const itemsInCluster = Array.from({ length: itemsInClusterCount }).map((_, index) => {\n          const item: PathToItem = [...cluster, index + lowestIndexInCluster];\n          return item;\n        });\n        allItems.push(...itemsInCluster);\n      }\n    }\n\n    if (preserveGaps && this.selectedItems.length > 1) {\n      const lastSelected = this.selectedItems[this.selectedItems.length - 1];\n      const firstSelected = this.selectedItems[0];\n\n      return allItems\n        .filter(item => {\n          const isAfterLast = this.isItemAfter(item, lastSelected);\n          const isBeforeFirst = this.isItemBefore(item, firstSelected);\n\n          if (isAfterLast || isBeforeFirst) {\n            return true;\n          } else if (!this.selectedItems.some(i => this.areItemsEqual(i, item))) {\n            return false;\n          }\n          return true;\n        })\n        .sort(this.itemSort);\n    } else {\n      return allItems.sort(this.itemSort);\n    }\n  }\n\n  private sortItems(a: PathToItem, b: PathToItem): [PathToItem, PathToItem] {\n    return this.itemSort(a, b) <= 0 ? [a, b] : [b, a];\n  }\n\n  private clusterIsHidden(cluster: PathToItem): boolean {\n    const groupId = this.provider.modelForGroup(cluster[0])?.id;\n    if (groupId && this.hiddenGroups.includes(groupId)) {\n      return true;\n    }\n    if (cluster.length > 1) {\n      const subGroupId = this.provider.modelForSubGroup(cluster[1])?.id;\n      if (subGroupId && this.hiddenSubGroups.includes(subGroupId)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private getClusterItemCount(cluster: PathToItem): number {\n    if (cluster.length > 1) {\n      return this.provider.clusterCounts?.[cluster[0]]?.[cluster[1]] ?? 0;\n    }\n    return this.provider.groupCounts[cluster[0]] ?? 0;\n  }\n\n  private isItemAfter(a: PathToItem, b: PathToItem): boolean {\n    return this.itemSort(a, b) > 0;\n  }\n\n  private isItemBefore(a: PathToItem, b: PathToItem): boolean {\n    return this.itemSort(a, b) < 0;\n  }\n\n  private areItemsEqual(a: PathToItem, b: PathToItem): boolean {\n    return a.length === b.length && a.every((value, index) => value === b[index]);\n  }\n\n  private itemSort(a: PathToItem, b: PathToItem): number {\n    for (let i = 0; i < Math.min(a.length, b.length); i++) {\n      if (a[i] !== b[i]) return a[i] - b[i];\n    }\n    return a.length - b.length;\n  }\n\n  // ... other methods ...\n}\n```\n\nThis implementation of `getItemsBetween` closely follows the logic from the `useGroupedViewSelection` hook. Here's a breakdown of what it does:\n\n1. It sorts the 'from' and 'to' items to determine the first and last items in the range.\n\n2. It iterates through all groups and subgroups (if applicable) between the first and last items.\n\n3. For each cluster (group or subgroup), it checks if it's hidden. If not, it generates all items within that cluster that fall within the range.\n\n4. If `preserveGaps` is true and there are multiple selected items, it filters the items to maintain gaps in the existing selection. This means it includes items that are after the last selected item, before the first selected item, or already in the selection.\n\n5. Finally, it sorts all the items and returns them.\n\nThe method relies on several helper methods:\n\n- `sortItems`: Determines which of two items comes first.\n- `clusterIsHidden`: Checks if a group or subgroup is hidden.\n- `getClusterItemCount`: Gets the number of items in a cluster.\n- `isItemAfter` and `isItemBefore`: Compare the positions of two items.\n- `areItemsEqual`: Checks if two items are the same.\n- `itemSort`: Defines the sorting order for items.\n\nThis implementation assumes that:\n\n1. `PathToItem` is an array of numbers where the first element is the group index, the second (if present) is the subgroup index, and the last is the item index within the group/subgroup.\n2. The `provider` has methods like `modelForGroup`, `modelForSubGroup`, and properties like `groupCounts`, `subGroupCounts`, and `clusterCounts`.\n3. Hidden groups and subgroups are identified by their IDs.\n\nYou might need to adjust these assumptions based on your specific data structure and requirements. Also, you may need to add error handling and edge case management depending on your use case.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":537}},"image_offsets":[]},{"id":{"replica_id":0,"value":229},"start":73358,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":538}},"image_offsets":[]},{"id":{"replica_id":0,"value":230},"start":79660,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":539}},"image_offsets":[]},{"id":{"replica_id":0,"value":311},"start":79748,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":540}},"image_offsets":[]},{"id":{"replica_id":0,"value":312},"start":83692,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":541}},"image_offsets":[]},{"id":{"replica_id":0,"value":361},"start":83725,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":542}},"image_offsets":[]},{"id":{"replica_id":0,"value":362},"start":88615,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":543}},"image_offsets":[]},{"id":{"replica_id":0,"value":485},"start":88652,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":544}},"image_offsets":[]},{"id":{"replica_id":0,"value":486},"start":96103,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":545}},"image_offsets":[]}],"summary":"Implementation of GroupedListState with selection methods","slash_command_output_sections":[{"range":{"start":0,"end":3864},"icon":"File","label":"linear-app/orbiter/src/components/useGroupedListNavigation.ts"},{"range":{"start":3865,"end":73243},"icon":"File","label":"linear-app/client/src/hooks/selection/useGroupedViewSelection.ts"}]}