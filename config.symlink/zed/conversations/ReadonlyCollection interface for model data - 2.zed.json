{"id":"aa7f620a-931a-46f8-858d-d6e722e5d162","zed":"context","version":"0.4.0","text":"\n\n\n```ts linear-app/client/src/models/collections/ReadonlyCollection.ts\nimport { Model } from \"~/models/base/Model\";\nimport { CachedPromise } from \"~/models/hydration/CachedPromise\";\nimport { Logger } from \"~/logging/Logger\";\nimport { NonHydratedAccessManager } from \"~/components/DeveloperToolbar/NonHydratedAccessIndicator\";\nimport { HydrationDebug } from \"~/views/Debug/HydrationDebug\";\nimport type { Hydrated } from \"../base/ModelTypes\";\nimport { type CollectionGroup, GroupedCollection } from \"./CollectionGroup\";\nimport { type CollectionFilter, CollectionOrder, FilteredCollection, OrderedCollection, type Predicate } from \"./\";\n\n/**\n * An abstract Collection class that provides functionality to read, map and filter elements that it contains.\n *\n * ReadonlyCollections cannot be instantiated, but should be used as the type whenever you want to denote that\n * the consumer should not be able to make changes to the collection that it consumes.\n *\n * All collections extends from the ReadonlyCollection class and provide additional functionality.\n */\nexport abstract class ReadonlyCollection<T extends Model> {\n  /**\n   * The first element in the collection.\n   */\n  public get first(): T | undefined {\n    return this.length > 0 ? this.elements[0] : undefined;\n  }\n\n  /**\n   * The last element in the collection.\n   */\n  public get last(): T | undefined {\n    return this.length > 0 ? this.elements[this.elements.length - 1] : undefined;\n  }\n\n  /** The elements of the collection. */\n  public abstract elements: T[];\n\n  /**\n   * The elements in the collection that have been fully hydrated. This will synchronously return all the elements that\n   * have been hydrated, but might not contain all elements that are part of the collection. If used on a\n   * `LazyCollection`, this will also kick off the hydration of the contents of the collection.\n   *\n   * Accessing `hydratedElements` will also kick of a hydration of any un-hydrated models of the collection, so you can\n   * expect any observers to get re-rendered immediately after hydration has finished.\n   */\n  public get hydratedElements(): Hydrated<T>[] {\n    const hydratedElements: Hydrated<T>[] = [];\n    const hydrationPromises: CachedPromise<Hydrated<T>>[] = [];\n    for (const element of this.elements) {\n      if (element.isHydrated()) {\n        hydratedElements.push(element);\n      } else {\n        hydrationPromises.push(element.hydrate());\n      }\n    }\n\n    if (hydrationPromises.length) {\n      void CachedPromise.allResolved(hydrationPromises)\n        .then(this.afterHydrate)\n        .catch(() => {\n          // No-op\n        });\n      if (Model.store.developerOptions?.nonHydratedCollectionHydratedElementsDebug && !this.hydrationElementsPromise) {\n        NonHydratedAccessManager.registerAccess();\n        Logger.info(`Hydration: Accessing hydrated elements before triggering elements hydration`);\n      }\n    }\n    return hydratedElements;\n  }\n\n  /**\n   * The number of elements in the collection, only counting fully hydrated ones. This will also kick off hydration of\n   * any non-hydrated models.\n   */\n  public get hydratedLength(): number {\n    return this.hydratedElements.length;\n  }\n\n  /** The number of elements in the collection. */\n  public get length(): number {\n    return this.elements.length;\n  }\n\n  /**\n   * Finds the index of a model object in the collection.\n   *\n   * @param model The model object to find.\n   * @returns The index of the model object in the collection or -1, if the model object wasn't in the collection.\n   */\n  public indexOf(model: T): number {\n    return this.elements.indexOf(model);\n  }\n\n  /**\n   * Finds the index of a model id in the collection.\n   *\n   * @param modelId The id of the model to find.\n   * @returns The index of the model with the given id in the collection or -1, if a model with the given id wasn't\n   * in the collection.\n   */\n  public indexOfId(modelId: string): number {\n    // Using a local variable in case it was overridden with a getter involving computations to get those elements\n    const elements = this.elements;\n    for (let i = 0, l = elements.length; i < l; ++i) {\n      if (elements[i].id === modelId) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns whether the collection contains the given model object.\n   *\n   * @param model The model object to check.\n   * @returns True if the model object is in the collection, false otherwise.\n   */\n  public contains(model: T): boolean {\n    return this.elements.indexOf(model) !== -1;\n  }\n\n  /**\n   * Finds a model by its id. This has a constant lookup time.\n   *\n   * @param id The id of the model to find.\n   * @returns The model with the corresponding id or undefined, if no model with the give id existed.\n   */\n  public findById(id: string): T | undefined {\n    for (const element of this.elements) {\n      if (element.id === id) {\n        return element;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns a slice of the Collection.\n   *\n   * @param start The index at which to start the slice at.\n   * @param end The index at which to end the slice at.\n   * @returns The sliced elements.\n   */\n  public slice(start: number, end?: number): T[] {\n    return this.elements.slice(start, end);\n  }\n\n  /**\n   * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n   *\n   * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one\n   * time for each element in the array.\n   * @returns The mapped elements.\n   */\n  public map<U>(callbackfn: (value: T, index: number, array: T[]) => U): U[] {\n    return this.elements.map(callbackfn);\n  }\n\n  /**\n   * Calls a defined callback function on each element of an array. Then, flattens the result into\n   * a new array.\n   *\n   * @param callbackfn A function that accepts up to three arguments. The flatMap method calls the\n   * callback function one time for each element in the array.\n   * @returns The mapped elements.\n   */\n  public flatMap<U>(callbackfn: (value: T, index: number, array: T[]) => U[]): U[] {\n    return this.elements.flatMap(callbackfn);\n  }\n\n  /**\n   * Calls the specified callback function for all the elements in the collection, in descending order. The return\n   * value of the callback function is the accumulated result, and is provided as an argument in the next call to the\n   * callback function.\n   *\n   * @param callback A function that accepts up to four arguments. The reduceRight method calls the callbackfn\n   * function one time for each element in the array.\n   * @param initialValue The initial value of the reduce operation.\n   */\n  public reduce<U>(\n    callback: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U,\n    initialValue: U\n  ): U {\n    return this.elements.reduce(callback, initialValue);\n  }\n\n  /**\n   * Performs the specified action for each element in an array. This is done safely to avoid changes to underlying array.\n   *\n   * @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time\n   * for each element in the array.\n   */\n  public forEach(callbackfn: (value: T, index: number, array: T[]) => void) {\n    const elements = this.elements.concat();\n    for (let i = 0, l = elements.length; i < l; ++i) {\n      callbackfn(elements[i], i, elements);\n    }\n  }\n\n  /**\n   * Finds the first model matching the predicate function.\n   *\n   * @param predicate A function that Array#find's arguments\n   * @returns The found model or undefined, if no model was found.\n   */\n  public find(predicate: (value: T, index: number, array: T[]) => boolean): T | undefined {\n    return this.elements.find(predicate);\n  }\n\n  /**\n   * Finds the first model matching the predicate function.\n   *\n   * @param predicate A function that Array#findLast's arguments\n   * @returns The found model or undefined, if no model was found.\n   */\n  public findLast(predicate: (value: T, index: number, array: T[]) => boolean): T | undefined {\n    // Built-in Array#findLast is not supported in older browsers\n    for (let index = this.elements.length - 1; index >= 0; index--) {\n      if (predicate(this.elements[index], index, this.elements)) {\n        return this.elements[index];\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Determines whether the specified callback function returns true for any element of an array.\n   *\n   * @param predicate A function that Array#some's arguments\n   * @returns Boolean to indicate if object matching the predicate was found.\n   */\n  public some(predicate: (value: T, index: number, array: T[]) => boolean): boolean {\n    return this.elements.some(predicate);\n  }\n\n  /**\n   * Determines whether the specified callback function returns true for all elements of an array.\n   *\n   * @param predicate A function that Array#every's arguments\n   * @returns Boolean to indicate if object matching the predicate was found.\n   */\n  public every(predicate: (value: T, index: number, array: T[]) => boolean): boolean {\n    return this.elements.every(predicate);\n  }\n\n  /**\n   * Returns the index of the first element in the array where predicate is true, and -1 otherwise.\n   *\n   * @param predicate A function that Array#findIndex's arguments\n   * @returns The found index or -1, if no model was found.\n   */\n  public findIndex(predicate: (value: T, index: number, array: T[]) => boolean): number {\n    return this.elements.findIndex(predicate);\n  }\n\n  /**\n   * Returns a new collection filtered based on the given `CollectionFilter` or predicate. The returned collection is\n   * associated with the `CollectionFilter` or predicate and updates whenever the contents of the parent collection\n   * changes or the `CollectionFilter` is changed.\n   *\n   * @param filter: The collection filter or predicate to use to filter the returned collection. If undefined is\n   * passed, the unfiltered collection is returned.\n   * @returns A collection that is filtered based on the given `CollectionFilter`.\n   */\n  public filter(\n    filter: CollectionFilter<T> | Predicate<T> | (CollectionFilter<T> | Predicate<T>)[] | undefined\n  ): ReadonlyCollection<T> {\n    if (filter === undefined) {\n      return this;\n    }\n    return new FilteredCollection<T>(this, filter);\n  }\n\n  /**\n   * Returns a new collection, inverse filtered based on the given `CollectionFilter` or predicate. The returned collection is\n   * associated with the `CollectionFilter` or predicate and updates whenever the contents of the parent collection\n   * changes or the `CollectionFilter` is changed.\n   *\n   * @param filter: The collection filter or predicate to use to filter the returned collection. If undefined is\n   * passed, the unfiltered collection is returned.\n   * @returns A collection that is filtered based on the given `CollectionFilter`.\n   */\n  public filterNot(\n    filter: CollectionFilter<T> | Predicate<T> | (CollectionFilter<T> | Predicate<T>)[] | undefined\n  ): ReadonlyCollection<T> {\n    if (filter === undefined) {\n      return this;\n    }\n    return new FilteredCollection<T>(this, filter, { inverseFilter: true });\n  }\n\n  /**\n   * Splits up a collection based on a predicate. This returns two arrays, where the first contains all elements\n   * that were matched by the predicate. The second array contains all elements that the\n   * predicate didn't match.\n   *\n   * @param predicate The collection predicate to use to split the collection.\n   * @returns Two arrays containing the matched and missed elements of the collection.\n   */\n  public split(predicate: Predicate<T>): [T[], T[]] {\n    const hit: T[] = [];\n    const miss: T[] = [];\n    // Using a local variable in case it was overridden with a getter involving computations to get those elements\n    const elements = this.elements;\n\n    for (let i = 0, l = elements.length; i < l; ++i) {\n      const element = elements[i];\n      if (predicate(element, i, elements)) {\n        hit.push(element);\n      } else {\n        miss.push(element);\n      }\n    }\n    return [hit, miss];\n  }\n\n  /**\n   * Returns an ordered collection.\n   *\n   * @param field The field of the model to order by.\n   * @param order The sort order for the field. Defaults to ascending.\n   * @returns A collection that is sorted based on the field and sort order.\n   */\n  public orderBy(field: keyof T, order?: \"asc\" | \"desc\"): ReadonlyCollection<T>;\n\n  /**\n   * Returns a new collection ordered based on the given `CollectionOrder`. The returned collection is associated with\n   * the `CollectionOrder` and updates whenever the contents of the parent collection changes or the `CollectionOrder`\n   * is changed.\n   *\n   * @param filter: The collection filter or predicate to use to filter the returned collection.\n   * @returns A collection that is filtered based on the given `CollectionFilter`.\n   */\n  public orderBy(collectionOrder: CollectionOrder<T>): ReadonlyCollection<T>;\n\n  /**\n   * Returns a new collection ordered based on the given `CollectionOrder`. The returned collection is associated with\n   * the `CollectionOrder` and updates whenever the contents of the parent collection changes or the `CollectionOrder`\n   * is changed.\n   *\n   * @param filter: The collection filter or predicate to use to filter the returned collection.\n   * @returns A collection that is filtered based on the given `CollectionFilter`.\n   */\n  public orderBy(\n    fieldOrCollectionOrder: CollectionOrder<T> | keyof T,\n    order: \"asc\" | \"desc\" = \"asc\"\n  ): ReadonlyCollection<T> {\n    if (fieldOrCollectionOrder instanceof CollectionOrder) {\n      return new OrderedCollection<T>(this, fieldOrCollectionOrder);\n    } else {\n      return new OrderedCollection<T>(this, new CollectionOrder<T>(fieldOrCollectionOrder, order));\n    }\n  }\n\n  /**\n   * Groups the collection by one of its keys.\n   *\n   * @param key The key to group the collection by.\n   * @param orderBy The collection order to order the groups by.\n   * @returns A grouped collection.\n   */\n  public groupBy<K extends keyof T>(key: K, orderBy?: CollectionOrder<CollectionGroup<K, T>>): GroupedCollection<K, T> {\n    return new GroupedCollection(this, key, orderBy);\n  }\n\n  /** Disallow direct index access. */\n  [index: number]: undefined;\n\n  /** Make collections iterable */\n  public [Symbol.iterator]() {\n    let index = 0;\n    const data = this.elements;\n\n    return {\n      next: () => ({ value: data[index++], done: index > data.length }),\n    };\n  }\n\n  /**\n   * Kicks off hydration of all the elements in the collection. If used on a `LazyCollection`, this will also kick off\n   * the hydration of the contents of the collection.\n   *\n   * Promise will be invalidated every time new non-hydrated element is added to the collection. Make sure you use this\n   * in combination with useResolvePromise with right memoization if you do not want to re-trigger component suspense\n   * on new non-hydrated elements.\n   *\n   * @options The options to use for the hydration.\n   * @returns A promise that resolves when all elements have been hydrated. Note that it is possible that during the\n   * hydration process, new, un-hydrated elements are added to the collection which will invalidate and create the\n   * promise.\n   */\n  public hydrateElements(options?: HydrationOptions): CachedPromise<unknown> {\n    const hash = this.elements.map(e => e.id).join(\",\");\n    if (this.hydrationElementsPromise && this.hydrationElementsPromiseHash !== hash) {\n      this.hydrationElementsPromiseHash = undefined;\n      this.hydrationElementsPromise = undefined;\n    }\n\n    if (this.hydrationElementsPromise) {\n      return this.hydrationElementsPromise;\n    }\n    if (HydrationDebug.enabled) {\n      HydrationDebug.record({\n        type: \"hydrateElements\",\n        options,\n        modelName: this.elements[0]?.modelName,\n      });\n    }\n    this.hydrationElementsPromiseHash = hash;\n    this.hydrationElementsPromise = new CachedPromise<void>((resolve, reject) => {\n      if (this.elements.length === 0) {\n        return resolve();\n      }\n      const hydrationPromises: CachedPromise<Hydrated<T>>[] = [];\n      for (const element of this.elements) {\n        if (!element.isHydrated()) {\n          hydrationPromises.push(element.hydrate(options));\n        }\n      }\n      if (hydrationPromises.length) {\n        CachedPromise.allResolved(hydrationPromises)\n          .then(resolve)\n          .catch(error => {\n            this.invalidateRejectedWhenRequested();\n            reject(error);\n          });\n      } else {\n        resolve();\n      }\n    });\n    return this.hydrationElementsPromise;\n  }\n\n  // -- Protected interface\n\n  /**\n   * Hook to run after hydrating all elements in the collection. By default, does nothing, but can be overridden by\n   * subclasses.\n   */\n  protected afterHydrate(): void {\n    // No-op\n  }\n\n  /** Subscribe Collection instance to `onInvalidateRejectedHydrations` signal. */\n  protected invalidateRejectedWhenRequested() {\n    if (!this._invalidateRejectedWhenRequestedSubscribed) {\n      Model.store.onInvalidateRejectedHydrations.subscribeOnce(() => this.invalidateRejectedHydrationPromises());\n      this._invalidateRejectedWhenRequestedSubscribed = true;\n    }\n  }\n\n  /** Invalidates the rejected hydration promises. */\n  protected invalidateRejectedHydrationPromises() {\n    if (this.hydrationElementsPromise?.error) {\n      this.hydrationElementsPromiseHash = undefined;\n      this.hydrationElementsPromise = undefined;\n    }\n    this._invalidateRejectedWhenRequestedSubscribed = false;\n  }\n\n  // -- Private interface\n\n  private hydrationElementsPromise: CachedPromise<void> | undefined;\n  private hydrationElementsPromiseHash: string | undefined;\n  private _invalidateRejectedWhenRequestedSubscribed?: boolean;\n}\n\n/** Options when hydrating models. */\nexport type HydrationOptions = {\n  /**\n   * Whether to skip cascading the hydration for properties that have been marked with `cascadeHydration`. You should\n   * only use this when there are very specific needs to optimize hydration. Defaults to false.\n   */\n  skipCascadeHydration?: boolean;\n};\n```\nextract an interface from this class\nTo extract an interface from the `ReadonlyCollection` class, we'll define an interface that includes all the public methods and properties. Here's the extracted interface:\n\n```typescript\nimport { Model } from \"~/models/base/Model\";\nimport { CachedPromise } from \"~/models/hydration/CachedPromise\";\nimport type { Hydrated } from \"../base/ModelTypes\";\nimport { type CollectionGroup, GroupedCollection } from \"./CollectionGroup\";\nimport { type CollectionFilter, CollectionOrder, type Predicate } from \"./\";\n\nexport interface IReadonlyCollection<T extends Model> {\n  readonly first: T | undefined;\n  readonly last: T | undefined;\n  readonly elements: T[];\n  readonly hydratedElements: Hydrated<T>[];\n  readonly hydratedLength: number;\n  readonly length: number;\n\n  indexOf(model: T): number;\n  indexOfId(modelId: string): number;\n  contains(model: T): boolean;\n  findById(id: string): T | undefined;\n  slice(start: number, end?: number): T[];\n  map<U>(callbackfn: (value: T, index: number, array: T[]) => U): U[];\n  flatMap<U>(callbackfn: (value: T, index: number, array: T[]) => U[]): U[];\n  reduce<U>(\n    callback: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U,\n    initialValue: U\n  ): U;\n  forEach(callbackfn: (value: T, index: number, array: T[]) => void): void;\n  find(predicate: (value: T, index: number, array: T[]) => boolean): T | undefined;\n  findLast(predicate: (value: T, index: number, array: T[]) => boolean): T | undefined;\n  some(predicate: (value: T, index: number, array: T[]) => boolean): boolean;\n  every(predicate: (value: T, index: number, array: T[]) => boolean): boolean;\n  findIndex(predicate: (value: T, index: number, array: T[]) => boolean): number;\n  filter(\n    filter: CollectionFilter<T> | Predicate<T> | (CollectionFilter<T> | Predicate<T>)[] | undefined\n  ): IReadonlyCollection<T>;\n  filterNot(\n    filter: CollectionFilter<T> | Predicate<T> | (CollectionFilter<T> | Predicate<T>)[] | undefined\n  ): IReadonlyCollection<T>;\n  split(predicate: Predicate<T>): [T[], T[]];\n  orderBy(field: keyof T, order?: \"asc\" | \"desc\"): IReadonlyCollection<T>;\n  orderBy(collectionOrder: CollectionOrder<T>): IReadonlyCollection<T>;\n  groupBy<K extends keyof T>(key: K, orderBy?: CollectionOrder<CollectionGroup<K, T>>): GroupedCollection<K, T>;\n  hydrateElements(options?: HydrationOptions): CachedPromise<unknown>;\n\n  [Symbol.iterator](): Iterator<T>;\n}\n\nexport type HydrationOptions = {\n  skipCascadeHydration?: boolean;\n};\n```\n\nThis interface, `IReadonlyCollection<T>`, captures all the public methods and properties of the `ReadonlyCollection` class. It can be used as a type for variables or parameters that need to work with read-only collections without being tied to the specific implementation of `ReadonlyCollection`.\n\nTo use this interface, you would update the `ReadonlyCollection` class declaration to implement it:\n\n```typescript\nexport abstract class ReadonlyCollection<T extends Model> implements IReadonlyCollection<T> {\n  // ... existing implementation ...\n}\n```\n\nThis way, you maintain the abstraction of the `ReadonlyCollection` class while providing a clear interface for consumers of the collection.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":927}},"image_offsets":[]},{"id":{"replica_id":0,"value":14},"start":18120,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":928}},"image_offsets":[]},{"id":{"replica_id":0,"value":15},"start":21289,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":929}},"image_offsets":[]}],"summary":"ReadonlyCollection interface for model data","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":18082},"icon":"File","label":"linear-app/client/src/models/collections/ReadonlyCollection.ts"}]}