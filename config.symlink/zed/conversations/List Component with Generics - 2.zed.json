{"id":"f421b46c-2d70-4cca-86bb-24f4083d91fc","zed":"context","version":"0.4.0","text":"\n\n\n```tsx linear-app/client/src/components/List/ListNew.tsx\nimport * as React from \"react\";\nimport { useHistory, useLocation } from \"react-router-dom\";\nimport debounce from \"lodash/debounce\";\nimport styled from \"styled-components\";\nimport type { LocationDescriptorObject } from \"history\";\nimport noop from \"lodash/noop\";\nimport { color, screenSize } from \"@linear/orbiter\";\nimport { Flex } from \"@linear/orbiter/components/Flex\";\nimport { useScrollChange } from \"@linear/orbiter/hooks/useScrollChange\";\nimport {\n  GroupedList,\n  type GroupedListRef,\n  type ListCellProps,\n} from \"@linear/orbiter/components/GroupedView/GroupedList\";\nimport { useScrollToActive, useUpdateActive } from \"@linear/orbiter/components/GroupedView/useGroupedViewHooks\";\nimport { type GroupedViewState, useGroupedViewState } from \"@linear/orbiter/components/GroupedView/GroupedViewState\";\nimport type { GroupedViewItem, GroupedViewItemKey } from \"@linear/orbiter/components/GroupedView/GroupedViewTypes\";\nimport { useComponentHeight } from \"@linear/orbiter/hooks/useComponentSize\";\nimport { useKeyPressEvent } from \"@linear/orbiter/hooks/useKeyPressEvent\";\nimport { KeyboardHelper } from \"@linear/orbiter/utils/KeyboardHelper\";\nimport { suspenseObserver } from \"~/components/suspenseObserver\";\nimport { useGroupedViewSelectionActions } from \"~/hooks/selection/useGroupedViewSelectionActionsNew\";\nimport { useLastActiveId } from \"~/hooks/useLastActiveId\";\nimport { useRegisterViewDataActionContext } from \"~/hooks/useRegisterViewDataActionContext\";\nimport { listColumnStyles, useListColumnWidths } from \"./components/ListColumn\";\nimport { GroupedViewDataContext } from \"./components/dataProviders/GroupedViewDataContext\";\nimport type { AnyDataProvider } from \"./components/dataProviders/AnyDataProvider\";\nimport { ViewPeek } from \"./ViewPeek\";\n\n/** Props for List component */\nexport type ListProps<T, M = unknown> = {\n  /** The data provider for the list or a function that generates the data provider. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  provider: AnyDataProvider<T, M>;\n  /** Function to get the pathname for an item. */\n  pathnameForItem(item: GroupedViewItem<T>): string | LocationDescriptorObject | undefined;\n  /** Empty state component. Displays while the list is empty and not loading */\n  emptyPlaceholder: React.ReactNode;\n  /** Optional flag to indicate if data is loading.  */\n  loading?: boolean;\n  /**\n   * Called when items are rendered. `lastItem` is the key of the last visible item. Debounced to avoid excessive calls.\n   */\n  onItemsRendered?(lastItem: GroupedViewItemKey): void;\n  /**\n   * Is the list rendered in a split view?\n   * This changes the behaviour of the list in a few ways â€”\n   * clicks and hover specifically works differently.\n   */\n  splitView?: boolean;\n  /**\n   * If set the list will activate and scroll to item with the given key.\n   */\n  initialActiveItemKey?: string;\n  /** Whether list cell should handle long press. Defaults to false */\n  withLongPress?: boolean;\n  /** Optional dependencies that when changed will re-calculate the column widths */\n  columnWidthsDeps?: unknown[];\n  /** Renderer for list items. Should return a <ListCell> */\n  itemComponent: React.ComponentType<ListCellProps<T>>;\n  /** Renderer for Peek.  */\n  peekComponent?: React.ComponentType<{\n    /** The item to render */\n    item: T;\n  }>;\n  /** How many levels from the root one should be sticky. 0 means no sticky header. */\n  stickyHeaderLevels: number;\n  /** Item heights */\n  heightPerLevel: number[];\n  /** Component that will be passed the viewState as a prop. Useful for reacting to state changes. */\n  stateHooksComponent?: React.ComponentType<StateHooksComponentProps<T>>;\n  /** Header element, rendered above the list */\n  header?: React.ReactNode;\n  /** Footer element, rendered at the end of the list */\n  footer?: React.ReactNode;\n  /**\n   * Height of the footer element. If provided, the footer will be hidden until visible.\n   * If not provided, the footer will always render to the dom.\n   */\n  footerHeight?: number;\n  /**\n   * Optional scrollRestorationId to use for the list.\n   */\n  scrollRestorationId?: string;\n  /** Padding at the top of the list */\n  paddingStart?: number;\n};\n\n/**\n * Page-size virtualized list component, that has support for selection, navigating between items etc. Driven by `GroupedDataProvider`.\n */\nexport const List = suspenseObserver(\n  React.forwardRef(function List_<T, M>(props: ListProps<T, M>, outerRef: React.RefObject<HTMLDivElement>) {\n    const {\n      provider,\n      emptyPlaceholder,\n      onItemsRendered,\n      stateHooksComponent: StateHooksComponent,\n      loading,\n      splitView,\n      heightPerLevel,\n      initialActiveItemKey,\n      pathnameForItem,\n      peekComponent,\n      itemComponent: ItemComponent,\n      columnWidthsDeps = [],\n      header,\n      footer,\n      footerHeight,\n      scrollRestorationId,\n      paddingStart,\n    } = props;\n\n    const history = useHistory();\n    const location = useLocation();\n\n    const lastActiveId = useLastActiveId();\n    const groupedListRef = React.useRef<GroupedListRef>(null);\n    const outerScrollContainerRef = React.useRef<HTMLDivElement>();\n    const listRef = React.useRef<HTMLDivElement>(null);\n    const innerRef = React.useRef<HTMLDivElement>(null);\n    const finalRef = outerRef || innerRef;\n    const height = useComponentHeight(listRef) || window.innerHeight;\n\n    const scrollbarOffset = outerScrollContainerRef.current\n      ? outerScrollContainerRef.current.offsetWidth - outerScrollContainerRef.current.clientWidth\n      : undefined;\n\n    const hasAnyActualItems = provider.filteredItems.length !== 0;\n\n    // Get widths for columns rendered in the list\n    const [widths, handleColumnWidthsUpdate] = useListColumnWidths(\n      finalRef,\n      [],\n      [location.pathname, ...columnWidthsDeps],\n      scrollbarOffset\n    );\n\n    const handleItemsRendered = React.useMemo(\n      () =>\n        debounce(() => {\n          const lastRenderedElement = finalRef.current?.querySelectorAll(\"[data-list-key]\");\n          const lastItem = lastRenderedElement?.[lastRenderedElement.length - 1]?.getAttribute(\n            \"data-list-key\"\n          ) as GroupedViewItemKey | null;\n          if (lastItem) {\n            onItemsRendered?.(lastItem);\n            handleColumnWidthsUpdate();\n          }\n        }, 50),\n      [onItemsRendered, scrollbarOffset]\n    );\n\n    React.useLayoutEffect(handleItemsRendered, []);\n\n    const displayEmptyState = !hasAnyActualItems && !loading;\n\n    const viewState = useGroupedViewState<T>(\n      provider.data,\n      (initialActiveItemKey ?? lastActiveId) as GroupedViewItemKey | undefined\n    );\n    useGroupedViewSelectionActions({ viewState });\n    useScrollToActive(viewState, groupedListRef);\n    useUpdateActive(viewState, provider.data);\n\n    React.useEffect(() => {\n      if (splitView && viewState.activeItem) {\n        const item = viewState.getItemForKey(viewState.activeItem);\n        if (item) {\n          const pathname = pathnameForItem(item);\n          if (pathname) {\n            history.replace(typeof pathname === \"string\" ? { pathname } : pathname);\n          }\n        }\n      }\n    }, [splitView, viewState.activeItem]);\n\n    useRegisterViewDataActionContext({\n      data: provider.data,\n      filteredItems: provider.filteredItems,\n      viewState,\n      viewPreferences: provider.viewPreferences,\n      modelType: \"modelType\" in provider ? provider.modelType : undefined,\n    });\n\n    // TODO update this, probably pull out to own hook, and have something other than the provider manage url logic.\n    useKeyPressEvent(KeyboardHelper.isEnter, () => {\n      if (viewState.activeItem) {\n        const item = viewState.getItemForKey(viewState.activeItem);\n        if (item && pathnameForItem) {\n          const pathname = pathnameForItem(item);\n          if (!pathname) {\n            return;\n          }\n          const existingHistoryState = { ...(history.location.state || {}) };\n          delete existingHistoryState.favoriteId;\n          const newHistoryState = { ...existingHistoryState };\n          typeof pathname === \"string\" ? history.push({ pathname, state: newHistoryState }) : history.push(pathname);\n        }\n      }\n    });\n    const listContainerRef = React.useRef<HTMLDivElement>(null);\n    useScrollChange(\n      listContainerRef,\n      React.useCallback(isScrolling => {\n        if (isScrolling) {\n          listContainerRef.current?.style.setProperty(\"--a-pointer-events\", \"none\");\n        } else {\n          listContainerRef.current?.style.removeProperty(\"--a-pointer-events\");\n        }\n      }, [])\n    );\n\n    const onScroll = React.useCallback(() => {\n      handleItemsRendered();\n    }, []);\n\n    const contextData = React.useMemo(\n      () => ({\n        state: viewState,\n        data: provider.data,\n        provider,\n        splitView,\n        pathnameForItem: pathnameForItem ?? noop,\n      }),\n      [viewState, provider.data, pathnameForItem, splitView]\n    );\n\n    if (displayEmptyState) {\n      return <>{emptyPlaceholder}</>;\n    }\n    return (\n      <OuterContainer $disableMinWidth={splitView || false}>\n        <Container\n          ref={finalRef}\n          auto\n          column\n          grow={1}\n          $widths={widths}\n          onClick={() => {\n            // De-select items when clicking on the list empty space, but not on an item\n            viewState.deactivate();\n            viewState.clearSelection();\n          }}\n        >\n          {StateHooksComponent ? <StateHooksComponent viewState={viewState} /> : null}\n          {header}\n          <ListContainer ref={listRef}>\n            <GroupedViewDataContext.Provider value={contextData}>\n              <GroupedList\n                data={provider.data}\n                height={height}\n                ref={groupedListRef}\n                heightPerLevel={heightPerLevel}\n                stickyHeaderLevels={props.stickyHeaderLevels}\n                overscan={600}\n                outerRef={listContainerRef}\n                onScroll={onScroll}\n                paddingStart={paddingStart}\n                itemComponent={ItemComponent}\n                footer={footer}\n                footerHeight={footerHeight}\n                scrollRestorationId={scrollRestorationId}\n              />\n              {peekComponent ? <ViewPeek renderer={peekComponent} /> : null}\n            </GroupedViewDataContext.Provider>\n          </ListContainer>\n        </Container>\n      </OuterContainer>\n    );\n  })\n);\n\nconst OuterContainer = styled.div<{ $disableMinWidth: boolean }>`\n  overflow-x: auto;\n  flex-grow: 1;\n  ${props => (props.$disableMinWidth ? \"\" : \"min-width: 575px;\")}\n  ${screenSize.laptop} {\n    min-width: auto;\n  }\n`;\n\nconst Container = styled(Flex)<{ $widths: Record<string, number> }>`\n  height: 100%;\n  overflow: hidden;\n  width: 100%;\n  ${listColumnStyles}\n`;\n\nconst ListContainer = styled.div`\n  min-height: 0;\n  flex: 1;\n  background-color: ${color(\"bgBase\")};\n  &:focus {\n    outline: none;\n  }\n  // TODO target row wrapper instead of a\n  a {\n    pointer-events: var(--a-pointer-events);\n  }\n`;\n\ntype StateHooksComponentProps<T> = {\n  /**\n   * The current view state of the list.\n   */\n  viewState: GroupedViewState<T>;\n};\n```\n\nAdd gnerics to `List`\nTo add generics to the `List` component, you can modify the component definition to include type parameters. Here's how you can update the code to add generics:\n\n```tsx\nexport const List = suspenseObserver(\n  React.forwardRef(function List_<T, M = unknown>(\n    props: ListProps<T, M>,\n    outerRef: React.RefObject<HTMLDivElement>\n  ) {\n    // ... rest of the component implementation\n  })\n) as <T, M = unknown>(\n  props: ListProps<T, M> & { ref?: React.RefObject<HTMLDivElement> }\n) => React.ReactElement;\n```\n\nThis change does the following:\n\n1. It adds generic type parameters `<T, M = unknown>` to the `List_` function component.\n2. It uses these generic types in the `props` parameter type.\n3. It adds a type assertion at the end of the `suspenseObserver` call to properly type the exported `List` component with generics.\n\nNow you can use the `List` component with specific types:\n\n```tsx\n<List<YourItemType, YourMetadataType>\n  provider={...}\n  pathnameForItem={...}\n  // ... other props\n/>\n```\n\nThis will provide better type checking and autocompletion for the `provider`, `pathnameForItem`, and other props that depend on the item type `T` or metadata type `M`.\n```tsx linear-app/client/src/components/ModelViewStateHooksComponent.tsx\nimport { observer } from \"mobx-react-lite\";\nimport type { GroupedViewState } from \"@linear/orbiter/components/GroupedView/GroupedViewState\";\nimport type { GroupedViewItem } from \"@linear/orbiter/components/GroupedView/GroupedViewTypes\";\nimport { useSelectModels } from \"~/hooks/useSelectModels\";\nimport type { Model } from \"~/models/base/Model\";\nimport { useRegisterFocusedModel } from \"~/hooks/useRegisterFocusedModel\";\nimport { FocusedGroupType } from \"~/action/ActionManager\";\nimport type { ModelListRow, ModelListRowItem } from \"./VirtualList/ModelListProvider\";\nimport type { ProviderItem } from \"./List/components/dataProviders/GroupedViewDataProvider\";\n\n/** Component to handle rendering of viewState when the view contains models.\n * For example in an issue list this will register active and selected issues.\n * Probably passed into a <List>/<Board> component.\n */\nexport const ModelViewStateHooksComponent = observer(function ModelViewStateHooksComponent_({\n  viewState,\n}: {\n  /** The viewState in the current view */\n  viewState: GroupedViewState<ModelListRow<Model, never> | ProviderItem>;\n}) {\n  useSelectModels(\n    viewState.selectedItems\n      .map(key => {\n        return modelForItem(viewState.getItemForKey(key));\n      })\n      .concrete()\n  );\n  const activeItem = viewState.activeItem && viewState.getItemForKey(viewState.activeItem);\n  useRegisterFocusedModel(FocusedGroupType.main, modelForItem(activeItem));\n  // Touch viewState to trigger re-render on change\n  viewState;\n  return null;\n});\n\nfunction modelForItem(item: GroupedViewItem<ModelListRowItem<Model> | ProviderItem> | null): Model | undefined {\n  if (item) {\n    if (\"wrappedModel\" in item.data) {\n      return item.data.wrappedModel;\n    } else if (\"id\" in item.data) {\n      return item.data;\n    }\n    return \"type\" in item.data && item.data.type === \"item\" ? item.data.value : undefined;\n  }\n\n  return;\n}\n```\n\nAdd generics for `ModelListRow<Model, never> | ProviderItem` in this conmponent. Default should be `ModelListRow<Model, never>`.\nTo add generics for `ModelListRow<Model, never> | ProviderItem` in this component with a default of `ModelListRow<Model, never>`, you can modify the component as follows:\n\n```tsx\nimport { observer } from \"mobx-react-lite\";\nimport type { GroupedViewState } from \"@linear/orbiter/components/GroupedView/GroupedViewState\";\nimport type { GroupedViewItem } from \"@linear/orbiter/components/GroupedView/GroupedViewTypes\";\nimport { useSelectModels } from \"~/hooks/useSelectModels\";\nimport type { Model } from \"~/models/base/Model\";\nimport { useRegisterFocusedModel } from \"~/hooks/useRegisterFocusedModel\";\nimport { FocusedGroupType } from \"~/action/ActionManager\";\nimport type { ModelListRow, ModelListRowItem } from \"./VirtualList/ModelListProvider\";\nimport type { ProviderItem } from \"./List/components/dataProviders/GroupedViewDataProvider\";\n\n/** Component to handle rendering of viewState when the view contains models.\n * For example in an issue list this will register active and selected issues.\n * Probably passed into a <List>/<Board> component.\n */\nexport const ModelViewStateHooksComponent = observer(function ModelViewStateHooksComponent_<\n  T extends ModelListRow<Model, never> | ProviderItem = ModelListRow<Model, never>\n>({\n  viewState,\n}: {\n  /** The viewState in the current view */\n  viewState: GroupedViewState<T>;\n}) {\n  useSelectModels(\n    viewState.selectedItems\n      .map(key => {\n        return modelForItem(viewState.getItemForKey(key));\n      })\n      .concrete()\n  );\n  const activeItem = viewState.activeItem && viewState.getItemForKey(viewState.activeItem);\n  useRegisterFocusedModel(FocusedGroupType.main, modelForItem(activeItem));\n  // Touch viewState to trigger re-render on change\n  viewState;\n  return null;\n});\n\nfunction modelForItem<T extends ModelListRow<Model, never> | ProviderItem>(\n  item: GroupedViewItem<T> | null\n): Model | undefined {\n  if (item) {\n    if (\"wrappedModel\" in item.data) {\n      return item.data.wrappedModel;\n    } else if (\"id\" in item.data) {\n      return item.data;\n    }\n    return \"type\" in item.data && item.data.type === \"item\" ? item.data.value : undefined;\n  }\n\n  return;\n}\n```\n\nThis modification does the following:\n\n1. Adds a generic type parameter `T` to the `ModelViewStateHooksComponent_` function, extending it with `ModelListRow<Model, never> | ProviderItem` and defaulting to `ModelListRow<Model, never>`.\n\n2. Updates the `viewState` prop type to use the generic `T`.\n\n3. Modifies the `modelForItem` function to also use the generic `T`.\n\nNow you can use the component with specific types if needed, or it will default to `ModelListRow<Model, never>` if no type is specified:\n\n```tsx\n<ModelViewStateHooksComponent viewState={...} />\n// or\n<ModelViewStateHooksComponent<ProviderItem> viewState={...} />\n```\n\nThis change provides more flexibility and type safety when using the component with different types of view states.\nMake sure they're exposed on ModelViewStateHooksComponent\nYou're right, I should have made the generic type parameter more explicit on the exported component. Here's an updated version that properly exposes the generic on `ModelViewStateHooksComponent`:\n\n```tsx\nimport { observer } from \"mobx-react-lite\";\nimport type { GroupedViewState } from \"@linear/orbiter/components/GroupedView/GroupedViewState\";\nimport type { GroupedViewItem } from \"@linear/orbiter/components/GroupedView/GroupedViewTypes\";\nimport { useSelectModels } from \"~/hooks/useSelectModels\";\nimport type { Model } from \"~/models/base/Model\";\nimport { useRegisterFocusedModel } from \"~/hooks/useRegisterFocusedModel\";\nimport { FocusedGroupType } from \"~/action/ActionManager\";\nimport type { ModelListRow, ModelListRowItem } from \"./VirtualList/ModelListProvider\";\nimport type { ProviderItem } from \"./List/components/dataProviders/GroupedViewDataProvider\";\n\n/** Component to handle rendering of viewState when the view contains models.\n * For example in an issue list this will register active and selected issues.\n * Probably passed into a <List>/<Board> component.\n */\nexport const ModelViewStateHooksComponent = observer(\n  function ModelViewStateHooksComponent_<T extends ModelListRow<Model, never> | ProviderItem = ModelListRow<Model, never>>({\n    viewState,\n  }: {\n    /** The viewState in the current view */\n    viewState: GroupedViewState<T>;\n  }) {\n    useSelectModels(\n      viewState.selectedItems\n        .map(key => {\n          return modelForItem(viewState.getItemForKey(key));\n        })\n        .concrete()\n    );\n    const activeItem = viewState.activeItem && viewState.getItemForKey(viewState.activeItem);\n    useRegisterFocusedModel(FocusedGroupType.main, modelForItem(activeItem));\n    // Touch viewState to trigger re-render on change\n    viewState;\n    return null;\n  }\n) as <T extends ModelListRow<Model, never> | ProviderItem = ModelListRow<Model, never>>(\n  props: { viewState: GroupedViewState<T> }\n) => React.ReactElement | null;\n\nfunction modelForItem<T extends ModelListRow<Model, never> | ProviderItem>(\n  item: GroupedViewItem<T> | null\n): Model | undefined {\n  if (item) {\n    if (\"wrappedModel\" in item.data) {\n      return item.data.wrappedModel;\n    } else if (\"id\" in item.data) {\n      return item.data;\n    }\n    return \"type\" in item.data && item.data.type === \"item\" ? item.data.value : undefined;\n  }\n\n  return;\n}\n```\n\nIn this updated version:\n\n1. The generic type parameter `T` is now properly exposed on the exported `ModelViewStateHooksComponent`.\n\n2. We've added a type assertion at the end of the `observer` call to explicitly define the component's type with the generic parameter.\n\n3. The default type for `T` is still set to `ModelListRow<Model, never>`.\n\nNow you can use the component with explicit typing:\n\n```tsx\n<ModelViewStateHooksComponent<ModelListRow<Model, never>> viewState={...} />\n// or\n<ModelViewStateHooksComponent<ProviderItem> viewState={...} />\n// or just use the default\n<ModelViewStateHooksComponent viewState={...} />\n```\n\nThis change ensures that the generic type parameter is properly exposed and can be used when consuming the component, providing better type checking and autocompletion.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":2096}}},{"id":{"replica_id":0,"value":447},"start":11269,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":2097}}},{"id":{"replica_id":0,"value":448},"start":12441,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":2098}}},{"id":{"replica_id":0,"value":638},"start":14544,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":2099}}},{"id":{"replica_id":0,"value":639},"start":17442,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":2100}}},{"id":{"replica_id":0,"value":686},"start":17500,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":2101}}},{"id":{"replica_id":0,"value":687},"start":20670,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":2102}}}],"summary":"List Component with Generics","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":11246},"icon":"File","label":"linear-app/client/src/components/List/ListNew.tsx","metadata":{"path":"linear-app/client/src/components/List/ListNew.tsx"}},{"range":{"start":12441,"end":14414},"icon":"File","label":"linear-app/client/src/components/ModelViewStateHooksComponent.tsx","metadata":{"path":"linear-app/client/src/components/ModelViewStateHooksComponent.tsx"}}]}