{"id":"45c338d1-5280-4df3-b788-dc0c3b4e81fa","zed":"context","version":"0.4.0","text":"\n\n\n```tsx linear-app/orbiter/src/components/GroupedView/GroupedList.stories.tsx\nimport * as React from \"react\";\nimport type { Meta } from \"@storybook/react\";\nimport { observer } from \"mobx-react-lite\";\nimport isEqual from \"lodash/isEqual\";\nimport { action, observable } from \"mobx\";\nimport { useComputed } from \"../../hooks/useComputed\";\nimport { Flex } from \"../Flex\";\nimport { GroupedList, type ListCellProps, type GroupedListRef } from \"./GroupedList\";\nimport type { GroupedViewItem, GroupedViewItemKey, PathToItem } from \"./GroupedViewTypes\";\nimport { Direction, type GroupedViewState, useGroupedViewState } from \"./GroupedViewState\";\nimport { useScrollToActive, useUpdateActive } from \"./useGroupedViewHooks\";\n\nconst meta: Meta = {\n  title: \"Components/GroupedList\",\n  component: GroupedList,\n};\n\nexport default meta;\n\nexport function SimpleList() {\n  return <SimpleListInner />;\n}\nconst SimpleListInner = observer(function SimpleList_() {\n  const [items, setItems] = React.useState(() => generateItems([], 2));\n  const heightPerLevel = React.useMemo(() => {\n    return [36, 36, 24, 24];\n  }, []);\n\n  const listRef = React.useRef<GroupedListRef>(null);\n  const state = useGroupedViewState(items, undefined, [items]);\n  React.useEffect(() => {\n    const keyListener = action((event: KeyboardEvent) => {\n      if (event.key === \"ArrowDown\") {\n        state.moveActive(Direction.DownRight);\n      } else if (event.key === \"ArrowUp\") {\n        state.moveActive(Direction.UpLeft);\n      } else if (event.key === \"x\") {\n        state.activeItem && state.cmdSelect(state.activeItem);\n      } else if (event.key === \"Backspace\") {\n        state.activeItem && removeItemByKey(items, state.activeItem);\n      } else {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n    });\n    window.document.body?.addEventListener(\"keydown\", keyListener);\n    return () => {\n      window.document.body?.removeEventListener(\"keydown\", keyListener);\n    };\n  }, [state]);\n  const itemsKey = useComputed(() => getItemsKey(items), [items]);\n  const randomKey = useComputed(() => getRandomItemKey(items), [itemsKey]);\n  useUpdateActive(state, items, itemsKey);\n  useScrollToActive(state, listRef);\n  return (\n    <div\n      style={{ display: \"flex\", flexDirection: \"column\", gap: 24, paddingBottom: 24, flexGrow: 1, flexBasis: \"50%\" }}\n    >\n      <Flex gap={24}>\n        <button onClick={() => listRef.current?.scrollTo(Math.random() * 1000)}>Scroll to random position</button>\n        <button onClick={() => listRef.current?.scrollToKey(randomKey)}>Scroll to id: {randomKey}</button>\n        <button onClick={() => state.updateState({ type: \"moveActive\", payload: { direction: Direction.UpLeft } })}>\n          up\n        </button>\n        <button onClick={() => state.updateState({ type: \"moveActive\", payload: { direction: Direction.DownRight } })}>\n          down\n        </button>\n      </Flex>\n      <div style={{ width: \"100%\" }}>\n        <ViewDataContext.Provider value={{ setItems, items }}>\n          <ViewStateContext.Provider value={state}>\n            <GroupedList\n              data={items}\n              height={600}\n              heightPerLevel={heightPerLevel}\n              overscan={500}\n              stickyHeaderLevels={2}\n              ref={listRef}\n              itemComponent={ListItemRenderer}\n            />\n          </ViewStateContext.Provider>\n        </ViewDataContext.Provider>\n      </div>\n    </div>\n  );\n});\n\nexport function VariableList() {\n  return <VariableListInner />;\n}\nconst VariableListInner = observer(function VariableList_() {\n  const [items, setItems] = React.useState(() => generateItems([], 2));\n  const heightPerLevel = React.useMemo(() => {\n    return [36, 36, 24, 24];\n  }, []);\n\n  const listRef = React.useRef<GroupedListRef>(null);\n  const state = useGroupedViewState(items, undefined, [items]);\n  React.useEffect(() => {\n    const keyListener = action((event: KeyboardEvent) => {\n      if (event.key === \"ArrowDown\") {\n        state.moveActive(Direction.DownRight);\n      } else if (event.key === \"ArrowUp\") {\n        state.moveActive(Direction.UpLeft);\n      } else if (event.key === \"x\") {\n        state.activeItem && state.cmdSelect(state.activeItem);\n      } else if (event.key === \"Backspace\") {\n        state.activeItem && removeItemByKey(items, state.activeItem);\n      } else {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n    });\n    window.document.body?.addEventListener(\"keydown\", keyListener);\n    return () => {\n      window.document.body?.removeEventListener(\"keydown\", keyListener);\n    };\n  }, [state]);\n  const itemsKey = useComputed(() => getItemsKey(items), [items]);\n  const randomKey = useComputed(() => getRandomItemKey(items), [itemsKey]);\n  useUpdateActive(state, items, itemsKey);\n  useScrollToActive(state, listRef);\n  return (\n    <div\n      style={{ display: \"flex\", flexDirection: \"column\", gap: 24, paddingBottom: 24, flexGrow: 1, flexBasis: \"50%\" }}\n    >\n      <Flex gap={24}>\n        <button onClick={() => listRef.current?.scrollTo(Math.random() * 1000)}>Scroll to random position</button>\n        <button onClick={() => listRef.current?.scrollToKey(randomKey)}>Scroll to id: {randomKey}</button>\n        <button onClick={() => state.updateState({ type: \"moveActive\", payload: { direction: Direction.UpLeft } })}>\n          up\n        </button>\n        <button onClick={() => state.updateState({ type: \"moveActive\", payload: { direction: Direction.DownRight } })}>\n          down\n        </button>\n      </Flex>\n      <div style={{ width: \"100%\" }}>\n        <ViewDataContext.Provider value={{ setItems, items }}>\n          <ViewStateContext.Provider value={state}>\n            <GroupedList\n              data={items}\n              height={600}\n              heightPerLevel={heightPerLevel}\n              overscan={500}\n              stickyHeaderLevels={2}\n              variableHeight\n              ref={listRef}\n              itemComponent={VariableListItemRenderer}\n            />\n          </ViewStateContext.Provider>\n        </ViewDataContext.Provider>\n      </div>\n    </div>\n  );\n});\n\nconst ViewStateContext = React.createContext<GroupedViewState | null>(null);\nconst ViewDataContext = React.createContext<{\n  items?: GroupedViewItem<ItemData>[];\n  setItems?: React.Dispatch<GroupedViewItem<ItemData>[]>;\n} | null>({});\n\nconst ListItemRenderer = observer(({ item, path, style, ...etc }: ListCellProps<ItemData>) => {\n  const level = path.length - 1;\n  const listState = React.useContext(ViewStateContext)!;\n  const { items } = React.useContext(ViewDataContext) ?? {};\n  const isActive = isEqual(listState.activeItem, item.key);\n  const isSelected = listState.selectedItems.some(i => isEqual(i, item.key));\n  return (\n    <div\n      data-key={item.key}\n      style={{\n        ...style,\n        color: \"#333\",\n        backgroundColor: isActive ? \"#c1c1c1\" : item.interactive ? \"#dddddd\" : \"#cccccc\",\n        padding: `0px ${18 * (level + 1)}px`,\n        display: \"flex\",\n        alignItems: \"center\",\n        fontVariantNumeric: \"tabular-nums\",\n      }}\n      onMouseEnter={item.interactive ? () => listState.activate({ item: item.key, keyboardActive: false }) : undefined}\n      {...etc}\n    >\n      <input\n        type=\"checkbox\"\n        checked={isSelected}\n        disabled={!item.interactive}\n        onChange={() => {\n          listState.cmdSelect(item.key);\n        }}\n      />\n      {item.data.textContent}\n      <button\n        onClick={action(() => {\n          removeItemByKey(items ?? [], item.key);\n        })}\n      >\n        x\n      </button>\n    </div>\n  );\n});\n\nconst VariableListItemRenderer = observer(({ item, path, style, ...etc }: ListCellProps<ItemData>) => {\n  const level = path.length - 1;\n  const listState = React.useContext(ViewStateContext)!;\n  const { items } = React.useContext(ViewDataContext) ?? {};\n  const isActive = isEqual(listState.activeItem, item.key);\n  const isSelected = listState.selectedItems.some(i => isEqual(i, item.key));\n  return (\n    <div\n      data-key={item.key}\n      style={{\n        ...style,\n        color: \"#333\",\n        backgroundColor: isActive ? \"#c1c1c1\" : item.interactive ? \"#dddddd\" : \"#cccccc\",\n        padding: `0px ${18 * (level + 1)}px`,\n        display: \"flex\",\n        alignItems: \"center\",\n        fontVariantNumeric: \"tabular-nums\",\n      }}\n      onMouseEnter={item.interactive ? () => listState.activate({ item: item.key, keyboardActive: false }) : undefined}\n      {...etc}\n    >\n      <input\n        type=\"checkbox\"\n        checked={isSelected}\n        disabled={!item.interactive}\n        onChange={() => {\n          listState.cmdSelect(item.key);\n        }}\n      />\n      {item.data.textContent}\n      <button\n        onClick={action(() => {\n          removeItemByKey(items ?? [], item.key);\n        })}\n      >\n        x\n      </button>\n    </div>\n  );\n});\n\nfunction generateItem(id: string, path: PathToItem, interactive: boolean): ItemData {\n  return {\n    id,\n    textContent: `${interactive ? \"Header\" : \"Item\"} ${path.join(\"-\")} ${!interactive ? \"(sticky)\" : \"(static)\"}`,\n    description: randomSentance(id),\n  };\n}\n\nfunction generateItems(parentPath: number[], stickyLevels: number): GroupedViewItem<ItemData>[] {\n  const result: GroupedViewItem<ItemData>[] = [];\n\n  const level = parentPath.length;\n  const sticky = level < stickyLevels;\n  for (let i = 0; i < (level === 0 ? 15000 : 2 + Math.floor(Math.random() * 10)); ++i) {\n    const seed = Math.random();\n    const path = [...parentPath, i];\n    let subItems: GroupedViewItem<ItemData>[] | undefined;\n    if (level < 3 && seed < 0.25) {\n      subItems = generateItems(path, stickyLevels);\n    }\n    const interactive = !sticky || !subItems;\n    result.push({\n      key: path.join(\"-\") as GroupedViewItemKey,\n      data: generateItem(i.toString(), path, interactive),\n      interactive,\n      subItems,\n    });\n  }\n  return observable(result);\n}\n\nfunction getRandomItemKey(items: GroupedViewItem<ItemData>[]): string {\n  const randomIndex = Math.floor(Math.random() * items.length);\n  const selectedItem = items[randomIndex];\n\n  if (selectedItem.subItems && selectedItem.subItems.length > 0) {\n    const randomChoice = Math.random();\n\n    // 50% chance to go deeper, 50% chance to return current item's id\n    if (randomChoice < 0.5) {\n      return getRandomItemKey(selectedItem.subItems);\n    }\n  }\n\n  return selectedItem.key;\n}\n\ntype ItemData = { id: string; textContent: string };\n\n// Function to remove an item from the items array based on its key\nfunction removeItemByKey(items: GroupedViewItem<ItemData>[], keyToRemove: string): void {\n  // Recursive helper function to traverse and modify the items\n  function traverse(currentItems: GroupedViewItem<ItemData>[]) {\n    for (let i = 0; i < currentItems.length; i++) {\n      if (currentItems[i].key === keyToRemove) {\n        // Remove the item if the key matches\n        currentItems.splice(i, 1);\n        return true; // Item found and removed\n      }\n\n      // If the item has subItems, recursively search them\n      if (currentItems[i].subItems) {\n        if (traverse(currentItems[i].subItems!)) {\n          return true; // Item found in subItems\n        }\n      }\n    }\n    return false; // Item not found in this branch\n  }\n\n  // Start the traversal from the top-level items\n  traverse(items);\n}\n\nfunction getItemsKey(items: GroupedViewItem<ItemData>[]): string {\n  function concatenateKeys(currentItems: GroupedViewItem<ItemData>[]): string {\n    return currentItems.reduce((acc, item) => {\n      acc += item.key;\n      if (item.subItems) {\n        acc += concatenateKeys(item.subItems);\n      }\n      return acc;\n    }, \"\");\n  }\n\n  return concatenateKeys(items);\n}\n```\n```tsx\n    id,\n    textContent: `${interactive ? \"Header\" : \"Item\"} ${path.join(\"-\")} ${!interactive ? \"(sticky)\" : \"(static)\"}`,\n    description: randomSentance(id),\n// error: Object literal may only specify known properties, and 'description' does not exist in type 'ItemData'.\n  };\n}\n```\n```tsx\n    id,\n    textContent: `${interactive ? \"Header\" : \"Item\"} ${path.join(\"-\")} ${!interactive ? \"(sticky)\" : \"(static)\"}`,\n    description: randomSentance(id),\n// error: Cannot find name 'randomSentance'.\n  };\n}\n```\n```tsx\n    id,\n    textContent: `${interactive ? \"Header\" : \"Item\"} ${path.join(\"-\")} ${!interactive ? \"(sticky)\" : \"(static)\"}`,\n    description: randomSentance(id),\n// error: Object literal may only specify known properties, and 'description' does not exist in type 'ItemData'.\n  };\n}\n```\n```tsx\n    id,\n    textContent: `${interactive ? \"Header\" : \"Item\"} ${path.join(\"-\")} ${!interactive ? \"(sticky)\" : \"(static)\"}`,\n    description: randomSentance(id),\n// error: Cannot find name 'randomSentance'.\n  };\n}\n```\n\nimplement the randomSentance function. It should generate a sentance between 10 and 20 words long. The result should be deterministic based on the id passed in. For example, randomSentance(\"id-1\") should always return the same sentance.\n\nTo implement the `randomSentence` function as requested, we can use a seeded random number generator to ensure deterministic results based on the input `id`. Here's an implementation that meets your requirements:\n\n```typescript\nfunction randomSentence(id: string): string {\n  const words = [\n    \"the\", \"be\", \"to\", \"of\", \"and\", \"a\", \"in\", \"that\", \"have\", \"I\",\n    \"it\", \"for\", \"not\", \"on\", \"with\", \"he\", \"as\", \"you\", \"do\", \"at\",\n    \"this\", \"but\", \"his\", \"by\", \"from\", \"they\", \"we\", \"say\", \"her\", \"she\",\n    \"or\", \"an\", \"will\", \"my\", \"one\", \"all\", \"would\", \"there\", \"their\", \"what\"\n  ];\n\n  // Simple hash function to generate a seed from the id\n  const seed = id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n\n  // Simple seeded random number generator\n  let state = seed;\n  const random = () => {\n    state = (state * 1664525 + 1013904223) % 2**32;\n    return state / 2**32;\n  };\n\n  // Generate a sentence with 10 to 20 words\n  const length = Math.floor(random() * 11) + 10;\n  const sentence = Array.from({ length }, () => words[Math.floor(random() * words.length)]);\n\n  // Capitalize the first word and add a period at the end\n  sentence[0] = sentence[0].charAt(0).toUpperCase() + sentence[0].slice(1);\n  return sentence.join(' ') + '.';\n}\n```\n\nNow, you can use this `randomSentence` function in your `generateItem` function:\n\n```typescript\nfunction generateItem(id: string, path: PathToItem, interactive: boolean): ItemData {\n  return {\n    id,\n    textContent: `${interactive ? \"Header\" : \"Item\"} ${path.join(\"-\")} ${!interactive ? \"(sticky)\" : \"(static)\"}`,\n    description: randomSentence(id),\n  };\n}\n```\n\nTo resolve the TypeScript error, you need to update your `ItemData` type to include the `description` property:\n\n```typescript\ntype ItemData = { \n  id: string; \n  textContent: string; \n  description: string;\n};\n```\n\nThese changes will:\n1. Implement the `randomSentence` function that generates deterministic sentences based on the input `id`.\n2. Use this function in `generateItem` to create a description for each item.\n3. Update the `ItemData` type to include the `description` property, resolving the TypeScript error.\n\nRemember to update any other parts of your code that rely on the `ItemData` type to accommodate this new `description` property.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":746}}},{"id":{"replica_id":0,"value":740},"start":12992,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":747}}},{"id":{"replica_id":0,"value":741},"start":15272,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":748}}}],"summary":"Here's an implementation of the `randomSentance` function that meets your requirements:","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":12239},"icon":"File","label":"linear-app/orbiter/src/components/GroupedView/GroupedList.stories.tsx","metadata":{"path":"linear-app/orbiter/src/components/GroupedView/GroupedList.stories.tsx"}},{"range":{"start":12239,"end":12529},"icon":"XCircle","label":"Object literal may only specify known properties, and 'description' does not exist in type 'ItemData'.","metadata":null},{"range":{"start":12530,"end":12752},"icon":"XCircle","label":"Cannot find name 'randomSentance'.","metadata":null}]}