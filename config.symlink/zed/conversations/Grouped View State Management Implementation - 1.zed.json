{"id":"89faba93-71c6-471f-b8a6-61b9ca6c50a0","zed":"context","version":"0.4.0","text":"\n\n\n```ts linear-app/orbiter/src/components/GroupedView/GroupedViewState.ts\n/* eslint-disable jsdoc/require-jsdoc */\nimport * as React from \"react\";\nimport { makeObservable, action as mobXaction, observable } from \"mobx\";\nimport { GroupedViewItemHelper } from \"./GroupedViewItemHelper\";\nimport type { GroupedViewItem, GroupedViewItemKey, PathToItem } from \"./GroupedViewTypes\";\n\nexport function useGroupedViewState<T>(data: GroupedViewItem<T>[]) {\n  return React.useMemo(() => new GroupedViewState({ data }), [data]);\n}\n\nexport class GroupedViewState {\n  public constructor(options: { initialActiveItem?: GroupedViewItemKey; data: GroupedViewItem<unknown>[] }) {\n    if (options.initialActiveItem) {\n      this.activeItem = options.initialActiveItem;\n    }\n    if (options.data) {\n      this.data = options.data;\n    }\n    makeObservable(this, {\n      moveActive: mobXaction,\n      activate: mobXaction,\n      addToSelection: mobXaction,\n      handleTabPress: mobXaction,\n      select: mobXaction,\n      selectBetween: mobXaction,\n      deactivate: mobXaction,\n      focus: mobXaction,\n      clearSelection: mobXaction,\n      shiftSelect: mobXaction,\n      cmdSelect: mobXaction,\n      selectAllSubItems: mobXaction,\n      selectAll: mobXaction,\n      goToEnd: mobXaction,\n      goToStart: mobXaction,\n      clearKeyboardActive: mobXaction,\n      setKeyboardActive: mobXaction,\n      activateNextAvailableItem: mobXaction,\n      updateState: mobXaction,\n      activeItem: observable,\n      focusedItem: observable,\n      keyboardActive: observable,\n      initialSelectedItem: observable,\n      selectedItems: observable,\n      navigationDirection: observable,\n    });\n  }\n\n  public focusedItem: GroupedViewItemKey | null = null;\n  public activeItem: GroupedViewItemKey | null = null;\n  public previouslyActiveItem: GroupedViewItemKey | null = null;\n  public keyboardActive: boolean = false;\n  public initialSelectedItem: GroupedViewItemKey | null = null;\n  public selectedItems: GroupedViewItemKey[] = [];\n  public navigationDirection: Direction = Direction.DownRight;\n\n  public updateState(action: GroupedViewAction): void {\n    switch (action.type) {\n      case \"moveActive\":\n        this.moveActive(action.payload.direction, action.payload);\n        break;\n      case \"activate\":\n        this.activate(action.payload);\n        break;\n      case \"addToSelection\":\n        this.addToSelection(action.payload);\n        break;\n      case \"tabPress\":\n        this.handleTabPress(action.payload);\n        break;\n      case \"select\":\n        this.select(action.payload);\n        break;\n      case \"selectBetween\":\n        this.selectBetween(action.payload);\n        break;\n      case \"deactivate\":\n        this.deactivate();\n        break;\n      case \"focus\":\n        this.focus(action.payload.item);\n        break;\n      case \"clearSelection\":\n        this.clearSelection();\n        break;\n      case \"shiftSelect\":\n        this.shiftSelect(action.payload);\n        break;\n      case \"cmdSelect\":\n        this.cmdSelect(action.payload);\n        break;\n      case \"selectAllInGroup\":\n        this.selectAllSubItems(action.payload);\n        break;\n      case \"selectAll\":\n        this.selectAll();\n        break;\n      case \"goToEnd\":\n        this.goToEnd();\n        break;\n      case \"goToStart\":\n        this.goToStart();\n        break;\n      case \"clearKeyboardActive\":\n        this.clearKeyboardActive();\n        break;\n      case \"setKeyboardActive\":\n        this.setKeyboardActive();\n        break;\n      case \"activateNextAvailableItem\":\n        this.activateNextAvailableItem(action.payload);\n        break;\n      default:\n        // eslint-disable-next-line no-console\n        console.warn(\"Unhandled action type:\", (action as unknown as { type: string }).type);\n    }\n  }\n\n  public moveActive(\n    direction: Direction,\n    options: {\n      toEnd?: boolean;\n      shouldClearSelection?: boolean;\n    } = {}\n  ) {\n    if (!this.activeItem) {\n      this.activeItem = this.firstItem();\n      return;\n    }\n\n    const newActiveItem = this.findNextItemByKey(this.activeItem, direction, options.toEnd);\n\n    if (newActiveItem) {\n      this.activeItem = newActiveItem;\n      this.keyboardActive = true;\n\n      if (options.shouldClearSelection) {\n        this.selectedItems = [];\n      }\n    }\n  }\n\n  public activate(payload: {\n    item: GroupedViewItemKey;\n    keyboardActive: boolean;\n    shouldClearSelection?: boolean;\n    maintainDirection?: boolean; // TODO - implement this\n  }) {\n    this.activeItem = payload.item;\n    this.keyboardActive = payload.keyboardActive;\n    if (payload.shouldClearSelection) {\n      this.selectedItems = [];\n    }\n  }\n\n  public addToSelection(_payload: { direction: Direction; selectActiveItemImmediately?: boolean }) {\n    // Implement add to selection logic\n  }\n\n  public handleTabPress(_event: React.KeyboardEvent | KeyboardEvent) {\n    // Implement tab press logic\n  }\n\n  public select(items: GroupedViewItemKey[]) {\n    this.selectedItems = items;\n    this.initialSelectedItem = items[0];\n    if (items.length > 0) {\n      this.activeItem = items[0];\n      this.focusedItem = items[0];\n    }\n  }\n\n  public selectBetween([start, end]: [GroupedViewItemKey, GroupedViewItemKey]) {\n    this.previouslyActiveItem = null;\n    this.activeItem = end;\n    this.focusedItem = end;\n    this.selectedItems = this.getItemsBetween(start, end);\n    this.initialSelectedItem = start;\n  }\n\n  public deactivate() {\n    this.previouslyActiveItem = this.activeItem;\n    this.activeItem = null;\n    this.keyboardActive = false;\n  }\n\n  public focus(item: GroupedViewItemKey) {\n    this.focusedItem = item;\n    this.activeItem = item;\n    this.keyboardActive = true;\n  }\n\n  public clearSelection() {\n    this.selectedItems = [];\n    this.focusedItem = null;\n    this.keyboardActive = false;\n  }\n\n  public shiftSelect(item?: GroupedViewItemKey) {\n    const startShiftSelectItem = item ?? this.activeItem;\n    if (!startShiftSelectItem) {\n      return;\n    }\n\n    this.previouslyActiveItem = null;\n    this.activeItem = startShiftSelectItem;\n    this.focusedItem = startShiftSelectItem;\n\n    if (this.initialSelectedItem) {\n      this.selectedItems = this.getItemsBetween(startShiftSelectItem, this.initialSelectedItem);\n    } else {\n      this.selectedItems = [startShiftSelectItem];\n    }\n    this.initialSelectedItem = this.initialSelectedItem || startShiftSelectItem;\n  }\n\n  public cmdSelect(item?: GroupedViewItemKey) {\n    const startCmdSelectItem = item ?? this.activeItem;\n    if (!startCmdSelectItem || this.multiSelectDisabled) {\n      return;\n    }\n\n    const oldSelectedItems =\n      this.isSplitView && this.activeItem ? [...new Set([...this.selectedItems, this.activeItem])] : this.selectedItems;\n\n    if (oldSelectedItems.includes(startCmdSelectItem)) {\n      const selectedItems = oldSelectedItems.filter(i => i !== startCmdSelectItem);\n      if (selectedItems.length > 0) {\n        this.focusedItem = selectedItems[selectedItems.length - 1];\n        this.selectedItems = selectedItems;\n      } else {\n        this.focusedItem = null;\n        this.initialSelectedItem = null;\n        this.selectedItems = [];\n      }\n    } else {\n      this.activeItem = startCmdSelectItem;\n      this.focusedItem = startCmdSelectItem;\n      this.initialSelectedItem = startCmdSelectItem;\n      this.selectedItems = [...oldSelectedItems, startCmdSelectItem];\n    }\n  }\n\n  public selectAllSubItems(root: GroupedViewItemKey) {\n    const rootItem = this.getItemForKey(root);\n    if (!rootItem?.subItems) {\n      return;\n    }\n\n    const allSubItemKeys: GroupedViewItemKey[] = [];\n    function collectKeys(items: GroupedViewItem<unknown>[]) {\n      for (const item of items) {\n        if (item.interactive) {\n          allSubItemKeys.push(item.key);\n        }\n        if (item.subItems) {\n          collectKeys(item.subItems);\n        }\n      }\n    }\n    collectKeys(rootItem.subItems);\n    this.selectedItems = allSubItemKeys;\n  }\n\n  public selectAll() {\n    const allKeys: GroupedViewItemKey[] = [];\n    function collectKeys(items: GroupedViewItem<unknown>[]) {\n      for (const item of items) {\n        if (item.interactive) {\n          allKeys.push(item.key);\n        }\n        if (item.subItems) {\n          collectKeys(item.subItems);\n        }\n      }\n    }\n    collectKeys(this.data);\n    this.selectedItems = allKeys;\n  }\n\n  public goToEnd() {\n    // Implement\n  }\n\n  public goToStart() {\n    // Implement\n  }\n\n  public getItemForKey(key: GroupedViewItemKey): GroupedViewItem<unknown> | null {\n    function findItem(items: GroupedViewItem<unknown>[]): GroupedViewItem<unknown> | null {\n      for (const item of items) {\n        if (item.key === key) {\n          return item;\n        }\n        if (item.subItems) {\n          const found = findItem(item.subItems);\n          if (found) {\n            return found;\n          }\n        }\n      }\n      return null;\n    }\n    return findItem(this.data);\n  }\n\n  public clearKeyboardActive() {\n    this.keyboardActive = false;\n  }\n\n  public setKeyboardActive() {\n    this.keyboardActive = true;\n  }\n\n  public activateNextAvailableItem(path: PathToItem) {\n    let res = this.getItemForPath(path, true)?.key ?? null;\n    if (!res) {\n      const nextPath = this.findNextPath(path, Direction.DownRight, false, false);\n      res = (nextPath && this.getItemForPath(nextPath, true)?.key) ?? null;\n    }\n    if (!res) {\n      const nextPath = this.findNextPath(path, Direction.UpLeft, false, false);\n      res = (nextPath && this.getItemForPath(nextPath, true)?.key) ?? null;\n    }\n    this.activeItem = res || this.firstItem();\n  }\n\n  private findNextItemByKey(\n    currentKey: GroupedViewItemKey,\n    direction: Direction,\n    toEnd: boolean = false\n  ): GroupedViewItemKey | null {\n    const path = GroupedViewItemHelper.getPathForItem(this.data, currentKey);\n    const nextPath = path && this.findNextPath(path, direction, toEnd);\n\n    return (nextPath && this.getItemForPath(nextPath, true)?.key) || null;\n  }\n\n  private findNextPath(\n    currentPathToItem: PathToItem,\n    direction: Direction,\n    toEnd: boolean = false,\n    onlySiblings: boolean = false\n  ): PathToItem | null {\n    const lastIndex = currentPathToItem.length - 1;\n    const parentPath = currentPathToItem.slice(0, -1);\n    const currentIndex = currentPathToItem[lastIndex];\n    const currentItem = this.getItemForPath(currentPathToItem, false);\n    if (!currentItem) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Could not find item for path\", [...currentPathToItem]);\n      if (currentPathToItem.length === 0) {\n        return null;\n      }\n      return this.findNextPath(\n        currentIndex >= 0\n          ? [...parentPath, currentIndex - 1]\n          : [...parentPath.slice(0, -1), parentPath[lastIndex - 1] + 1],\n        direction,\n        toEnd,\n        onlySiblings\n      );\n    }\n\n    if (toEnd) {\n      return direction === Direction.DownRight ? this.lastPath() : this.firstPath();\n    }\n\n    if (direction === Direction.DownRight) {\n      if (!onlySiblings) {\n        // Try to go to the first child of the current item\n        const firstChild = currentItem.subItems && this.firstPathInGroup(currentItem.subItems, currentPathToItem);\n\n        if (firstChild) {\n          return firstChild;\n        }\n      }\n      // Try to go to the next sibling\n      const [nextSiblingPath, nextSibling] = this.findNextSibling(currentPathToItem);\n      if (nextSibling) {\n        if (nextSibling.interactive) {\n          return nextSiblingPath;\n        } else {\n          return this.findNextPath(nextSiblingPath, direction);\n        }\n      }\n\n      // Go up and find the next available item\n      return this.findNextPath(parentPath, direction, toEnd, true);\n    } else {\n      if (currentIndex > 0) {\n        // Go to the previous sibling's last descendant\n        const previousSibling = [...parentPath, currentIndex - 1];\n        return this.findLastSubItem(previousSibling);\n      }\n      const parentItem = this.getItemForPath(parentPath, false);\n\n      // If we're at the first child, go to the parent\n      if (parentItem?.interactive) {\n        return parentPath;\n      } else {\n        return parentPath.length > 0 ? this.findNextPath(parentPath, direction) : null;\n      }\n    }\n  }\n\n  private findNextSibling(path: PathToItem): [PathToItem, GroupedViewItem<unknown>] | [null, null] {\n    const parentPath = path.slice(0, -1);\n    const currentIndex = path[path.length - 1];\n    const nextSiblingPath = [...parentPath, currentIndex + 1];\n    const nextSibling = this.getItemForPath(nextSiblingPath, false);\n\n    if (nextSibling) {\n      return [nextSiblingPath, nextSibling];\n    }\n\n    return [null, null];\n  }\n\n  private findLastSubItem(path: PathToItem): PathToItem | null {\n    const item = this.getItemForPath(path, false);\n    if (item && item.subItems && item.subItems.length > 0) {\n      const lastInteractiveIndex = item.subItems.findLastIndex(hasSomeInteractiveItem);\n      return this.findLastSubItem([...path, lastInteractiveIndex]);\n    }\n    return item?.interactive ? path : null;\n  }\n\n  /** Returns the item for a specific path\n   * @param path The path to the item.\n   * @param onlyInteractive If true, only returns interactive items. Default is false.\n   */\n  public getItemForPath(path: PathToItem, onlyInteractive: boolean): GroupedViewItem<unknown> | null {\n    let items = this.data;\n    let result: GroupedViewItem<unknown> | null = null;\n    for (const index of path) {\n      const item = items[index];\n      if (item && item.subItems) {\n        items = item.subItems;\n      }\n      result = onlyInteractive && item?.interactive ? item : item ?? null;\n    }\n    return result;\n  }\n\n  private firstItem(): GroupedViewItemKey | null {\n    const firstPath = this.firstPath();\n    return (firstPath && this.getItemForPath(firstPath, true)?.key) ?? null;\n  }\n\n  private firstPath() {\n    return this.firstPathInGroup(this.data);\n  }\n\n  private firstPathInGroup(items: GroupedViewItem<unknown>[], currentPath: PathToItem = []): PathToItem | null {\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      const path = [...currentPath, i];\n\n      // Check if the current item is interactive (not disabled)\n      if (item.interactive) {\n        return path;\n      }\n\n      // If the item has subitems, recursively search them\n      if (item.subItems && item.subItems.length > 0) {\n        const interactiveSubItem = this.firstPathInGroup(item.subItems, path);\n        if (interactiveSubItem) {\n          return interactiveSubItem;\n        }\n      }\n    }\n\n    // If no interactive item is found, return null\n    return null;\n  }\n\n  private lastItem(): string | null {\n    const lastPath = this.lastPath();\n    return (lastPath && this.getItemForPath(lastPath, true)?.key) ?? null;\n  }\n\n  private lastPath() {\n    return this.lastItemInGroup(this.data);\n  }\n\n  private lastItemInGroup(items: GroupedViewItem<unknown>[], currentPath: PathToItem = []): PathToItem | null {\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n      const path = [...currentPath, i];\n\n      // If the item has subitems, recursively search them first\n      if (item.subItems && item.subItems.length > 0) {\n        const interactiveSubItem = this.lastItemInGroup(item.subItems, path);\n        if (interactiveSubItem) {\n          return interactiveSubItem;\n        }\n      }\n\n      // Check if the current item is interactive (not disabled)\n      if (item.interactive) {\n        return path;\n      }\n    }\n\n    // If no interactive item is found, return null\n    return null;\n  }\n\n  private getItemsBetween(startKey: GroupedViewItemKey, endKey: GroupedViewItemKey): GroupedViewItemKey[] {\n    const startPath = GroupedViewItemHelper.getPathForItem(this.data, startKey);\n    const endPath = GroupedViewItemHelper.getPathForItem(this.data, endKey);\n    return startPath && endPath\n      ? this.getPathsBetween(startPath, endPath).map(path => this.getItemForPath(path, true)!.key)\n      : [startKey];\n  }\n\n  private getPathsBetween(startPath_: PathToItem, endPath_: PathToItem): PathToItem[] {\n    const result: PathToItem[] = [];\n    let inRange = false;\n    const [startPath, endPath] = sortPaths([startPath_, endPath_]);\n    function traverse(currentItems: GroupedViewItem<unknown>[], currentPath: number[] = [], depth: number = 0) {\n      for (let i = 0; i < currentItems.length; i++) {\n        const item = currentItems[i];\n        const itemPath = [...currentPath, i];\n\n        // Check if we've reached the start or end path\n        if (pathIsEqual(itemPath, startPath)) {\n          inRange = true;\n        }\n\n        // If we're in range, add the item to the result\n        if (inRange && item.interactive) {\n          result.push(itemPath);\n        }\n\n        // If we've reached the end path, stop traversing\n        if (pathIsEqual(itemPath, endPath)) {\n          inRange = false;\n          return;\n        }\n\n        // Recursively traverse subItems if they exist\n        if (item.subItems && depth < Math.max(startPath.length, endPath.length)) {\n          traverse(item.subItems, itemPath, depth + 1);\n        }\n      }\n    }\n\n    traverse(this.data);\n    return sortPaths(result);\n  }\n  private multiSelectDisabled: boolean = false;\n  private isSplitView: boolean = false;\n  private data: GroupedViewItem<unknown>[] = [];\n}\n\nexport const Direction = {\n  UpLeft: \"up/left\",\n  DownRight: \"down/right\",\n} as const;\nexport type Direction = (typeof Direction)[keyof typeof Direction];\n\n// Update GroupedViewAction types to use string instead of PathToItem\nexport type GroupedViewAction =\n  | {\n    type: \"moveActive\";\n    payload: {\n      direction: Direction;\n      toEnd?: boolean;\n      shouldClearSelection?: boolean;\n    };\n  }\n  | {\n    type: \"activate\";\n    payload: {\n      item: GroupedViewItemKey;\n      keyboardActive: boolean;\n      shouldClearSelection?: boolean;\n      maintainDirection?: boolean;\n    };\n  }\n  | {\n    type: \"addToSelection\";\n    payload: {\n      direction: Direction;\n      selectActiveItemImmediately?: boolean;\n    };\n  }\n  | {\n    type: \"tabPress\";\n    payload: React.KeyboardEvent | KeyboardEvent;\n  }\n  | { type: \"select\"; payload: GroupedViewItemKey[]; allowWithInPageFind?: boolean }\n  | { type: \"selectBetween\"; payload: [GroupedViewItemKey, GroupedViewItemKey] }\n  | { type: \"deactivate\"; allowWithInPageFind?: boolean }\n  | { type: \"focus\"; payload: { item: GroupedViewItemKey } }\n  | { type: \"clearSelection\" }\n  | { type: \"shiftSelect\"; payload?: GroupedViewItemKey }\n  | { type: \"cmdSelect\"; payload?: GroupedViewItemKey }\n  | { type: \"selectAllInGroup\"; payload: GroupedViewItemKey }\n  | { type: \"selectAll\" }\n  | { type: \"goToEnd\" }\n  | { type: \"goToStart\" }\n  | { type: \"clearKeyboardActive\" }\n  | { type: \"setKeyboardActive\" }\n  | { type: \"activateNextAvailableItem\"; payload: PathToItem };\n\nfunction pathIsEqual(path1: PathToItem, path2: PathToItem): boolean {\n  return path1.length === path2.length && path1.every((v, i) => v === path2[i]);\n}\n\nfunction sortPaths(paths: PathToItem[]): PathToItem[] {\n  return paths.sort((a, b) => {\n    const minLength = Math.min(a.length, b.length);\n\n    for (let i = 0; i < minLength; i++) {\n      if (a[i] !== b[i]) {\n        return a[i] - b[i];\n      }\n    }\n\n    // If one path is a prefix of the other, the shorter one comes first\n    if (a.length !== b.length) {\n      return a.length - b.length;\n    }\n\n    // Paths are identical\n    return 0;\n  });\n}\n\nfunction hasSomeInteractiveItem(item: GroupedViewItem<unknown>): boolean {\n  return Boolean(item.interactive || (item.subItems && item.subItems.some(hasSomeInteractiveItem)));\n}\n```\nImplement addToSelection\nTo implement the `addToSelection` method, we need to consider the direction of selection and whether to immediately select the active item. Here's an implementation that should work within the context of the `GroupedViewState` class:\n\n```typescript\npublic addToSelection(payload: { direction: Direction; selectActiveItemImmediately?: boolean }) {\n  if (!this.activeItem) {\n    return;\n  }\n\n  const { direction, selectActiveItemImmediately } = payload;\n  \n  // If we should select the active item immediately, add it to the selection\n  if (selectActiveItemImmediately && !this.selectedItems.includes(this.activeItem)) {\n    this.selectedItems.push(this.activeItem);\n  }\n\n  // Find the next item in the specified direction\n  const nextItem = this.findNextItemByKey(this.activeItem, direction);\n\n  if (nextItem) {\n    // Move the active item to the next item\n    this.activeItem = nextItem;\n    this.keyboardActive = true;\n\n    // If the next item is not already selected, add it to the selection\n    if (!this.selectedItems.includes(nextItem)) {\n      this.selectedItems.push(nextItem);\n    }\n\n    // Update the focused item\n    this.focusedItem = nextItem;\n\n    // If there's no initial selected item, set it to the first selected item\n    if (!this.initialSelectedItem && this.selectedItems.length > 0) {\n      this.initialSelectedItem = this.selectedItems[0];\n    }\n  }\n\n  // Ensure the selection is in order\n  this.selectedItems = this.getItemsBetween(this.initialSelectedItem!, this.activeItem);\n}\n```\n\nThis implementation does the following:\n\n1. It checks if there's an active item. If not, it returns early.\n2. If `selectActiveItemImmediately` is true and the active item isn't already selected, it adds the active item to the selection.\n3. It finds the next item in the specified direction using the existing `findNextItemByKey` method.\n4. If a next item is found:\n   - It updates the active item.\n   - It sets `keyboardActive` to true.\n   - If the next item isn't already selected, it adds it to the selection.\n   - It updates the focused item.\n   - If there's no initial selected item, it sets it to the first selected item.\n5. Finally, it ensures the selection is in order by calling `getItemsBetween` with the initial selected item and the active item.\n\nThis implementation should work with the existing structure of the `GroupedViewState` class and handle adding to the selection in both directions while maintaining the order of selection.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1067}},"image_offsets":[]},{"id":{"replica_id":0,"value":329},"start":19658,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1068}},"image_offsets":[]},{"id":{"replica_id":0,"value":330},"start":22110,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1069}},"image_offsets":[]}],"summary":"Grouped View State Management Implementation","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":19632},"icon":"File","label":"linear-app/orbiter/src/components/GroupedView/GroupedViewState.ts"}]}