{"id":"a8965ffe-8519-40fe-afc8-081b2c3a7a9a","zed":"context","version":"0.4.0","text":"\n\n\n```ts linear-app/orbiter/src/components/GroupedView/useGroupedViewState.ts\nimport * as React from \"react\";\nimport { action as mobXaction, makeObservable, observable } from \"mobx\";\nimport type { GroupedViewItem } from \"./GroupedViewTypes\";\n\n/**\n * A custom hook that creates and manages the state for a grouped view.\n *\n * @param listId - A unique identifier for the list.\n * @param data - The data to be displayed in the grouped view.\n * @param listRef - A ref object for the GroupedList component.\n * @returns A GroupedViewState instance that manages the state of the view.\n */\nexport function useGroupedViewState<T>(listId: string, data: GroupedViewItem<T>[]) {\n  const [state, setState] = React.useState(() => new GroupedViewState({ data }));\n\n  React.useEffect(() => {\n    // TODO: Update state when data changes isntead of replace\n    setState(new GroupedViewState({ data }));\n  }, [data, listId]);\n\n  return state;\n}\n\n/**\n * Represents the state of a grouped view, managing selection, activation, and navigation.\n */\nexport class GroupedViewState {\n  public constructor(options: { initialActiveItem?: PathToItem; data: GroupedViewItem<unknown>[] }) {\n    if (options.initialActiveItem) {\n      this.activeItem = options.initialActiveItem;\n    }\n    if (options.data) {\n      this.data = options.data;\n    }\n    makeObservable(this, {\n      moveActive: mobXaction,\n      activate: mobXaction,\n      addToSelection: mobXaction,\n      handleTabPress: mobXaction,\n      select: mobXaction,\n      selectBetween: mobXaction,\n      deactivate: mobXaction,\n      focus: mobXaction,\n      clearSelection: mobXaction,\n      shiftSelect: mobXaction,\n      cmdSelect: mobXaction,\n      selectAllSubItems: mobXaction,\n      selectAll: mobXaction,\n      goToEnd: mobXaction,\n      goToStart: mobXaction,\n      clearKeyboardActive: mobXaction,\n      setKeyboardActive: mobXaction,\n      activateNextAvailableItem: mobXaction,\n      updateState: mobXaction,\n      activeItem: observable,\n      focusedItem: observable,\n      keyboardActive: observable,\n      initialSelectedItem: observable,\n      selectedItems: observable,\n      navigationDirection: observable,\n    });\n  }\n  /** The currently focused item in the view */\n  public focusedItem: PathToItem | null = null;\n\n  /** The currently active item in the view */\n  public activeItem: PathToItem | null = null;\n\n  /** The previously active item in the view */\n  public previouslyActiveItem: PathToItem | null = null;\n\n  /** Indicates whether keyboard navigation is currently active */\n  public keyboardActive: boolean = false;\n\n  /** The initial item selected when starting a multi-select operation */\n  public initialSelectedItem: PathToItem | null = null;\n\n  /** An array of currently selected items */\n  public selectedItems: PathToItem[] = [];\n\n  /** The current navigation direction in the view */\n  public navigationDirection: Direction = Direction.DownRight;\n\n  /** Reducer, to update the state. Kept mostly for legacy reasons. It's preferred to use methods directly. */\n  public updateState(action: GroupedViewAction): void {\n    switch (action.type) {\n      case \"moveActive\":\n        this.moveActive(action.payload.direction, action.payload);\n        break;\n      case \"activate\":\n        this.activate(action.payload);\n        break;\n      case \"addToSelection\":\n        this.addToSelection(action.payload);\n        break;\n      case \"tabPress\":\n        this.handleTabPress(action.payload);\n        break;\n      case \"select\":\n        this.select(action.payload);\n        break;\n      case \"selectBetween\":\n        this.selectBetween(action.payload);\n        break;\n      case \"deactivate\":\n        this.deactivate();\n        break;\n      case \"focus\":\n        this.focus(action.payload.item);\n        break;\n      case \"navigateToActive\":\n        // TODO: Implement. Maybe.\n        break;\n      case \"clearSelection\":\n        this.clearSelection();\n        break;\n      case \"shiftSelect\":\n        this.shiftSelect(action.payload);\n        break;\n      case \"cmdSelect\":\n        this.cmdSelect(action.payload);\n        break;\n      case \"selectAllInGroup\":\n        this.selectAllSubItems(action.payload);\n        break;\n      case \"selectAll\":\n        this.selectAll();\n        break;\n      case \"goToEnd\":\n        this.goToEnd();\n        break;\n      case \"goToStart\":\n        this.goToStart();\n        break;\n      case \"clearKeyboardActive\":\n        this.clearKeyboardActive();\n        break;\n      case \"setKeyboardActive\":\n        this.setKeyboardActive();\n        break;\n      case \"activateNextAvailableItem\":\n        this.activateNextAvailableItem(action.payload);\n        break;\n      case \"openSelectionInTabs\":\n        // TODO: Implement. Maybe.\n        break;\n      default:\n        // eslint-disable-next-line no-console\n        console.warn(\"Unhandled action type:\", (action as unknown as { type: string }).type);\n    }\n  }\n\n  /**\n   * Moves the active item in the specified direction\n   * @param payload\n   * @returns\n   */\n  public moveActive(\n    direction: Direction,\n    options: {\n      toEnd?: boolean;\n      navigate?: boolean;\n      shouldClearSelection?: boolean;\n      isDebounced?: boolean;\n      isPending?: boolean;\n    }\n  ) {\n    if (!this.activeItem) {\n      // If no active item, activate the first item\n      this.activeItem = this.firstItem();\n      return;\n    }\n\n    const newActiveItem = this.findNextItem(this.activeItem, direction, options.toEnd);\n\n    if (newActiveItem) {\n      this.activeItem = newActiveItem;\n      this.keyboardActive = true;\n\n      if (options.shouldClearSelection) {\n        this.selectedItems = [];\n      }\n    }\n  }\n  /**\n   * Activates a specific item in the view.\n   *\n   * @param payload - An object containing activation details.\n   * @param payload.item - The path to the item to be activated.\n   * @param payload.keyboardActive - Indicates whether the activation is triggered by keyboard navigation.\n   * @param payload.navigate - Optional. If true, triggers navigation to the activated item. If \"refresh\", refreshes the current view.\n   * @param payload.shouldClearSelection - Optional. If true, clears the current selection before activating the item.\n   * @param payload.maintainDirection - Optional. If true, maintains the current navigation direction.\n   */\n  public activate(payload: {\n    item: PathToItem;\n    keyboardActive: boolean;\n    navigate?: boolean | \"refresh\";\n    shouldClearSelection?: boolean;\n    maintainDirection?: boolean;\n  }) {\n    this.activeItem = payload.item;\n    this.keyboardActive = payload.keyboardActive;\n    if (payload.shouldClearSelection) {\n      this.selectedItems = [];\n    }\n  }\n\n  /** Not implemented yet */\n  public addToSelection(_payload: { direction: Direction; selectActiveItemImmediately?: boolean }) {\n    // Implement add to selection logic\n  }\n\n  /** Not implemented yet */\n  public handleTabPress(_event: React.KeyboardEvent | KeyboardEvent) {\n    // Implement tab press logic\n  }\n\n  /** Select a specific item */\n  public select(items: PathToItem[]) {\n    this.selectedItems = items;\n    if (items.length > 0) {\n      this.activeItem = items[0];\n      this.focusedItem = items[0];\n    }\n  }\n\n  /** Select everything between two specific items */\n  public selectBetween(items: [PathToItem, PathToItem]) {\n    // Implement select between logic\n    const [start, end] = items;\n    const startIndex = this.selectedItems.findIndex(item => item === start);\n    const endIndex = this.selectedItems.findIndex(item => item === end);\n\n    if (startIndex !== -1 && endIndex !== -1) {\n      const selectedRange = this.selectedItems.slice(\n        Math.min(startIndex, endIndex),\n        Math.max(startIndex, endIndex) + 1\n      );\n      this.selectedItems = selectedRange;\n    } else {\n      // If either start or end is not in the current selection, select just these two items\n      this.selectedItems = [start, end];\n    }\n\n    this.activeItem = end;\n    this.focusedItem = end;\n  }\n\n  /** Deactivates the current active item. */\n  public deactivate() {\n    this.previouslyActiveItem = this.activeItem;\n    this.activeItem = null;\n    this.keyboardActive = false;\n  }\n\n  /**\n   * Focus a specific item in the view.\n   * @param item The item to focus\n   */\n  public focus(item: PathToItem) {\n    this.focusedItem = item;\n    this.activeItem = item;\n    this.keyboardActive = true;\n  }\n\n  /**\n   * Clears the selection.\n   */\n  public clearSelection() {\n    this.selectedItems = [];\n    this.focusedItem = null;\n    this.keyboardActive = false;\n  }\n\n  /** Perform shift + select logic, which is mostly just toggling a range between the existing selection and the selection starting point. */\n  public shiftSelect(item?: PathToItem) {\n    const startShiftSelectItem = item ?? this.activeItem;\n    if (!startShiftSelectItem) {\n      return;\n    }\n\n    this.previouslyActiveItem = null;\n    this.initialSelectedItem = this.initialSelectedItem || startShiftSelectItem;\n    this.activeItem = startShiftSelectItem;\n    this.focusedItem = startShiftSelectItem;\n\n    if (this.initialSelectedItem) {\n      this.selectedItems = this.getItemsBetween(startShiftSelectItem, this.initialSelectedItem);\n    } else {\n      this.selectedItems = [startShiftSelectItem];\n    }\n  }\n\n  /** Perform cmd + select logic (mostly just adds to the existing selection) */\n  public cmdSelect(item?: PathToItem) {\n    const startCmdSelectItem = item ?? this.activeItem;\n    if (!startCmdSelectItem || this.multiSelectDisabled) {\n      return;\n    }\n\n    const oldSelectedItems =\n      this.isSplitView && this.activeItem\n        ? this.uniqueItems([...this.selectedItems, this.activeItem])\n        : this.selectedItems;\n\n    if (this.isItemInSelection(startCmdSelectItem, oldSelectedItems)) {\n      const selectedItems = oldSelectedItems.filter(i => !this.areItemsEqual(i, startCmdSelectItem));\n      if (selectedItems.length > 0) {\n        this.focusedItem = selectedItems[selectedItems.length - 1];\n        this.selectedItems = selectedItems;\n      } else {\n        this.focusedItem = null;\n        this.initialSelectedItem = null;\n        this.selectedItems = [];\n      }\n    } else {\n      this.activeItem = startCmdSelectItem;\n      this.focusedItem = startCmdSelectItem;\n      this.initialSelectedItem = startCmdSelectItem;\n      this.selectedItems = [...oldSelectedItems, startCmdSelectItem].sort(this.itemSort);\n    }\n  }\n\n  /** Selects all sub-items to a specific item */\n  public selectAllSubItems(root: PathToItem) {\n    const pathToItems: PathToItem[] = [];\n    const rootItem = this.getItemForPath(root, false);\n    if (!rootItem?.subItems) {\n      return;\n    }\n\n    function selectAllItemsRec(items: GroupedViewItem<unknown>[], parentPath: PathToItem = []) {\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const path = [...parentPath, i];\n        if (item.interactive) {\n          pathToItems.push(path);\n        }\n        if (item.subItems) {\n          selectAllItemsRec(item.subItems, path);\n        }\n      }\n    }\n    selectAllItemsRec(rootItem.subItems, root);\n    this.selectedItems = pathToItems;\n  }\n\n  /** Aelect all items in view */\n  public selectAll() {\n    const pathToItems: PathToItem[] = [];\n    function selectAllItems(items: GroupedViewItem<unknown>[], parentPath: PathToItem = []) {\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const path = [...parentPath, i];\n        if (item.interactive) {\n          pathToItems.push(path);\n        }\n        if (item.subItems) {\n          selectAllItems(item.subItems, path);\n        }\n      }\n    }\n    selectAllItems(this.data);\n    this.selectedItems = pathToItems;\n  }\n\n  /** Not implemented yet */\n  public goToEnd() {\n    return;\n  }\n\n  /** Not implemented yet */\n  public goToStart() {\n    return;\n  }\n\n  /** Returns the item for a specific path\n   * @param path The path to the item.\n   * @param onlyInteractive If true, only returns interactive items. Default is false.\n   */\n  public getItemForPath(path: PathToItem, onlyInteractive: boolean): GroupedViewItem<unknown> | null {\n    let items = this.data;\n    let result: GroupedViewItem<unknown> | null = null;\n    for (const index of path) {\n      const item = items[index];\n      if (item && item.subItems) {\n        items = item.subItems;\n      }\n      result = onlyInteractive && item?.interactive ? item : item ?? null;\n    }\n    return result;\n  }\n\n  /**\n   * Finds the path to an item with the given key in the grouped view data.\n   *\n   * @param targetKey - The key of the item to find.\n   * @returns An array of indices representing the path to the item, or null if not found.\n   */\n  public pathToKey(targetKey: string): number[] | null {\n    return pathToKey(this.data, targetKey);\n  }\n\n  private findNextItem(\n    currentPathToItem: PathToItem,\n    direction: Direction,\n    toEnd: boolean = false,\n    onlySiblings: boolean = false\n  ): PathToItem | null {\n    const lastIndex = currentPathToItem.length - 1;\n    const parentPath = currentPathToItem.slice(0, -1);\n    const currentIndex = currentPathToItem[lastIndex];\n    const currentItem = this.getItemForPath(currentPathToItem, false);\n    if (!currentItem) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Could not find item for path\", [...currentPathToItem]);\n      return null;\n    }\n\n    if (toEnd) {\n      return direction === Direction.DownRight ? this.lastItem() : this.firstItem();\n    }\n\n    if (direction === Direction.DownRight) {\n      if (!onlySiblings) {\n        // Try to go to the first child of the current item\n        const firstChild = currentItem.subItems && this.firstItemInGroup(currentItem.subItems, currentPathToItem);\n\n        if (firstChild) {\n          return firstChild;\n        }\n      }\n      // Try to go to the next sibling\n      const [nextSiblingPath, nextSibling] = this.findNextSibling(currentPathToItem);\n      if (nextSibling) {\n        if (nextSibling.interactive) {\n          return nextSiblingPath;\n        } else {\n          return this.findNextItem(nextSiblingPath, direction);\n        }\n      }\n\n      // Go up and find the next available item\n      return this.findNextItem(parentPath, direction, toEnd, true);\n    } else {\n      if (currentIndex > 0) {\n        // Go to the previous sibling's last descendant\n        const previousSibling = [...parentPath, currentIndex - 1];\n        return this.findLastSubItem(previousSibling);\n      }\n      const parentItem = this.getItemForPath(parentPath, false);\n\n      // If we're at the first child, go to the parent\n      if (parentItem?.interactive) {\n        return parentPath;\n      } else {\n        return parentPath.length > 0 ? this.findNextItem(parentPath, direction) : null;\n      }\n    }\n  }\n\n  private firstItem() {\n    return this.firstItemInGroup(this.data);\n  }\n\n  private firstItemInGroup(items: GroupedViewItem<unknown>[], currentPath: PathToItem = []): PathToItem | null {\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      const path = [...currentPath, i];\n\n      // Check if the current item is interactive (not disabled)\n      if (item.interactive) {\n        return path;\n      }\n\n      // If the item has subitems, recursively search them\n      if (item.subItems && item.subItems.length > 0) {\n        const interactiveSubItem = this.firstItemInGroup(item.subItems, path);\n        if (interactiveSubItem) {\n          return interactiveSubItem;\n        }\n      }\n    }\n\n    // If no interactive item is found, return null\n    return null;\n  }\n\n  private lastItem() {\n    return this.lastItemInGroup(this.data);\n  }\n\n  private lastItemInGroup(items: GroupedViewItem<unknown>[], currentPath: PathToItem = []): PathToItem | null {\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n      const path = [...currentPath, i];\n\n      // If the item has subitems, recursively search them first\n      if (item.subItems && item.subItems.length > 0) {\n        const interactiveSubItem = this.lastItemInGroup(item.subItems, path);\n        if (interactiveSubItem) {\n          return interactiveSubItem;\n        }\n      }\n\n      // Check if the current item is interactive (not disabled)\n      if (item.interactive) {\n        return path;\n      }\n    }\n\n    // If no interactive item is found, return null\n    return null;\n  }\n\n  private findNextSibling(path: PathToItem): [PathToItem, GroupedViewItem<unknown>] | [null, null] {\n    const parentPath = path.slice(0, -1);\n    const currentIndex = path[path.length - 1];\n    const nextSiblingPath = [...parentPath, currentIndex + 1];\n    const nextSibling = this.getItemForPath(nextSiblingPath, false);\n\n    if (nextSibling) {\n      return [nextSiblingPath, nextSibling];\n    }\n\n    return [null, null];\n  }\n\n  private findLastSubItem(path: PathToItem): PathToItem | null {\n    const item = this.getItemForPath(path, false);\n    if (item && item.subItems && item.subItems.length > 0) {\n      const lastInteractiveIndex = item.subItems.findLastIndex(i => i.interactive);\n      return this.findLastSubItem([...path, lastInteractiveIndex]);\n    }\n    return item?.interactive ? path : null;\n  }\n\n  private uniqueItems(items: PathToItem[]): PathToItem[] {\n    return items.filter((item, index, self) => index === self.findIndex(t => this.areItemsEqual(t, item)));\n  }\n\n  private isItemInSelection(item: PathToItem, selection: PathToItem[]): boolean {\n    return selection.some(selectedItem => this.areItemsEqual(selectedItem, item));\n  }\n\n  private areItemsEqual(a: PathToItem, b: PathToItem): boolean {\n    return a.length === b.length && a.every((value, index) => value === b[index]);\n  }\n\n  private itemSort(a: PathToItem, b: PathToItem): number {\n    for (let i = 0; i < Math.min(a.length, b.length); i++) {\n      if (a[i] !== b[i]) {\n        return a[i] - b[i];\n      }\n    }\n    return a.length - b.length;\n  }\n\n  private getItemsBetween(from: PathToItem, to: PathToItem): PathToItem[] {\n    // This is a simplified version. You'll need to implement the full logic\n    // based on your specific data structure and requirements.\n    const start = Math.min(from[0], to[0]);\n    const end = Math.max(from[0], to[0]);\n    const items: PathToItem[] = [];\n\n    for (let i = start; i <= end; i++) {\n      items.push([i]);\n    }\n\n    return items;\n  }\n  /**\n   * Clears the keyboard active state.\n   * This method sets the `keyboardActive` flag to false, indicating that keyboard navigation is no longer active.\n   */\n  public clearKeyboardActive() {\n    this.keyboardActive = false;\n  }\n\n  /**\n   * Sets the keyboard active state.\n   * This method sets the `keyboardActive` flag to true, indicating that keyboard navigation is currently active.\n   */\n  public setKeyboardActive() {\n    this.keyboardActive = true;\n  }\n  /**\n   * Activates the next available item after the specified item.\n   * @param item - The path to the current item.\n   * This method attempts to find and activate the next interactive item in the view.\n   */\n  public activateNextAvailableItem(item: PathToItem) {\n    this.activeItem = this.findNextItem(item, Direction.DownRight);\n  }\n  /* is it possible to multi-select. */\n  private multiSelectDisabled: boolean = false;\n  /**\n   * Is the view a split view. This affects some activation & selection behaviour.\n   * TODO: Maybe remove\n   */\n  private isSplitView: boolean = false;\n  /** THe data displayed in the view. TODO: Maybe replace with provider. */\n  private data: GroupedViewItem<unknown>[] = [];\n}\n\ntype PathToItem = number[];\n\n/** Combined direction for moving active/selection. Up/Down for vertical, Left/Right for horizontal. */\nexport const Direction = {\n  UpLeft: \"up/left\",\n  DownRight: \"down/right\",\n} as const;\n/** Type for the combined direction for moving active/selection. Up/Down for vertical, Left/Right for horizontal. */\nexport type Direction = (typeof Direction)[keyof typeof Direction];\n\n/**\n * Actions for controlling view selection\n */\nexport type GroupedViewAction =\n  | {\n      // Move the active item in a given direction. If we're at the end of the dimension, the active doesn't move.\n      type: \"moveActive\";\n      payload: {\n        direction: Direction;\n        toEnd?: boolean;\n        navigate?: boolean;\n        shouldClearSelection?: boolean;\n        isDebounced?: boolean;\n        isPending?: boolean;\n      };\n    }\n  | {\n      // Activate a specific item. Used for hovering the list, pressing up/down on keyboard etc.\n      type: \"activate\";\n      payload: {\n        item: PathToItem;\n        keyboardActive: boolean;\n        navigate?: boolean | \"refresh\";\n        shouldClearSelection?: boolean;\n        maintainDirection?: boolean;\n      };\n    }\n  | {\n      // Add an item to the selection.\n      type: \"addToSelection\";\n      payload: {\n        direction: Direction;\n        /**\n         * If no item is selected but there's an active item, this flag controls wether to select both the active and the next item,\n         * or just the active item.\n         */\n        selectActiveItemImmediately?: boolean;\n      };\n    }\n  | {\n      // Moves the active & focused item one step.\n      type: \"tabPress\";\n      payload: React.KeyboardEvent | KeyboardEvent;\n    }\n  | { type: \"select\"; payload: PathToItem[]; allowWithInPageFind?: boolean }\n  | { type: \"selectBetween\"; payload: [PathToItem, PathToItem] }\n  | { type: \"deactivate\"; allowWithInPageFind?: boolean }\n  | { type: \"focus\"; payload: { item: PathToItem } }\n  | { type: \"navigateToActive\"; payload: { replace: boolean } }\n  | { type: \"clearSelection\" }\n  | { type: \"shiftSelect\"; payload?: PathToItem }\n  | { type: \"cmdSelect\"; payload?: PathToItem }\n  | { type: \"selectAllInGroup\"; payload: PathToItem }\n  | { type: \"selectAll\" }\n  | { type: \"goToEnd\" }\n  | { type: \"goToStart\" }\n  | { type: \"clearKeyboardActive\" }\n  | { type: \"setKeyboardActive\" }\n  | { type: \"activateNextAvailableItem\"; payload: PathToItem }\n  | { type: \"openSelectionInTabs\" };\n\nfunction pathToKey<T>(data: GroupedViewItem<T>[], targetKey: string, currentPath: number[] = []): number[] | null {\n  for (let i = 0; i < data.length; i++) {\n    const item = data[i];\n\n    if (item.key === targetKey) {\n      return [...currentPath, i];\n    }\n\n    if (item.subItems) {\n      const result = pathToKey(item.subItems, targetKey, [...currentPath, i]);\n      if (result !== null) {\n        return result;\n      }\n    }\n  }\n\n  return null;\n}\n```\ncan you generate unit tests for all actions in this code? for any action that accepts an item, the item should be on the second or third level f nesting. the test data should be a nested GroupedViewItem<unknown>[] where the top level is not interactive and other levels are all interactive. the test data should have three levels of nesting.\nCertainly! I'll create unit tests for the actions in the `GroupedViewState` class using a nested `GroupedViewItem<unknown>[]` structure as you described. Here's a set of unit tests that cover the main actions:\n\n```typescript\nimport { GroupedViewState, Direction, GroupedViewItem } from './GroupedViewState';\n\ndescribe('GroupedViewState', () => {\n  let state: GroupedViewState;\n  let testData: GroupedViewItem<unknown>[];\n\n  beforeEach(() => {\n    testData = [\n      {\n        key: 'group1',\n        interactive: false,\n        subItems: [\n          {\n            key: 'item1-1',\n            interactive: true,\n            subItems: [\n              { key: 'item1-1-1', interactive: true },\n              { key: 'item1-1-2', interactive: true },\n            ],\n          },\n          {\n            key: 'item1-2',\n            interactive: true,\n            subItems: [\n              { key: 'item1-2-1', interactive: true },\n              { key: 'item1-2-2', interactive: true },\n            ],\n          },\n        ],\n      },\n      {\n        key: 'group2',\n        interactive: false,\n        subItems: [\n          {\n            key: 'item2-1',\n            interactive: true,\n            subItems: [\n              { key: 'item2-1-1', interactive: true },\n              { key: 'item2-1-2', interactive: true },\n            ],\n          },\n          {\n            key: 'item2-2',\n            interactive: true,\n            subItems: [\n              { key: 'item2-2-1', interactive: true },\n              { key: 'item2-2-2', interactive: true },\n            ],\n          },\n        ],\n      },\n    ];\n\n    state = new GroupedViewState({ data: testData });\n  });\n\n  test('moveActive', () => {\n    state.moveActive(Direction.DownRight, {});\n    expect(state.activeItem).toEqual([0, 0]);\n\n    state.moveActive(Direction.DownRight, {});\n    expect(state.activeItem).toEqual([0, 0, 0]);\n\n    state.moveActive(Direction.DownRight, {});\n    expect(state.activeItem).toEqual([0, 0, 1]);\n  });\n\n  test('activate', () => {\n    state.activate({ item: [0, 1, 0], keyboardActive: true });\n    expect(state.activeItem).toEqual([0, 1, 0]);\n    expect(state.keyboardActive).toBe(true);\n  });\n\n  test('select', () => {\n    state.select([[0, 0, 1], [0, 1, 0]]);\n    expect(state.selectedItems).toEqual([[0, 0, 1], [0, 1, 0]]);\n    expect(state.activeItem).toEqual([0, 0, 1]);\n    expect(state.focusedItem).toEqual([0, 0, 1]);\n  });\n\n  test('selectBetween', () => {\n    state.selectBetween([[0, 0, 0], [0, 1, 1]]);\n    expect(state.selectedItems).toEqual([[0, 0, 0], [0, 1, 1]]);\n    expect(state.activeItem).toEqual([0, 1, 1]);\n    expect(state.focusedItem).toEqual([0, 1, 1]);\n  });\n\n  test('deactivate', () => {\n    state.activate({ item: [0, 1, 0], keyboardActive: true });\n    state.deactivate();\n    expect(state.activeItem).toBeNull();\n    expect(state.keyboardActive).toBe(false);\n  });\n\n  test('focus', () => {\n    state.focus([1, 0, 1]);\n    expect(state.focusedItem).toEqual([1, 0, 1]);\n    expect(state.activeItem).toEqual([1, 0, 1]);\n    expect(state.keyboardActive).toBe(true);\n  });\n\n  test('clearSelection', () => {\n    state.select([[0, 0, 1], [0, 1, 0]]);\n    state.clearSelection();\n    expect(state.selectedItems).toEqual([]);\n    expect(state.focusedItem).toBeNull();\n    expect(state.keyboardActive).toBe(false);\n  });\n\n  test('shiftSelect', () => {\n    state.shiftSelect([0, 1, 0]);\n    expect(state.selectedItems).toEqual([[0, 1, 0]]);\n    state.shiftSelect([1, 0, 1]);\n    expect(state.selectedItems).toContainEqual([0, 1, 0]);\n    expect(state.selectedItems).toContainEqual([1, 0, 1]);\n  });\n\n  test('cmdSelect', () => {\n    state.cmdSelect([0, 1, 0]);\n    expect(state.selectedItems).toEqual([[0, 1, 0]]);\n    state.cmdSelect([1, 0, 1]);\n    expect(state.selectedItems).toEqual([[0, 1, 0], [1, 0, 1]]);\n    state.cmdSelect([0, 1, 0]);\n    expect(state.selectedItems).toEqual([[1, 0, 1]]);\n  });\n\n  test('selectAllSubItems', () => {\n    state.selectAllSubItems([0, 1]);\n    expect(state.selectedItems).toEqual([[0, 1, 0], [0, 1, 1]]);\n  });\n\n  test('selectAll', () => {\n    state.selectAll();\n    expect(state.selectedItems.length).toBe(8); // Total number of interactive items\n  });\n\n  test('clearKeyboardActive', () => {\n    state.setKeyboardActive();\n    state.clearKeyboardActive();\n    expect(state.keyboardActive).toBe(false);\n  });\n\n  test('setKeyboardActive', () => {\n    state.setKeyboardActive();\n    expect(state.keyboardActive).toBe(true);\n  });\n\n  test('activateNextAvailableItem', () => {\n    state.activateNextAvailableItem([0, 0, 1]);\n    expect(state.activeItem).toEqual([0, 1, 0]);\n  });\n});\n```\n\nThese tests cover the main actions in the `GroupedViewState` class. They use a nested `GroupedViewItem<unknown>[]` structure with three levels of nesting, where the top level is not interactive, and other levels are interactive.\n\nNote that some methods like `goToEnd`, `goToStart`, `addToSelection`, and `handleTabPress` are not fully implemented in the original code, so I didn't include tests for them. You may want to add tests for these methods once they are implemented.\n\nAlso, the `getItemsBetween` method in the original code is a simplified version, so the `selectBetween` test might need to be adjusted based on the actual implementation of this method.\n\nRemember to import and set up your testing framework (like Jest) properly before running these tests.\n```ts linear-app/orbiter/src/components/GroupedView/GroupedViewState.test.ts\nimport { beforeEach, describe, expect, test } from 'vitest';\nimport { GroupedViewState, Direction, } from './useGroupedViewState';\nimport { GroupedViewItem } from './GroupedViewTypes';\n\ndescribe('GroupedViewState', () => {\n  let state: GroupedViewState;\n  let testData: GroupedViewItem<unknown>[];\n\n  beforeEach(() => {\n    testData = [\n      {\n        textContent: \"\", data: {}, key: 'group1',\n        interactive: false,\n        subItems: [\n          {\n            textContent: \"\", data: {}, key: 'item1-1',\n            interactive: true,\n            subItems: [\n              { textContent: \"\", data: {}, key: 'item1-1-1', interactive: true },\n              { textContent: \"\", data: {}, key: 'item1-1-2', interactive: true },\n            ],\n          },\n          {\n            textContent: \"\", data: {}, key: 'item1-2',\n            interactive: true,\n            subItems: [\n              { textContent: \"\", data: {}, key: 'item1-2-1', interactive: true },\n              { textContent: \"\", data: {}, key: 'item1-2-2', interactive: true },\n            ],\n          },\n        ],\n      },\n      {\n        textContent: \"\", data: {}, key: 'group2',\n        interactive: false,\n        subItems: [\n          {\n            textContent: \"\", data: {}, key: 'item2-1',\n            interactive: true,\n            subItems: [\n              { textContent: \"\", data: {}, key: 'item2-1-1', interactive: true },\n              { textContent: \"\", data: {}, key: 'item2-1-2', interactive: true },\n            ],\n          },\n          {\n            textContent: \"\", data: {}, key: 'item2-2',\n            interactive: true,\n            subItems: [\n              { textContent: \"\", data: {}, key: 'item2-2-1', interactive: true },\n              { textContent: \"\", data: {}, key: 'item2-2-2', interactive: true },\n            ],\n          },\n        ],\n      },\n    ];\n\n    state = new GroupedViewState({ data: testData });\n  });\n\n  test('moveActive', () => {\n    state.moveActive(Direction.DownRight, {});\n    expect(state.activeItem).toEqual([0, 0]);\n\n    state.moveActive(Direction.DownRight, {});\n    expect(state.activeItem).toEqual([0, 0, 0]);\n\n    state.moveActive(Direction.DownRight, {});\n    expect(state.activeItem).toEqual([0, 0, 1]);\n  });\n\n  test('activate', () => {\n    state.activate({ item: [0, 1, 0], keyboardActive: true });\n    expect(state.activeItem).toEqual([0, 1, 0]);\n    expect(state.keyboardActive).toBe(true);\n  });\n\n  test('select', () => {\n    state.select([[0, 0, 1], [0, 1, 0]]);\n    expect(state.selectedItems).toEqual([[0, 0, 1], [0, 1, 0]]);\n    expect(state.activeItem).toEqual([0, 0, 1]);\n    expect(state.focusedItem).toEqual([0, 0, 1]);\n  });\n\n  test('selectBetween', () => {\n    state.selectBetween([[0, 0, 0], [0, 1, 1]]);\n    expect(state.selectedItems).toEqual([[0, 0, 0], [0, 1, 1]]);\n    expect(state.activeItem).toEqual([0, 1, 1]);\n    expect(state.focusedItem).toEqual([0, 1, 1]);\n  });\n\n  test('deactivate', () => {\n    state.activate({ item: [0, 1, 0], keyboardActive: true });\n    state.deactivate();\n    expect(state.activeItem).toBeNull();\n    expect(state.keyboardActive).toBe(false);\n  });\n\n  test('focus', () => {\n    state.focus([1, 0, 1]);\n    expect(state.focusedItem).toEqual([1, 0, 1]);\n    expect(state.activeItem).toEqual([1, 0, 1]);\n    expect(state.keyboardActive).toBe(true);\n  });\n\n  test('clearSelection', () => {\n    state.select([[0, 0, 1], [0, 1, 0]]);\n    state.clearSelection();\n    expect(state.selectedItems).toEqual([]);\n    expect(state.focusedItem).toBeNull();\n    expect(state.keyboardActive).toBe(false);\n  });\n\n  test('shiftSelect', () => {\n    state.shiftSelect([0, 1, 0]);\n    expect(state.selectedItems).toEqual([[0, 1, 0]]);\n    state.shiftSelect([1, 0, 1]);\n    expect(state.selectedItems).toContainEqual([0, 1, 0]);\n    expect(state.selectedItems).toContainEqual([1, 0, 1]);\n  });\n\n  test('cmdSelect', () => {\n    state.cmdSelect([0, 1, 0]);\n    expect(state.selectedItems).toEqual([[0, 1, 0]]);\n    state.cmdSelect([1, 0, 1]);\n    expect(state.selectedItems).toEqual([[0, 1, 0], [1, 0, 1]]);\n    state.cmdSelect([0, 1, 0]);\n    expect(state.selectedItems).toEqual([[1, 0, 1]]);\n  });\n\n  test('selectAllSubItems', () => {\n    state.selectAllSubItems([0, 1]);\n    expect(state.selectedItems).toEqual([[0, 1, 0], [0, 1, 1]]);\n  });\n\n  test('selectAll', () => {\n    state.selectAll();\n    expect(state.selectedItems.length).toBe(8); // Total number of interactive items\n  });\n\n  test('clearKeyboardActive', () => {\n    state.setKeyboardActive();\n    state.clearKeyboardActive();\n    expect(state.keyboardActive).toBe(false);\n  });\n\n  test('setKeyboardActive', () => {\n    state.setKeyboardActive();\n    expect(state.keyboardActive).toBe(true);\n  });\n\n  test('activateNextAvailableItem', () => {\n    state.activateNextAvailableItem([0, 0, 1]);\n    expect(state.activeItem).toEqual([0, 1, 0]);\n  });\n});\n```\ncan you change the test data so that the key matches the path to the item? So the item with path [0,0,1] should have the key \"0-0-1\".\nCertainly! I'll modify the test data so that the key for each item matches its path. Here's the updated test data:\n\n```typescript\nimport { beforeEach, describe, expect, test } from 'vitest';\nimport { GroupedViewState, Direction, } from './useGroupedViewState';\nimport { GroupedViewItem } from './GroupedViewTypes';\n\ndescribe('GroupedViewState', () => {\n  let state: GroupedViewState;\n  let testData: GroupedViewItem<unknown>[];\n\n  beforeEach(() => {\n    testData = [\n      {\n        textContent: \"\", data: {}, key: '0',\n        interactive: false,\n        subItems: [\n          {\n            textContent: \"\", data: {}, key: '0-0',\n            interactive: true,\n            subItems: [\n              { textContent: \"\", data: {}, key: '0-0-0', interactive: true },\n              { textContent: \"\", data: {}, key: '0-0-1', interactive: true },\n            ],\n          },\n          {\n            textContent: \"\", data: {}, key: '0-1',\n            interactive: true,\n            subItems: [\n              { textContent: \"\", data: {}, key: '0-1-0', interactive: true },\n              { textContent: \"\", data: {}, key: '0-1-1', interactive: true },\n            ],\n          },\n        ],\n      },\n      {\n        textContent: \"\", data: {}, key: '1',\n        interactive: false,\n        subItems: [\n          {\n            textContent: \"\", data: {}, key: '1-0',\n            interactive: true,\n            subItems: [\n              { textContent: \"\", data: {}, key: '1-0-0', interactive: true },\n              { textContent: \"\", data: {}, key: '1-0-1', interactive: true },\n            ],\n          },\n          {\n            textContent: \"\", data: {}, key: '1-1',\n            interactive: true,\n            subItems: [\n              { textContent: \"\", data: {}, key: '1-1-0', interactive: true },\n              { textContent: \"\", data: {}, key: '1-1-1', interactive: true },\n            ],\n          },\n        ],\n      },\n    ];\n\n    state = new GroupedViewState({ data: testData });\n  });\n\n  // ... rest of the test cases remain the same\n});\n```\n\nIn this updated version, the key for each item is now a string representation of its path, with the levels separated by hyphens. For example:\n\n- The item at path [0, 0, 1] now has the key \"0-0-1\"\n- The item at path [1, 1, 0] now has the key \"1-1-0\"\n\nThis change makes it easier to correlate the keys with the paths used in the tests, which can be helpful for debugging and understanding the structure of the test data.\n\nThe test cases themselves don't need to change, as they were already using the correct paths. However, if you have any tests that rely on specific key values, you would need to update those to match the new key format.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4737}},"image_offsets":[]},{"id":{"replica_id":0,"value":570},"start":22714,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":4738}},"image_offsets":[]},{"id":{"replica_id":0,"value":571},"start":28098,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4739}},"image_offsets":[]},{"id":{"replica_id":0,"value":712},"start":33181,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":4740}},"image_offsets":[]},{"id":{"replica_id":0,"value":713},"start":35863,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":4741}},"image_offsets":[]}],"summary":"Unit tests for GroupedViewState actions","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":22371},"icon":"File","label":"linear-app/orbiter/src/components/GroupedView/useGroupedViewState.ts"},{"range":{"start":28098,"end":33046},"icon":"File","label":"linear-app/orbiter/src/components/GroupedView/GroupedViewState.test.ts"}]}