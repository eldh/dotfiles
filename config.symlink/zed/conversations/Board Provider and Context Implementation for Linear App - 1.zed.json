{"id":"8e638f08-3e03-4b53-997d-048c8a405203","zed":"context","version":"0.4.0","text":"\n\n\n```tsx linear-app/client/src/components/Board/BoardProviders.tsx\nimport * as React from \"react\";\nimport type { VirtuosoHandle } from \"react-virtuoso\";\nimport { observer } from \"mobx-react-lite\";\nimport { useComponentWidth } from \"@linear/orbiter/hooks/useComponentSize\";\nimport type { GroupedViewItemKey, PathToItem } from \"@linear/orbiter/components/GroupedView/GroupedViewTypes\";\nimport { ViewPeek } from \"~/components/List/ViewPeek\";\nimport type {\n  AnyGroupedDataProvider,\n  ItemIndices,\n} from \"~/components/List/components/dataProviders/GroupedViewDataProvider\";\nimport { RegisterSelectedAndActiveItems } from \"~/hooks/useRegisterSelectedAndActiveItems\";\nimport {\n  useInternalInitialBoardPosition,\n  type BoardInitialPosition,\n} from \"~/components/Board/hooks/useScrollToBoardItems\";\nimport type { VirtualList } from \"~/components/VirtualList\";\nimport type { ModelListRow } from \"../VirtualList/ModelListProvider\";\nimport type { AnyDataProvider } from \"../List/components/dataProviders/AnyDataProvider\";\nimport { IssuePeekNew } from \"../Peek/IssuePeek\";\nimport { useInternalBoardGroups, type BoardGroupsInfo } from \"./hooks/useInternalBoardGroups\";\nimport { useInternalBoardNavigation, type BoardNavigationState } from \"./hooks/useInternalBoardNavigation\";\nimport { useCollapsedSubGroups, type CollapsedSubGroupsState } from \"./hooks/useCollapsedSubGroups\";\nimport { getBoardType, type BoardType, useHasSubGroups, useColumnWidth } from \"./boardHelpers\";\n\n/** Refs to layout elements of the board */\ntype BoardLayoutRefs = {\n  /**\n   * Instance to the first virtual scroller rendering columns (horizontal scroll), i.e. the virtual\n   * scroller for the column headers (though it doesn't really matter which row this is attached to).\n   * Every row has a separate virtual columns scroller, but they are all synced via the global scroller\n   * element scroll position.\n   */\n  virtualColumnsListRef: React.RefObject<VirtualList>;\n  /** Instance of Virtuoso virtual scroll which manages virtual scroll of board rows (vertical scroll) */\n  virtualRowsListRef: React.RefObject<VirtuosoHandle>;\n  /** Global scroller element of the board (scrolls in two dimensions) */\n  scrollerRef: React.RefObject<HTMLDivElement>;\n  /** Container element of the board (technically not a ref, but here for convenience) */\n  containerEl: HTMLDivElement | null;\n};\n\ntype BoardProvidersProps = {\n  children: React.ReactNode;\n  /** Grouped data provider for the view */\n  provider: AnyGroupedDataProvider | AnyDataProvider<ModelListRow, unknown>;\n  /** Refs for global board layout scroller elements */\n  refs: BoardLayoutRefs;\n};\n\n/**\n * Wraps the board with providers that expose board context values (grouped by change frequency).\n */\nexport function BoardProviders(props: BoardProvidersProps) {\n  const { children, provider, refs } = props;\n  const provider_ = React.useMemo(() => (\"data\" in provider ? new BoardProvider(provider) : provider), [provider]);\n  return (\n    <BoardProviderProvider provider={provider_} refs={refs}>\n      <BoardLayoutProvider>\n        <BoardNavigationProvider>\n          <BoardInitialPositionProvider>{children}</BoardInitialPositionProvider>\n        </BoardNavigationProvider>\n      </BoardLayoutProvider>\n    </BoardProviderProvider>\n  );\n}\n\n/** Provider for voard, post 2024 refactor */\nclass BoardProvider<M> implements NewBoardDataProvider {\n  public constructor(provider: AnyDataProvider<ModelListRow, M>) {\n    this.provider = provider;\n  }\n\n  /**\n   * Get the data from the provider.\n   * @returns The data from the provider.\n   */\n  public get data() {\n    return this.provider.data;\n  }\n\n  /**\n   * Get the filtered items from the provider.\n   * @returns The filtered items from the provider.\n   */\n  public get filteredItems() {\n    return this.provider.filteredItems;\n  }\n\n  public get subGroupCounts() {\n    let res: number[] = [];\n  }\n\n  /**\n   * Get the view preferences from the provider.\n   * @returns The view preferences from the provider.\n   */\n  public get viewPreferences() {\n    return this.provider.viewPreferences!; // TODO sort this out\n  }\n\n  /**\n   * Get the cluster counts.\n   * @returns A 2D array of cluster counts.\n   */\n  public get clusterCounts(): number[][] {\n    let res: number[][] = [];\n    for (let group of this.data) {\n      res.push([]);\n      if (group.subItems) {\n        for (let subGroup of group.subItems) {\n          if (subGroup.subItems) {\n            res[res.length - 1].push(subGroup.subItems.length);\n          } else {\n            res[res.length - 1].push(0);\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Determines if an item can be dropped in a specific cluster.\n   * @param itemKey - The unique identifier of the item being dropped.\n   * @param clusterPath - The path to the target cluster.\n   * @returns A boolean indicating whether the item can be dropped in the specified cluster.\n   */\n  public canDropInCluster(itemKey: GroupedViewItemKey, clusterPath: PathToItem): boolean {\n    return false; // TODO implement\n  }\n\n  /**\n   * Determines if a cluster is ordered manually.\n   * @param path - The path to the cluster.\n   * @returns A boolean indicating whether the cluster is ordered manually.\n   */\n  public isClusterOrderedManually(path: PathToItem): boolean {\n    return false; // TODO implement\n  }\n\n  /**\n   * The type of item displayed in the board.\n   * Can be either \"issue\" or \"project\".\n   */\n  public itemType: \"issue\" | \"project\";\n\n  // Private interface\n  private provider: AnyDataProvider<ModelListRow, M>;\n}\n\ntype LegacyBoardProviderContextType = {\n  /** Data provider for the board */\n  provider: LegacyBoardDataProvider;\n  /** Type of the model displayed by the board */\n  boardType: BoardType;\n  /** Whether the board has sub-groups (rows, a.k.a. swimlanes) */\n  hasSubGroups: boolean;\n  /** Width of a single column in the board */\n  columnWidth: number;\n  /** Width of the container element (i.e. the visible portion of the board) */\n  containerWidth: number;\n  /** Width of all columns combined */\n  allColumnsWidth: number;\n  refs: BoardLayoutRefs;\n};\n\ntype NewBoardProviderContextType = {\n  /** Data provider for the board */\n  provider: NewBoardDataProvider;\n  /** Type of the model displayed by the board */\n  boardType: BoardType;\n  /** Whether the board has sub-groups (rows, a.k.a. swimlanes) */\n  hasSubGroups: boolean;\n  /** Width of a single column in the board */\n  columnWidth: number;\n  /** Width of the container element (i.e. the visible portion of the board) */\n  containerWidth: number;\n  /** Width of all columns combined */\n  allColumnsWidth: number;\n  refs: BoardLayoutRefs;\n};\nconst LegacyBoardProviderContext = React.createContext<LegacyBoardProviderContextType | null>(null);\nconst NewBoardProviderContext = React.createContext<NewBoardProviderContextType | null>(null);\n\n/**\n * Hook to retrieve the board data provider and misc board context.\n * @returns The board data provider and common derived values\n * @deprecated\n */\nexport function useLegacyBoardProvider() {\n  const value = React.useContext(LegacyBoardProviderContext);\n  if (!value) {\n    throw new Error(\"BoardProviderContext not found\");\n  }\n  return value;\n}\n\n/**\n * Hook to retrieve the board data provider and misc board context.\n * @returns The board data provider and common derived values\n */\nexport function useBoardProvider(): NewBoardProviderContextType | LegacyBoardProviderContextType {\n  const newValue = React.useContext(NewBoardProviderContext);\n  const legacyValue = React.useContext(LegacyBoardProviderContext);\n  const res = newValue || legacyValue;\n  if (!res) {\n    throw new Error(\"BoardProviderContext not found\");\n  }\n  return res;\n}\n\nconst BoardProviderProvider = observer(function BoardProviderProvider_(props: BoardProvidersProps) {\n  const { children, refs, provider } = props;\n  if (!(\"viewPreferences\" in provider)) {\n    throw new Error(\"Cannot render boards without view preferences\");\n  }\n  if (!(\"clusterCounts\" in provider)) {\n    throw new Error(\"Cannot render boards without cluster counts\");\n  }\n  if (!(\"canDropInCluster\" in provider)) {\n    throw new Error(\"Cannot render boards without canDropInCluster method\");\n  }\n\n  const boardProvider = provider as BoardDataProvider;\n\n  const containerWidth = useComponentWidth({ current: refs.containerEl }) ?? 0;\n  const allColumnsWidth = useAllColumnsWidth(containerWidth);\n\n  const boardType = getBoardType(boardProvider);\n  const hasSubGroups = useHasSubGroups(boardProvider);\n  const columnWidth = useColumnWidth(boardProvider);\n  const boardProviderValue = React.useMemo(\n    () => ({ provider, boardType, hasSubGroups, columnWidth, refs, containerWidth, allColumnsWidth }),\n    [provider, boardType, hasSubGroups, columnWidth, refs, containerWidth, allColumnsWidth]\n  );\n\n  return \"data\" in provider ? (\n    <NewBoardProviderContext.Provider value={boardProviderValue as unknown as NewBoardProviderContextType}>\n      {children}\n    </NewBoardProviderContext.Provider>\n  ) : (\n    <LegacyBoardProviderContext.Provider value={boardProviderValue as LegacyBoardProviderContextType}>\n      {children}\n    </LegacyBoardProviderContext.Provider>\n  );\n});\n\nconst BoardLayoutContext = React.createContext<(BoardGroupsInfo & { collapsedRows: CollapsedSubGroupsState }) | null>(\n  null\n);\n\n/**\n * Hook to retrieve the info and controls for board layout from context.\n * @returns Board layout controls and info\n */\nexport function useBoardLayout() {\n  const value = React.useContext(BoardLayoutContext);\n  if (!value) {\n    throw new Error(\"BoardLayoutContext not found\");\n  }\n  return value;\n}\n\nconst BoardLayoutProvider = observer(function BoardLayoutProvider_(props: { children: React.ReactNode }) {\n  const { children } = props;\n  const boardGroupsInfo = useInternalBoardGroups();\n  const collapsedRowsState = useCollapsedSubGroups(boardGroupsInfo);\n  const layoutProviderValue = React.useMemo(\n    () => ({ ...boardGroupsInfo, collapsedRows: collapsedRowsState }),\n    [boardGroupsInfo, collapsedRowsState]\n  );\n\n  return <BoardLayoutContext.Provider value={layoutProviderValue}>{children}</BoardLayoutContext.Provider>;\n});\n\nconst BoardNavigationContext = React.createContext<BoardNavigationState | null>(null);\n\n/**\n * Hook to retrieve the info and controls for board navigation and selection.\n * @returns Board navigation controls and info\n */\nexport function useBoardNavigation() {\n  const value = React.useContext(BoardNavigationContext);\n  if (!value) {\n    throw new Error(\"BoardNavigationContext not found\");\n  }\n  return value;\n}\n\nconst BoardActiveItemContext = React.createContext<ItemIndices | null>(null);\n\n/**\n * Hook to retrieve the active item in the board from context.\n * @returns The active item in the board\n */\nexport function useBoardActiveItem() {\n  return React.useContext(BoardActiveItemContext);\n}\n\nconst BoardNavigationProvider = observer(function BoardNavigationProvider_(props: { children: React.ReactNode }) {\n  const { children } = props;\n  const { provider } = useLegacyBoardProvider();\n  const boardLayout = useBoardLayout();\n  const { navigationState, activeItem } = useInternalBoardNavigation({\n    provider,\n    hiddenGroups: boardLayout.allHiddenColumns,\n    hiddenSubGroups: boardLayout.allHiddenRows,\n    collapsedSubGroups: boardLayout.collapsedRows.allCollapsed,\n  });\n\n  return (\n    <>\n      <BoardNavigationContext.Provider value={navigationState}>\n        <BoardActiveItemContext.Provider value={activeItem}>{children}</BoardActiveItemContext.Provider>\n      </BoardNavigationContext.Provider>\n      {\"modelForItem\" in provider ? (\n        <RegisterSelectedAndActiveItems\n          activeItem={activeItem}\n          selectedItems={navigationState.selectedItems}\n          provider={provider}\n        />\n      ) : null}\n      {\"modelForItem\" in provider ? (\n        <ViewPeek navigationState={{ ...navigationState, activeItem }} provider={provider} />\n      ) : (\n        <ViewPeek renderer={IssuePeekNew} />\n      )}\n    </>\n  );\n});\n\nconst BoardInitialPositionContext = React.createContext<BoardInitialPosition | null>(null);\n/**\n * Hook to retrieve the initial position of the board from context.\n * @returns The initial position of the board\n */\nexport function useBoardInitialPosition() {\n  return React.useContext(BoardInitialPositionContext);\n}\n\nconst BoardInitialPositionProvider = observer(function BoardInitialPositionProviderProvider_(props: {\n  children: React.ReactNode;\n}) {\n  const initialPosition = useInternalInitialBoardPosition();\n  return (\n    <BoardInitialPositionContext.Provider value={initialPosition}>\n      {props.children}\n    </BoardInitialPositionContext.Provider>\n  );\n});\n\ntype RequiredProperties<T, P extends keyof T> = Omit<T, P> & Required<Pick<T, P>>;\n\n/** Legacy provider, used for boards */\nexport type LegacyBoardDataProvider = RequiredProperties<\n  AnyGroupedDataProvider,\n  \"clusterCounts\" | \"viewPreferences\" | \"canDropInCluster\" | \"isClusterOrderedManually\"\n>;\n\n/** View refactor 2024 enhanced provider that is valid to use in the board */\nexport type NewBoardDataProvider = RequiredProperties<AnyDataProvider<ModelListRow, unknown>, \"viewPreferences\"> & {\n  clusterCounts: number[][];\n  canDropInCluster: (itemKey: GroupedViewItemKey, clusterPath: PathToItem) => boolean;\n  isClusterOrderedManually(path: PathToItem): boolean;\n  itemType: \"issue\" | \"project\";\n};\n\n/** GroupedDataProvider that is valid to use in the board */\nexport type BoardDataProvider = LegacyBoardDataProvider | NewBoardDataProvider;\n\n// Observe the width of all the columns combined\nfunction useAllColumnsWidth(defaultValue: number) {\n  const [allColumnsWidth, setAllColumnsWidth] = React.useState(defaultValue);\n  React.useEffect(() => {\n    const parent = self.document.querySelector(\"[data-virtuoso-scroller]\");\n    if (!parent) {\n      return;\n    }\n    const resizeObserver = new ResizeObserver(event => {\n      setAllColumnsWidth(event[0].contentBoxSize[0].inlineSize);\n    });\n    resizeObserver.observe(parent);\n    return () => resizeObserver.disconnect();\n  }, [defaultValue]);\n\n  return allColumnsWidth;\n}\n```\ndiagnostics: linear-app/client/src/components/Board/BoardProviders.tsx\n```tsx\n  }\n\n  public get subGroupCounts() {\n// error: A 'get' accessor must return a value.\n    let res: number[] = [];\n  }\n```\n\nimplement subGroupCounts. it should sum up clusterCounts, so that if clusterCounts is [[0,1,2],[0,1,2]], subGroupCounts should be [0,2,4]\nCertainly! I'll implement the `subGroupCounts` getter to sum up the `clusterCounts` as you described. Here's the corrected implementation:\n\n```typescript\npublic get subGroupCounts(): number[] {\n  const res: number[] = [];\n  const clusterCounts = this.clusterCounts;\n\n  for (let i = 0; i < clusterCounts[0].length; i++) {\n    let sum = 0;\n    for (let j = 0; j < clusterCounts.length; j++) {\n      sum += clusterCounts[j][i] || 0;\n    }\n    res.push(sum);\n  }\n\n  return res;\n}\n```\n\nThis implementation does the following:\n\n1. It initializes an empty array `res` to store the results.\n2. It gets the `clusterCounts` from the existing getter.\n3. It iterates over the columns (assuming all rows have the same number of columns as the first row).\n4. For each column, it sums up the counts across all rows.\n5. It pushes the sum for each column into the `res` array.\n6. Finally, it returns the `res` array containing the summed counts for each column.\n\nThis implementation will correctly handle the example you provided:\n- If `clusterCounts` is `[[0,1,2],[0,1,2]]`, `subGroupCounts` will return `[0,2,4]`.\n\nIt also handles cases where rows might have different numbers of columns by using `clusterCounts[j][i] || 0`, which will use 0 if a count is not present for a particular row and column.\nimplement groupCoounts, which for the same clusterCounts should return [3,3]\nCertainly! I'll implement the `groupCounts` getter to sum up the counts for each row in `clusterCounts`. Here's the implementation:\n\n```typescript\npublic get groupCounts(): number[] {\n  return this.clusterCounts.map(row => row.reduce((sum, count) => sum + count, 0));\n}\n```\n\nThis implementation does the following:\n\n1. It uses the `map` function to iterate over each row in `clusterCounts`.\n2. For each row, it uses the `reduce` function to sum up all the counts in that row.\n3. The result is an array where each element represents the sum of counts for a row.\n\nSo, for the example where `clusterCounts` is `[[0,1,2],[0,1,2]]`:\n\n- The first row `[0,1,2]` sums to 3\n- The second row `[0,1,2]` also sums to 3\n- The resulting `groupCounts` will be `[3,3]`\n\nThis getter can be added to the `BoardProvider` class like this:\n\n```typescript\nclass BoardProvider<M> implements NewBoardDataProvider {\n  // ... other methods and properties ...\n\n  public get groupCounts(): number[] {\n    return this.clusterCounts.map(row => row.reduce((sum, count) => sum + count, 0));\n  }\n\n  // ... rest of the class ...\n}\n```\n\nThis implementation will correctly handle the example you provided and will work for `clusterCounts` of any size, summing up the counts for each row independently.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":155}},"image_offsets":[]},{"id":{"replica_id":0,"value":56},"start":14408,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":156}},"image_offsets":[]},{"id":{"replica_id":0,"value":57},"start":15694,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":157}},"image_offsets":[]},{"id":{"replica_id":0,"value":147},"start":15771,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":158}},"image_offsets":[]},{"id":{"replica_id":0,"value":148},"start":17037,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":159}},"image_offsets":[]}],"summary":"Board Provider and Context Implementation for Linear App","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":14269},"icon":"File","label":"linear-app/client/src/components/Board/BoardProviders.tsx"},{"range":{"start":14070,"end":14269},"icon":"ExclamationTriangle","label":"Diagnostics (linear-app/client/src/components/Board/BoardProviders.tsx): 1 errors"},{"range":{"start":14141,"end":14268},"icon":"XCircle","label":"A 'get' accessor must return a value."}]}