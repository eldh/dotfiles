{"id":"2ed8eb95-94b5-4b4e-96c6-d8da06a82743","zed":"context","version":"0.4.0","text":"```tsx linear-app/client/src/views/Team/components/Insights/components/InsightControls.tsx\nimport { z } from \"zod\";\n\nimport { action, computed, makeObservable, observable, reaction } from \"mobx\";\nimport type { History } from \"history\";\nimport { DateAggregation, DimensionName, InsightsColorScale, MeasureName } from \"@linear/common/insights/types\";\nimport { EstimationType } from \"@linear/common/models/EstimationType\";\nimport { notReachable } from \"@linear/orbiter/errors/UnreachableCaseError\";\nimport type { InsightPreferencesValues } from \"@linear/common/insights/InsightPreferencesValues\";\nimport { ViewType } from \"@linear/common/views/ViewType\";\nimport type { Organization } from \"~/models/Organization\";\nimport type { Team } from \"~/models/Team\";\nimport type { ViewPreferences } from \"~/models/ViewPreferences\";\nimport { ClientStorage } from \"~/utils/ClientStorage\";\nimport { SearchParam, removeQueryAndLocationState } from \"~/utils/urls\";\nimport { Insights } from \"../Insights\";\n\nexport class InsightControls {\n  public key: string;\n  public estimationType: EstimationType;\n  public retries: number;\n  public fullscreen: boolean;\n\n  private persistanceKey: string;\n  public viewPreferences: ViewPreferences;\n\n  // While fetching a new insight, we still want to show the previous one with the color scale it was using,\n  // but we also want to correctly update ViewPreferences with the proper color scale for the next insight.\n  // This `_colorScale` will serve as a temporary color while loading so that the previous insight doesn't flash.\n  public _colorScale: InsightsColorScale;\n\n  // API\n  public dispose: () => void;\n\n  public constructor(props: {\n    view: Insights.View;\n    viewPreferences: ViewPreferences;\n    organization: Organization;\n    teams: Team[];\n    searchParam: Object | undefined;\n    history: History;\n  }) {\n    const { view, searchParam, history } = props;\n\n    this.key = props.viewPreferences.id;\n    this.persistanceKey = Insights.View.getPersistanceKey(view);\n    this.viewPreferences = props.viewPreferences;\n    this.estimationType = getEstimationType(props.teams);\n    this.retries = 0;\n\n    let restoredFromSearch = false;\n\n    if (searchParam) {\n      const parsed = insightSearchParamSchema.safeParse(searchParam);\n      if (parsed.success) {\n        this.fromSearchParam(parsed.data);\n        restoredFromSearch = true;\n      } else {\n        this.restore(history, view, props.teams);\n      }\n    } else {\n      this.restore(history, view, props.teams);\n    }\n\n    this._colorScale = this.viewPreferences.getInsightPreference(\"colorScale\");\n\n    const fixes: Partial<InsightPreferencesValues> = {};\n\n    const possibleMeasures = Insights.getPossibleMeasures(props.teams);\n    if (!possibleMeasures.includes(this.measure)) {\n      fixes.measure = possibleMeasures[0];\n    }\n\n    const possibleDimensions = Insights.getPossibleDimensions(\n      props.organization,\n      props.teams,\n      this.estimationType,\n      view,\n      this.measure\n    );\n    if (!possibleDimensions.includes(this.dimension)) {\n      fixes.dimension = possibleDimensions[0];\n      fixes.subDimension = undefined;\n    }\n\n    if (this.segment !== undefined) {\n      const possibleSegments = Insights.getSegmentsForDimension(this.dimension, possibleDimensions);\n      if (!possibleSegments.includes(this.segment)) {\n        fixes.segment = undefined;\n      }\n    }\n\n    if (Object.keys(fixes).length > 0) {\n      this.updateAndSave(fixes, !restoredFromSearch && this.viewPreferences.persisted);\n    }\n\n    makeObservable(this, {\n      _colorScale: observable,\n      retries: observable,\n      fullscreen: observable,\n      insightHash: computed,\n      openFullscreen: action,\n      closeFullscreen: action,\n      retry: action,\n      alignColorScale: action,\n    });\n\n    const disposeFullscreen = reaction(\n      () => this.fullscreen,\n      fullscreen => {\n        const location = history.location;\n        history.replace({\n          ...location,\n          state: {\n            ...location.state,\n            insightsFullscreen: fullscreen,\n          },\n        });\n      }\n    );\n\n    const disposeSearch = reaction(\n      () => this.toSearchParam(),\n      () => {\n        // Any update on something impacting the search param should clear it\n        removeQueryAndLocationState(props.history, [SearchParam.insights]);\n      }\n    );\n\n    this.dispose = function () {\n      disposeFullscreen();\n      disposeSearch();\n    };\n  }\n\n  public updateAndSave(preferences: Partial<InsightPreferencesValues>, save: boolean = true) {\n    let resetColorScale = false;\n\n    if (this.viewPreferences.getInsightPreference(\"colorScale\") !== InsightsColorScale.default) {\n      // Check if we should reset automatically the color scale to default\n      const currentDimension = this.viewPreferences.getInsightPreference(\"dimension\");\n      const currentSegment = this.viewPreferences.getInsightPreference(\"segment\");\n      const nextDimension = preferences.dimension ?? currentDimension;\n      const nextSegment = preferences.hasOwnProperty(\"segment\") ? preferences.segment : currentSegment;\n      resetColorScale = shouldResetColorScale({ currentDimension, currentSegment, nextDimension, nextSegment });\n    }\n\n    if (resetColorScale) {\n      this.viewPreferences.updateInsights({ ...preferences, colorScale: InsightsColorScale.default });\n    } else {\n      this.viewPreferences.updateInsights(preferences);\n    }\n\n    if (save && this.viewPreferences.viewType !== ViewType.quickView) {\n      this.viewPreferences.save(true);\n    }\n  }\n\n  // Warning: not all properties need a setter, the main ones (measure, dimension, segment, ...) should be updated all at once\n  public get measure(): MeasureName {\n    return this.viewPreferences.getInsightPreference(\"measure\");\n  }\n\n  public get dimension(): DimensionName {\n    return this.viewPreferences.getInsightPreference(\"dimension\");\n  }\n\n  public get subDimension(): string | undefined {\n    return this.viewPreferences.getInsightPreference(\"subDimension\");\n  }\n\n  public get dimensionDateAggregation(): DateAggregation {\n    return this.viewPreferences.getInsightPreference(\"dimensionDateAggregation\");\n  }\n\n  public set dimensionDateAggregation(value) {\n    this.viewPreferences.setAndSaveInsightPreference(\"dimensionDateAggregation\", value);\n  }\n\n  public get segment(): DimensionName | undefined {\n    return this.viewPreferences.getInsightPreference(\"segment\");\n  }\n\n  public get subSegment(): string | undefined {\n    return this.viewPreferences.getInsightPreference(\"subSegment\");\n  }\n\n  public get includeArchived(): boolean {\n    return this.viewPreferences.getInsightPreference(\"includeArchived\");\n  }\n\n  public set includeArchived(value) {\n    this.viewPreferences.setAndSaveInsightPreference(\"includeArchived\", value);\n  }\n\n  public get hideEmptyDimension(): boolean {\n    return this.viewPreferences.getInsightPreference(\"hideEmptyDimension\");\n  }\n\n  public set hideEmptyDimension(value) {\n    this.viewPreferences.setAndSaveInsightPreference(\"hideEmptyDimension\", value);\n  }\n\n  public get hideEmptySegment(): boolean {\n    return this.viewPreferences.getInsightPreference(\"hideEmptySegment\");\n  }\n\n  public set hideEmptySegment(value) {\n    this.viewPreferences.setAndSaveInsightPreference(\"hideEmptySegment\", value);\n  }\n\n  public get colorScale(): InsightsColorScale {\n    // See comment above on why this is not using the ViewPreferences\n    return this._colorScale;\n  }\n\n  public set colorScale(value) {\n    this.viewPreferences.setAndSaveInsightPreference(\"colorScale\", value);\n  }\n\n  public alignColorScale() {\n    this._colorScale = this.viewPreferences.getInsightPreference(\"colorScale\");\n  }\n\n  public openFullscreen() {\n    this.fullscreen = true;\n  }\n\n  public closeFullscreen() {\n    this.fullscreen = false;\n  }\n\n  public retry() {\n    ++this.retries;\n  }\n\n  public get insightHash(): string {\n    const currentInsight = this.viewPreferences.currentInsight;\n\n    return [\n      currentInsight.measure,\n      currentInsight.dimension,\n      currentInsight.subDimension ?? \"\",\n      currentInsight.dimensionDateAggregation ?? \"\",\n      currentInsight.segment ?? \"\",\n      currentInsight.subSegment ?? \"\",\n      currentInsight.includeArchived ? \"archived\" : \"\",\n    ].join(\"_\");\n  }\n\n  public fromSearchParam(values: InsightsShareConfig) {\n    this.viewPreferences.setInsights({\n      measure: values.m,\n      dimension: values.d,\n      subDimension: values.sd ?? undefined,\n      segment: values.s ?? undefined,\n      subSegment: values.ss ?? undefined,\n      dimensionDateAggregation: values.dateAgg ?? undefined,\n      includeArchived: values.archive ?? false,\n      hideEmptyDimension: values.emptyDim ?? false,\n      hideEmptySegment: values.emptySeg ?? false,\n    });\n\n    this.fullscreen = values.fullscreen ?? false;\n  }\n\n  public toSearchParam(): InsightsShareConfig {\n    return {\n      m: this.measure,\n      d: this.dimension,\n      sd: this.subDimension,\n      s: this.segment,\n      ss: this.subSegment,\n      fullscreen: this.fullscreen ? true : undefined,\n      archive: this.includeArchived ? true : undefined,\n      emptyDim: this.hideEmptyDimension ? true : undefined,\n      emptySeg: this.hideEmptySegment ? true : undefined,\n      dateAgg: this.dimensionDateAggregation,\n    };\n  }\n\n  public toSettings(): Insights.Settings {\n    return {\n      measure: this.measure,\n      dimension: this.dimension,\n      subDimension: this.subDimension,\n      dimensionDateAggregation: this.dimensionDateAggregation,\n      segment: this.segment,\n      subSegment: this.subSegment,\n      estimationType: this.estimationType,\n      includeArchived: this.includeArchived,\n    };\n  }\n\n  private restore(history: History, view: Insights.View, teams: Team[]) {\n    this.fullscreen = Boolean(history.location.state?.insightsFullscreen);\n\n    if (this.viewPreferences.insights == null) {\n      const saved = ClientStorage.get(this.persistanceKey);\n      if (saved != null) {\n        // Migrating locally stored insights to view preferences\n        const parsed = insightStorageSchema.safeParse(saved);\n        if (parsed.success) {\n          this.viewPreferences.setInsights({\n            measure: parsed.data.measure,\n            dimension: parsed.data.dimension,\n            subDimension: parsed.data.subDimension ?? undefined,\n            dimensionDateAggregation: parsed.data.dimensionDateAggregation ?? undefined,\n            segment: parsed.data.segment ?? undefined,\n            subSegment: parsed.data.subSegment ?? undefined,\n            includeArchived: parsed.data.includeArchived ?? undefined,\n            hideEmptyDimension: parsed.data.hideEmptyDimension ?? undefined,\n            hideEmptySegment: parsed.data.hideEmptySegment ?? undefined,\n          });\n          void this.viewPreferences\n            .save(true)\n            .result()\n            .then(() => {\n              ClientStorage.remove(this.persistanceKey);\n            });\n        }\n      }\n    } else {\n      ClientStorage.remove(this.persistanceKey);\n    }\n\n    if (this.viewPreferences.insights == null && this.viewPreferences?.organizationViewPreferences?.insights == null) {\n      // Try to map grouping / ordering from the view preferences to the Insights\n      const groupingDimension = issueGroupingToDimension(teams, this.viewPreferences);\n\n      this.viewPreferences.setInsights({\n        measure: MeasureName.id,\n        dimension: groupingDimension?.dimension ?? DimensionName.stateName,\n        subDimension: groupingDimension?.subDimension,\n        dimensionDateAggregation: undefined,\n        segment: issueViewOrderingToDimension(this.viewPreferences),\n        subSegment: undefined,\n        includeArchived: includeArchivedByDefault(view),\n        hideEmptyDimension: false,\n        hideEmptySegment: false,\n        colorScale: InsightsColorScale.default,\n      });\n    }\n  }\n}\n\nconst insightStorageSchema = z.object({\n  measure: z.nativeEnum(MeasureName),\n  dimension: z.nativeEnum(DimensionName),\n  subDimension: z.string().nullish(),\n  dimensionDateAggregation: z.nativeEnum(DateAggregation).nullish(),\n  segment: z.nativeEnum(DimensionName).nullish(),\n  subSegment: z.string().nullish(),\n  includeArchived: z.boolean().nullish(),\n  hideEmptyDimension: z.boolean().nullish(),\n  hideEmptySegment: z.boolean().nullish(),\n});\n\nconst insightSearchParamSchema = z.object({\n  m: z.nativeEnum(MeasureName),\n  d: z.nativeEnum(DimensionName),\n  sd: z.string().nullish(),\n  dateAgg: z.nativeEnum(DateAggregation).nullish(),\n  s: z.nativeEnum(DimensionName).nullish(),\n  ss: z.string().nullish(),\n  fullscreen: z.boolean().nullish(),\n  archive: z.boolean().nullish(),\n  emptyDim: z.boolean().nullish(),\n  emptySeg: z.boolean().nullish(),\n});\n\n/* Condensed insights config used to pass via search params or location state */\nexport type InsightsShareConfig = z.infer<typeof insightSearchParamSchema>;\n\nfunction getEstimationType(teams: Team[]): EstimationType {\n  const estimates = new Set(\n    teams.map(team => (team.estimationEnabled ? team.issueEstimationType : EstimationType.notUsed))\n  );\n\n  if (estimates.size === 1) {\n    return Array.from(estimates)[0];\n  } else {\n    return EstimationType.fibonacci;\n  }\n}\n\nfunction issueGroupingToDimension(\n  teams: Team[],\n  viewPreferences: ViewPreferences\n): { dimension: DimensionName; subDimension?: string } | undefined {\n  const grouping = viewPreferences.getPreference(\"issueGrouping\");\n  if (grouping == null) {\n    return undefined;\n  }\n\n  switch (grouping) {\n    case \"priority\":\n      return { dimension: DimensionName.priority };\n    case \"assignee\":\n      return { dimension: DimensionName.assignee };\n    case \"cycle\":\n      return { dimension: DimensionName.cycle };\n    case \"team\":\n      return { dimension: DimensionName.team };\n    case \"workflowState\":\n      return { dimension: DimensionName.stateName };\n    case \"label\":\n      return { dimension: DimensionName.label };\n    case \"labelGroup\": {\n      const labelGroup = viewPreferences.getLabelGroupOrFallback(teams);\n      if (labelGroup) {\n        return {\n          dimension: DimensionName.labelGroup,\n          subDimension: labelGroup.id,\n        };\n      } else {\n        return undefined;\n      }\n    }\n    case \"project\":\n      return { dimension: DimensionName.project };\n    case \"sla\":\n      return { dimension: DimensionName.sla };\n    case \"projectMilestone\":\n      return { dimension: DimensionName.projectMilestone };\n    case \"focus\":\n    case \"activityDate\":\n    case \"rootIssue\":\n    case \"none\":\n      return undefined;\n\n    default:\n      throw notReachable(grouping);\n  }\n}\n\nfunction issueViewOrderingToDimension(viewPreferences: ViewPreferences): DimensionName | undefined {\n  const ordering = viewPreferences.getPreference(\"viewOrdering\");\n  if (ordering == null) {\n    return undefined;\n  }\n\n  switch (ordering) {\n    case \"priority\":\n      return DimensionName.priority;\n    case \"dateCreated\":\n      return DimensionName.createdAt;\n    case \"dueDate\":\n      return DimensionName.dueDate;\n    case \"estimate\":\n      return DimensionName.estimate;\n    case \"workflowState\":\n      return DimensionName.stateName;\n    case \"dateUpdated\":\n    case \"dateMyActivity\":\n    case \"title\":\n    case \"linkCount\":\n    case \"manual\":\n    case \"assignee\":\n    case \"feedbackCount\":\n      return undefined;\n\n    default:\n      throw notReachable(ordering);\n  }\n}\n\nfunction shouldResetColorScale(props: {\n  currentDimension: DimensionName;\n  nextDimension: DimensionName;\n  currentSegment: DimensionName | undefined;\n  nextSegment: DimensionName | undefined;\n}) {\n  if (props.nextSegment !== props.currentSegment) {\n    // When changing segmentation, always reset colors\n    return true;\n  } else if (props.nextSegment == null && props.nextDimension !== props.currentDimension) {\n    // if segmentation is already selected, and dimension is changed, preserve next colors\n    // if no segmentation is selected, and dimension is changed, reset colors\n\n    const isDate = Insights.isDateDimension(props.nextDimension);\n    const wasDate = Insights.isDateDimension(props.currentDimension);\n\n    const isUser = Insights.isUserDimension(props.nextDimension);\n    const wasUser = Insights.isUserDimension(props.currentDimension);\n\n    if (isDate && wasDate) {\n      // Same kind of dimension, keep the color\n    } else if (isUser && wasUser) {\n      // Same kind of dimension, keep the color\n    } else {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction includeArchivedByDefault(view: Insights.View) {\n  switch (view.type) {\n    case \"issue\":\n      return false;\n    case \"project\":\n      return view.project.isArchived;\n    case \"cycle\":\n      return view.cycle.isArchived;\n    case \"customView\":\n      return view.customView.isArchived;\n    case \"label\":\n      return false;\n    case \"user\":\n      return false;\n    case \"my-issues\":\n      return false;\n    default:\n      throw notReachable(view);\n  }\n}\n```\n\nconvert InsightsShareConfig to a plain ts type\n\nHere's the InsightsShareConfig converted to a plain TypeScript type:\n\n```typescript\ntype InsightsShareConfig = {\n  m: MeasureName;\n  d: DimensionName;\n  sd?: string | null;\n  dateAgg?: DateAggregation | null;\n  s?: DimensionName | null;\n  ss?: string | null;\n  fullscreen?: boolean | null;\n  archive?: boolean | null;\n  emptyDim?: boolean | null;\n  emptySeg?: boolean | null;\n};\n```\n\nThis type definition includes all the properties from the Zod schema, with their corresponding types. The optional properties are marked with `?`, and the nullable properties are represented as unions with `| null`.\n\nNote that this plain TypeScript type does not include the validation logic that the Zod schema provides. If you need runtime validation, you'll still want to use the Zod schema.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":624}}},{"id":{"replica_id":0,"value":291},"start":16961,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":625}}},{"id":{"replica_id":0,"value":292},"start":17740,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":626}}}],"summary":"Title: Conversion of Zod-inferred Types to Plain TypeScript Interfaces","slash_command_output_sections":[{"range":{"start":0,"end":16912},"icon":"File","label":"linear-app/client/src/views/Team/components/Insights/components/InsightControls.tsx","metadata":{"path":"linear-app/client/src/views/Team/components/Insights/components/InsightControls.tsx"}}]}