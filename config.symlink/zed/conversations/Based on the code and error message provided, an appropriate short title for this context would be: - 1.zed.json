{"id":"b7e54688-706f-4cee-9639-29da9ec0bf8d","zed":"context","version":"0.4.0","text":"\n\n\ngenerate the interface for childCOmpopnent props\nTo generate an interface for the props of a ChildComponent in TypeScript, you would typically define an interface that describes the structure of the props object. Here's a generic example of how you might do this:\n\n```typescript\ninterface ChildComponentProps {\n  // Define your prop types here\n  name: string;\n  age: number;\n  isStudent?: boolean;\n  onButtonClick: () => void;\n  items: string[];\n}\n\n// Then use it with your component like this:\nconst ChildComponent: React.FC<ChildComponentProps> = (props) => {\n  // Component logic here\n};\n```\n```tsx linear-app/client/src/components/List/components/ListCellNew.tsx\nimport * as React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport { useAsRef } from \"@linear/orbiter/hooks/useAsRef\";\nimport { useNavigationFocusKeyboardActive } from \"@linear/orbiter/hooks/useNavigationFocusKeyboardActive\";\nimport { useGroupedViewDataContext } from \"@linear/orbiter/components/GroupedView/GroupedViewDataContext\";\nimport type { GroupedViewItem } from \"@linear/orbiter/components/GroupedView/GroupedViewTypes\";\nimport { useIsKeyPressedRef } from \"~/hooks/useIsKeyPressedRef\";\nimport { useIsSplitView } from \"~/hooks/useIsSplitView\";\nimport type { ItemIndices } from \"~/hooks/selection/GroupedViewSelectionTypes\";\nimport type { AnyGroupedDataProvider } from \"./dataProviders/GroupedViewDataProvider\";\nimport { RowWrapper } from \"./RowWrappers\";\n\ntype Props = {\n  /** The GroupedViewItem to render */\n  item: GroupedViewItem<unknown>;\n  /** The legacy (pre-refactor) item indices. Will be removed when we have the new provider (if not before). */\n  legacyItem: ItemIndices;\n  style: React.CSSProperties;\n  /** The component to render as a child */\n  childComponent: React.ComponentType<unknown>;\n};\n\n/**\n * Renders List items with appropriate component and styling for GroupedList.\n */\nexport const ListCell = observer(function ListCell_(props: Props) {\n  const { provider, state } = useGroupedViewDataContext<AnyGroupedDataProvider>();\n  const {\n    item: { key },\n  } = props;\n  const $isSelected = React.useMemo(\n    () => state.selectedItems.some(item => item === key),\n    [state.selectedItems.join(\"\")]\n  );\n\n  const $isActive = state.activeItem === key;\n  const $isKeyboardActive = Boolean($isActive) && state.keyboardActive;\n  const $isFocused = state.focusedItem === key;\n  const selectedItemsRef = useAsRef(state.selectedItems);\n\n  const result = React.useMemo(() => {\n    return (\n      <ListCellComponent\n        $isSelected={$isSelected}\n        $isActive={$isActive}\n        $isKeyboardActive={$isKeyboardActive}\n        $isFocused={$isFocused}\n        onFocus={() => state.focus(key)}\n        onClick={() => {\n          // TODO implement\n        }}\n        item={props.item}\n        // onContextMenuCapture={onContextMenuCapture}\n        onSelect={() => state.cmdSelect(key)}\n        onSelectAllInGroup={() => {\n          // TODO implement\n        }}\n        onHover={() => {\n          if (key !== state.activeItem) {\n            state.activate({ item: key, keyboardActive: false });\n          }\n        }}\n        provider={provider}\n        selectedItemsRef={selectedItemsRef}\n        style={props.style}\n        legacyItem={props.legacyItem}\n        childComponent={props.childComponent}\n      />\n    );\n  }, [\n    provider,\n    props.legacyItem,\n    props.childComponent,\n    $isActive,\n    $isKeyboardActive,\n    $isFocused,\n    selectedItemsRef,\n    $isSelected,\n  ]);\n  return result;\n});\n\ninterface PropsAndProvider {\n  item: GroupedViewItem<unknown>;\n  legacyItem: ItemIndices;\n  style: React.CSSProperties;\n  provider: AnyGroupedDataProvider;\n  $isActive: boolean;\n  $isKeyboardActive: boolean;\n  $isFocused: boolean;\n  $isSelected: boolean;\n  selectedItemsRef: React.MutableRefObject<string[]>;\n  onClick(event: React.MouseEvent<HTMLElement>, key: string): void;\n  onSelect(key: string, addToSelection?: boolean): void;\n  onSelectAllInGroup(groupIndex: number): void;\n  onFocus(key: string): void;\n  onHover?(key: string): void;\n  onContextMenuCapture?(key: string): void;\n  withLongPress?: boolean;\n  childComponent: React.ComponentType<unknown>;\n}\n/**\n * Handles most of the rendering logic for the row\n */\nconst ListCellComponent = observer(function ListCellComponent_(props: PropsAndProvider) {\n  const {\n    item,\n    legacyItem,\n    style,\n    onClick,\n    onSelect,\n    onHover,\n    onFocus,\n    onContextMenuCapture,\n    provider,\n    $isActive,\n    $isKeyboardActive,\n    $isSelected,\n    selectedItemsRef,\n    childComponent: ChildComponent,\n  } = props;\n  const { key } = item;\n  const ref = React.useRef<HTMLElement>(null);\n  const isSplitView = useIsSplitView();\n\n  useNavigationFocusKeyboardActive(ref, $isKeyboardActive);\n\n  const onMouseMove = React.useMemo(\n    () =>\n      onHover\n        ? (e: React.MouseEvent) => {\n            if (e.metaKey && e.movementY === 0 && e.movementX === 0) {\n              // Handle Safari bug where onMouseMove would trigger on cmd click. In this case don't trigger the callback.\n              return;\n            }\n            onHover(key);\n          }\n        : undefined,\n    [onHover, key]\n  );\n\n  const handleClick = React.useCallback(\n    (event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n      onClick(event, key);\n      provider.handleNavigateToItem?.(legacyItem);\n    },\n    [onClick, provider, key]\n  );\n\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent<HTMLElement>) => {\n      if (event.key === \"Enter\") {\n        // On split views navigation is done as soon as item is active, so enter should be a noop Allowing it to\n        // actually trigger might result in duplicate breadcrumbs as the native link navigation would also trigger\n        if (isSplitView) {\n          return;\n        }\n\n        // Already handled by useGroupedViewSelection to open selection\n        // in new tabs, both on desktop app and browser\n        if (event.metaKey) {\n          return;\n        }\n\n        // provider.handleNavigateToItem?.(item);\n      }\n    },\n    [provider, key, isSplitView]\n  );\n\n  const handleContextMenuCapture = React.useMemo(\n    () => (onContextMenuCapture ? () => onContextMenuCapture(key) : undefined),\n    [onContextMenuCapture, key]\n  );\n  let child = (\n    <ChildComponent\n      {...{\n        onSelect,\n        model: item.data,\n        isSelected: $isSelected,\n        isActive: $isActive,\n        isKeyboardActive: $isKeyboardActive,\n        viewPreferences: provider.viewPreferences,\n        provider,\n        item: legacyItem,\n        groupIndex: legacyItem.groupIndex,\n        items: item.subItems?.map(i => i.data) ?? [],\n      }}\n    />\n  );\n  const tabPressedRef = useIsKeyPressedRef(e => e.key === \"Tab\");\n\n  return React.useMemo(() => {\n    const pathname = provider.path(props.legacyItem);\n\n    const sharedProps = {\n      ref,\n      style,\n      $isSelected,\n      to: pathname ? (typeof pathname === \"string\" ? { pathname } : pathname) : undefined,\n      $isActive,\n      \"data-selected\": $isSelected,\n      \"data-active\": $isActive,\n      \"data-list-key\": item.key,\n      $isKeyboardActive,\n      onMouseMove,\n      onContextMenuCapture: handleContextMenuCapture,\n      onClick: handleClick,\n      onKeyDown: handleKeyDown,\n      tabIndex: item.interactive ? 0 : undefined,\n      onFocus: () => {\n        // `tabPressRef` is a hack to prevent onFocus handler from triggering on mouse press. Otherwise it would interfere with the click handler. We need the focus handler though for when user navigates to an item with keyboard.\n        tabPressedRef.current && onFocus(key);\n      },\n      children: child,\n    };\n\n    return <RowWrapper {...sharedProps} />;\n  }, [\n    provider,\n    onSelect,\n    onClick,\n    onContextMenuCapture,\n    selectedItemsRef.current,\n    provider.viewPreferences?.serializedSettings,\n    $isActive,\n    $isKeyboardActive,\n    $isSelected,\n    style,\n  ]);\n});\n```\ndiagnostics: linear-app/client/src/components/List/components/ListCellNew.tsx\n```tsx\n  );\n  let child = (\n    <ChildComponent\n// error: Type '{ onSelect: (key: string, addToSelection?: boolean | undefined) => void; model: unknown; isSelected: boolean; isActive: boolean; isKeyboardActive: boolean; viewPreferences: ViewPreferences | undefined; provider: AnyGroupedDataProvider; item: ItemIndices; groupIndex: number; items: unknown[]; }' has no properties in common with type 'IntrinsicAttributes'.\n      {...{\n        onSelect,\n```\n\ngenerate the interface for childCOmpopnent props\n\n\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":57}},"image_offsets":[]},{"id":{"replica_id":0,"value":19},"start":52,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":58}},"image_offsets":[]},{"id":{"replica_id":0,"value":54},"start":8521,"metadata":{"role":"assistant","status":{"Error":"cloud language model completion failed with status 400 Bad Request: messages: final assistant content cannot end with trailing whitespace"},"timestamp":{"replica_id":0,"value":59}},"image_offsets":[]},{"id":{"replica_id":0,"value":55},"start":8522,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":60}},"image_offsets":[]}],"summary":"Based on the code and error message provided, an appropriate short title for this context would be:","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":598,"end":8470},"icon":"File","label":"linear-app/client/src/components/List/components/ListCellNew.tsx"},{"range":{"start":7937,"end":8470},"icon":"ExclamationTriangle","label":"Diagnostics (linear-app/client/src/components/List/components/ListCellNew.tsx): 1 errors"},{"range":{"start":8015,"end":8469},"icon":"XCircle","label":"Type '{ onSelect: (key: string, addToSelection?: boolean | undefined) => void; model: unknown; isSelected: boolean; isActive: boolean; isKeyboardActive: boolean; viewPreferences: ViewPreferences | undefined; provider: AnyGroupedDataProvider; item: ItemIndices; groupIndex: number; items: unknown[]; }' has no properties in common with type 'IntrinsicAttributes'."}]}