{"id":"86661023-e317-44bc-b6e0-dd74fb7ed79f","zed":"context","version":"0.4.0","text":"\n\n\n```ts linear-app/client/src/models/collections/UniversalCollectionFilter.ts\nimport flatten from \"lodash/flatten\";\nimport { makeObservable, observable, runInAction } from \"mobx\";\nimport { cloneDeep } from \"lodash\";\nimport { type AllowedFilter, ModelMatcher } from \"@linear/common/filters/ModelMatcher\";\nimport { isFilterUsingLegacyDateInterval, patchLegacyDateFilter } from \"@linear/common/filters/DateFilterUtils\";\nimport { Logger } from \"~/logging/Logger\";\nimport { ClientStorage } from \"~/utils/ClientStorage\";\nimport type { FilterableModel, ModelFilter } from \"~/filters/FilterBlock\";\nimport { CollectionFilter } from \"./CollectionFilter\";\n\nconst PERSISTANCE_VERSION = 2;\n\n/**\n * A Filter that can be used to filter `Collections`, using their `filter` method.\n *\n * @param filter The filter to use.\n */\nexport class UniversalCollectionFilter<T extends FilterableModel> extends CollectionFilter<T> {\n  /** Constructor for universal collection filters */\n  public constructor(props: { filter?: ModelFilter<T>; persistanceKey?: string; storage?: \"session\" | \"local\" }) {\n    super();\n    const { filter, persistanceKey, storage = \"local\" } = props;\n    this.storage = storage;\n    if (persistanceKey) {\n      this.persistanceKey = `filter_${PERSISTANCE_VERSION}_${persistanceKey}`;\n      const map: ModelFilter<T> =\n        this.storage === \"local\"\n          ? ClientStorage.get(this.persistanceKey, { logError: false }) || ({} as ModelFilter<T>)\n          : ClientStorage.getSession(this.persistanceKey) || ({} as ModelFilter<T>);\n\n      const hasLegacyDateFilter = isFilterUsingLegacyDateInterval(map);\n      if (hasLegacyDateFilter) {\n        Logger.warning(\"Unexpected legacy date filter detected\");\n      }\n\n      this.filter = hasLegacyDateFilter ? patchLegacyDateFilter(map) : map;\n    }\n    if (filter) {\n      this.filter = filter;\n    }\n    makeObservable<this, \"_filter\">(this, {\n      _filter: observable,\n    });\n  }\n\n  /**\n   * Setter for the filter data used by this filter\n   */\n  public set filter(filter: ModelFilter<T>) {\n    runInAction(() => {\n      this._filter = filter;\n    });\n    if (this.persistanceKey) {\n      if (Object.keys(filter).length === 0) {\n        ClientStorage.remove(this.persistanceKey);\n        ClientStorage.removeSession(this.persistanceKey);\n      } else {\n        this.storage === \"local\"\n          ? ClientStorage.set(this.persistanceKey, filter)\n          : ClientStorage.setSession(this.persistanceKey, filter);\n      }\n    }\n  }\n\n  /**\n   * Getter for filter data used by this filter\n   */\n  public get filter(): ModelFilter<T> {\n    return this._filter;\n  }\n\n  /**\n   * Whether the filter is filtering. For this property to be true, there needs to be at least one registered filter.\n   */\n  public override get isFiltering() {\n    return this.filterCount > 0;\n  }\n\n  /**\n   * The number of filters currently applied by this filter.\n   */\n  public override get filterCount() {\n    return (this._filter.and ?? this._filter.or ?? Object.keys(this._filter)).length;\n  }\n\n  /**\n   * Reset filter.\n   */\n  public override reset() {\n    this.filter = {} as ModelFilter<T>;\n  }\n\n  /**\n   * Return the filter for the key, if there is one\n   * By default, it will return the value only if \"matching all filters\" is used\n   *\n   * @param key a key to check\n   * @param [matching=\"all\"] matching type\n   * @returns the matching filter if there is one\n   */\n  public matchingFilterForKey<K extends keyof ModelFilter<T>>(\n    key: K,\n    matching: \"all\" | \"any\" = \"all\"\n  ): ModelFilter<T>[K] | undefined {\n    const orFilters = (this.filter.or || []) as ModelFilter<T>[];\n    const andFilters = (this.filter.and || []) as ModelFilter<T>[];\n\n    if (matching === \"all\") {\n      if (this.filter[key]) {\n        return this.filter[key];\n      }\n\n      let result;\n\n      if (andFilters.length > 0) {\n        result = andFilters.find(subFilter => subFilter[key])?.[key] || undefined;\n      }\n\n      if (!result && orFilters.length === 1) {\n        result = orFilters[0][key];\n      }\n\n      return result;\n    }\n    // matching === \"any\"\n    else {\n      if (this.filter[key]) {\n        return this.filter[key];\n      }\n\n      return [...orFilters, ...andFilters].find(subFilter => subFilter[key])?.[key] || undefined;\n    }\n  }\n\n  /**\n   * Returns true when the filter is matching all filters\n   */\n  public get isMatchingAllFilters() {\n    return \"and\" in this.filter;\n  }\n\n  /**\n   * Returns true when the filter is matching any filters\n   */\n  public get isMatchingAnyFilters() {\n    return \"or\" in this.filter;\n  }\n\n  /**\n   *  Check if the provided key is the only filter\n   *\n   * @param key a key to check\n   * @returns boolean True if there’s a\n   */\n  public hasFilterOnlyForKey(key: string) {\n    const keys = UniversalCollectionFilter.filterKeys(this.filter);\n    return !(\"or\" in this.filter) && keys.length === 1 && keys.indexOf(key) === 0;\n  }\n\n  /**\n   * Recursively applies a filter to an element. You should not need to call this externally.\n   *\n   * @param filter The filter definition\n   * @param element The element to filter\n   * @param propPath The path to the prop for with the filter applies. Should generally not be supplied, as it’s only used for recursion purposes.\n   * @returns\n   */\n  public static filterElement<V extends FilterableModel>(filter: ModelFilter<V>, element: V): boolean {\n    return this.modelMatcher.matchElement(filter, element);\n  }\n\n  public override filterElement(element: T): boolean {\n    return UniversalCollectionFilter.modelMatcher.matchElement(this.filter, element);\n  }\n\n  /**\n   * Filter the given elements. This method is internally called whenever a FilteredCollection needs to compute\n   * its contents, you generally should not call this yourself.\n   *\n   * @param elements The elements to filter.\n   * @returns The filtered elements.\n   */\n  public override filterElements(elements: T[]): T[] {\n    try {\n      return super.filterElements(elements);\n    } catch (error) {\n      Logger.warning(\"Invalid filter \", {\n        filter: JSON.parse(JSON.stringify(this.filter)),\n        error,\n      });\n      return elements;\n    }\n  }\n\n  /**\n   * Inverse filter the given elements. This method is internally called whenever a FilteredCollection needs to compute\n   * its contents, you generally should not call this yourself.\n   *\n   * @param elements The elements to filter.\n   * @returns The filtered elements.\n   */\n  public override filterNotElements(elements: T[]): T[] {\n    try {\n      return super.filterNotElements(elements);\n    } catch (error) {\n      Logger.warning(\"Invalid filter \", {\n        filter: JSON.parse(JSON.stringify(this.filter)),\n        error,\n      });\n      return elements;\n    }\n  }\n\n  // -- Private interface\n  private optimizeFilter(filter: ModelFilter<T>): ModelFilter<T> {\n    if (\"and\" in filter && filter.and?.length === 1) {\n      return this.optimizeFilter(filter.and[0] as ModelFilter<T>);\n    } else if (\"or\" in filter && filter.or?.length === 1) {\n      return this.optimizeFilter(filter.or[0] as ModelFilter<T>);\n    } else {\n      mapObject(filter, (key, value) => [key, this.optimizeFilter(value)]);\n    }\n    return filter;\n  }\n\n  private static readonly modelMatcher = new ModelMatcher({\n    priority: function (this: ModelMatcher, filterKey: string, modelProperty: {}, value: AllowedFilter) {\n      // We need to special case priority on frontend, as the backend model just has priority as a simple number\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n      return this.matchElement(value, (modelProperty as any)?.[filterKey][filterKey]);\n    },\n  });\n  private _filter: ModelFilter<T> = {} as ModelFilter<T>;\n  private persistanceKey?: string;\n  private storage?: \"session\" | \"local\";\n\n  private static filterKeys<V extends FilterableModel>(filter: ModelFilter<V>): string[] {\n    const baseFilterKeys = [\"and\", \"or\"];\n\n    const baseFilters = [\n      ...flatten(filter.and?.map(f => UniversalCollectionFilter.filterKeys(f)) || []),\n      ...flatten(filter.or?.map(f => UniversalCollectionFilter.filterKeys(f)) || []),\n    ];\n\n    return [...Object.keys(filter).filter(k => baseFilterKeys.indexOf(k) === -1), ...baseFilters].distinct();\n  }\n}\n```\ndiagnostics: linear-app/client/src/models/collections/UniversalCollectionFilter.ts\n```typescript\n      return this.optimizeFilter(filter.or[0] as ModelFilter<T>);\n    } else {\n      mapObject(filter, (key, value) => [key, this.optimizeFilter(value)]);\n// error: Cannot find name 'mapObject'. Did you mean 'Object'?\n    }\n    return filter;\n```\n```typescript\n      return this.optimizeFilter(filter.or[0] as ModelFilter<T>);\n    } else {\n      mapObject(filter, (key, value) => [key, this.optimizeFilter(value)]);\n// error: Parameter 'key' implicitly has an 'any' type.\n    }\n    return filter;\n```\n```typescript\n      return this.optimizeFilter(filter.or[0] as ModelFilter<T>);\n    } else {\n      mapObject(filter, (key, value) => [key, this.optimizeFilter(value)]);\n// error: Parameter 'value' implicitly has an 'any' type.\n    }\n    return filter;\n```\n\nimplement the mapObject function. it should return an object with the same keys as the input object, but with the values transformed by the callback function.\n\nTo implement the `mapObject` function as requested, you can create a utility function that transforms the values of an object based on a provided callback. Here's an implementation that addresses the issues in the diagnostics:\n\n```typescript\n/**\n * Maps over an object's key-value pairs and returns a new object with transformed values.\n * @param obj The input object to map over\n * @param callback A function that takes a key and value and returns a new value\n * @returns A new object with the same keys but transformed values\n */\nfunction mapObject<T extends object, U>(\n  obj: T,\n  callback: (key: keyof T, value: T[keyof T]) => U\n): { [K in keyof T]: U } {\n  const result: Partial<{ [K in keyof T]: U }> = {};\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = callback(key, obj[key]);\n    }\n  }\n  return result as { [K in keyof T]: U };\n}\n```\n\nNow, you can use this `mapObject` function in your `optimizeFilter` method. Here's how you can modify the `optimizeFilter` method to use the new `mapObject` function:\n\n```typescript\nprivate optimizeFilter(filter: ModelFilter<T>): ModelFilter<T> {\n  if (\"and\" in filter && filter.and?.length === 1) {\n    return this.optimizeFilter(filter.and[0] as ModelFilter<T>);\n  } else if (\"or\" in filter && filter.or?.length === 1) {\n    return this.optimizeFilter(filter.or[0] as ModelFilter<T>);\n  } else {\n    return mapObject(filter, (key, value) => {\n      if (typeof value === 'object' && value !== null) {\n        return this.optimizeFilter(value as ModelFilter<T>);\n      }\n      return value;\n    });\n  }\n}\n```\n\nThis implementation addresses the following issues:\n\n1. It defines the `mapObject` function, resolving the \"Cannot find name 'mapObject'\" error.\n2. It properly types the parameters in the callback function, addressing the \"Parameter 'key' implicitly has an 'any' type\" and \"Parameter 'value' implicitly has an 'any' type\" errors.\n3. It handles the recursive optimization of nested filters.\n\nMake sure to place the `mapObject` function either in the same file or in a separate utility file that you import at the top of your `UniversalCollectionFilter.ts` file.\n\nThis implementation should resolve the diagnostics issues and provide the functionality you need for optimizing the filter object.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":31}},"image_offsets":[]},{"id":{"replica_id":0,"value":25},"start":9279,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":32}},"image_offsets":[]},{"id":{"replica_id":0,"value":26},"start":11585,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":33}},"image_offsets":[]}],"summary":"Universal Collection Filter Implementation","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":9118},"icon":"File","label":"linear-app/client/src/models/collections/UniversalCollectionFilter.ts"},{"range":{"start":8264,"end":9118},"icon":"ExclamationTriangle","label":"Diagnostics (linear-app/client/src/models/collections/UniversalCollectionFilter.ts): 3 errors"},{"range":{"start":8347,"end":8607},"icon":"XCircle","label":"Cannot find name 'mapObject'. Did you mean 'Object'?"},{"range":{"start":8608,"end":8861},"icon":"XCircle","label":"Parameter 'key' implicitly has an 'any' type."},{"range":{"start":8862,"end":9117},"icon":"XCircle","label":"Parameter 'value' implicitly has an 'any' type."}]}