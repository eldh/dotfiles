{"id":"dfff1bb1-1a0c-4405-b43c-8b252bdcbad8","zed":"context","version":"0.4.0","text":"\n\n\n```ts linear-app/orbiter/src/components/GroupedView/GroupedViewState.ts\nimport * as React from \"react\";\nimport { makeObservable, action as mobxAction, observable } from \"mobx\";\nimport { GroupedViewItemHelper } from \"./GroupedViewItemHelper\";\nimport type { GroupedViewItem, GroupedViewItemKey, PathToItem } from \"./GroupedViewTypes\";\n\ntype GroupedViewStateOptions = {\n  /** An item to set as initially active */\n  initialActiveItem?: GroupedViewItemKey;\n  /** Disable item selection, but not keyboard nav */\n  disableSelection?: boolean;\n};\n\n/** Hook to get a view state instance for the current data */\nexport function useGroupedViewState<T>(\n  data: GroupedViewItem<T>[],\n  options?: GroupedViewStateOptions,\n  deps: React.DependencyList = []\n) {\n  return React.useMemo(() => new GroupedViewState({ data, ...options }), deps);\n}\n\n/** Class to handle selected/active items in a grouped view. Contains the state and methods to manipulate the state. */\nexport class GroupedViewState<T = unknown> {\n  public constructor(options: GroupedViewStateOptions & { data: GroupedViewItem<T>[] }) {\n    this.selectionDisabled = options.disableSelection ?? false;\n    if (options.initialActiveItem) {\n      this.activeItem = options.initialActiveItem;\n    }\n    if (options.data) {\n      this.data = options.data;\n    }\n    makeObservable(this, {\n      moveActive: mobxAction,\n      activate: mobxAction,\n      addToSelection: mobxAction,\n      select: mobxAction,\n      selectBetween: mobxAction,\n      deactivate: mobxAction,\n      focus: mobxAction,\n      clearSelection: mobxAction,\n      shiftSelect: mobxAction,\n      cmdSelect: mobxAction,\n      selectAllSubItems: mobxAction,\n      selectAll: mobxAction,\n      goToEnd: mobxAction,\n      goToStart: mobxAction,\n      activateNextAvailableItem: mobxAction,\n      activeItem: observable,\n      focusedItem: observable,\n      keyboardActive: observable,\n      initialSelectedItem: observable,\n      selectedItems: observable,\n      selectedItemsKey: observable,\n      navigationDirection: observable,\n    });\n  }\n\n  /** The currently focused item key */\n  public focusedItem: GroupedViewItemKey | null = null;\n\n  /** The currently active item key */\n  public activeItem: GroupedViewItemKey | null = null;\n\n  /** The previously active item key */\n  public previouslyActiveItem: GroupedViewItemKey | null = null;\n\n  /** Indicates if the view is currently keyboard active */\n  public keyboardActive: boolean = false;\n\n  /** The initially selected item key */\n  public initialSelectedItem: GroupedViewItemKey | null = null;\n\n  /** Array of selected item keys */\n  public selectedItems: GroupedViewItemKey[] = [];\n\n  /** A string representation of selected items for quick comparison */\n  public selectedItemsKey = \"\";\n\n  /** The current navigation direction */\n  public navigationDirection: Direction = Direction.DownRight;\n\n  /** Is selection of items disabled */\n  public selectionDisabled = false;\n\n  /**\n   * Moves the active item in the specified direction\n   * @param direction The direction to move\n   * @param options Additional options for movement\n   */\n  public moveActive(\n    direction: Direction,\n    options: {\n      toEnd?: boolean;\n      shouldClearSelection?: boolean;\n    } = {}\n  ) {\n    this.navigationDirection = direction;\n    if (!this.activeItem) {\n      this.activeItem = this.firstItem();\n      return;\n    }\n\n    const newActiveItem = this.findNextItemByKey(this.activeItem, direction, options.toEnd);\n\n    if (newActiveItem) {\n      this.activeItem = newActiveItem;\n      this.keyboardActive = true;\n\n      if (options.shouldClearSelection) {\n        this.clearSelectedItems();\n      }\n    }\n  }\n\n  /**\n   * Activates a specific item\n   * @param payload Activation options\n   */\n  public activate(payload: {\n    item: GroupedViewItemKey;\n    keyboardActive: boolean;\n    shouldClearSelection?: boolean;\n    maintainDirection?: boolean; // TODO - implement this\n  }) {\n    this.activeItem = payload.item;\n    this.keyboardActive = payload.keyboardActive;\n    if (payload.shouldClearSelection) {\n      this.clearSelectedItems();\n    }\n  }\n\n  /**\n   * Checks if an item is selected\n   * @param itemKey The key of the item to check\n   * @returns True if the item is selected, false otherwise\n   */\n  public isSelected(itemKey: GroupedViewItemKey) {\n    if (this.selectionDisabled) {\n      return false;\n    }\n    return this.selectedItemsSet.has(itemKey);\n  }\n\n  /**\n   * Gets the selected elements, optionally transformed\n   * @param options Options for transforming the selected elements\n   * @returns An array of selected elements\n   */\n  public getSelectedElements<E = GroupedViewItem<T>>(options?: {\n    transform: (item: GroupedViewItem<T>) => E | undefined;\n  }): E[] {\n    const selectedElementsSet = new Set<E>();\n    const result: E[] = [];\n    const selectedItems = this.selectedItems;\n    const data = this.data;\n    const transform = options?.transform;\n\n    for (let i = 0, l = selectedItems.length; i < l; ++i) {\n      const itemKey = selectedItems[i];\n      let selectedItem: GroupedViewItem<T> | undefined;\n\n      GroupedViewItemHelper.traverse(data, item => {\n        if (item.key === itemKey) {\n          selectedItem = item;\n          return true;\n        } else {\n          return false;\n        }\n      });\n\n      if (selectedItem != null) {\n        const transformedItem: E | undefined = transform ? transform(selectedItem) : (selectedItem as E);\n        if (transformedItem != null && !selectedElementsSet.has(transformedItem)) {\n          result.push(transformedItem);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Adds to the current selection\n   * @param payload Options for adding to selection\n   */\n  public addToSelection(payload: { direction: Direction; selectActiveItemImmediately?: boolean }) {\n    if (!this.activeItem) {\n      return;\n    }\n    const { direction, selectActiveItemImmediately } = payload;\n    const shouldAlsoSelectNextItem = selectActiveItemImmediately || this.selectedItems.length > 0;\n\n    if (!this.isSelected(this.activeItem)) {\n      this.addSelectedItem(this.activeItem);\n    }\n    console.log(direction, this.activeItem, this.initialSelectedItem, this.selectedItems);\n\n    // Find the next item in the specified direction\n    const nextItem = this.findNextItemByKey(this.activeItem, direction);\n    this.keyboardActive = true;\n\n    if (nextItem && shouldAlsoSelectNextItem) {\n      // Move the active item to the next item\n      this.activeItem = nextItem;\n\n      // If the next item is not already selected, add it to the selection\n      if (!this.isSelected(nextItem)) {\n        this.addSelectedItem(nextItem);\n      } else if (nextItem !== this.initialSelectedItem) {\n        this.removeSelectedItem(nextItem);\n      }\n\n      // Update the focused item\n      this.focusedItem = nextItem;\n\n      // If there's no initial selected item, set it to the first selected item\n      if (!this.initialSelectedItem && this.selectedItems.length > 0) {\n        this.initialSelectedItem = this.selectedItems[0];\n      }\n    }\n  }\n\n  /**\n   * Selects specific items\n   * @param items Array of item keys to select\n   */\n  public select(items: GroupedViewItemKey[]) {\n    this.setSelectedItems(items);\n    this.initialSelectedItem = items[0];\n    if (items.length > 0) {\n      this.activeItem = items[0];\n      this.focusedItem = items[0];\n    }\n  }\n\n  /**\n   * Selects items between two specified items\n   * @param start The start item key\n   * @param end The end item key\n   */\n  public selectBetween([start, end]: [GroupedViewItemKey, GroupedViewItemKey]) {\n    this.previouslyActiveItem = null;\n    this.setSelectedItems(this.getItemsBetween(start, end));\n    this.activeItem = end;\n    this.focusedItem = end;\n    this.initialSelectedItem = start;\n  }\n\n  /**\n   * Deactivates the current active item\n   */\n  public deactivate() {\n    this.previouslyActiveItem = this.activeItem;\n    this.activeItem = null;\n    this.keyboardActive = false;\n  }\n\n  /**\n   * Focuses on a specific item\n   * @param item The item key to focus\n   */\n  public focus(item: GroupedViewItemKey) {\n    this.focusedItem = item;\n    this.activeItem = item;\n    this.keyboardActive = true;\n  }\n\n  /**\n   * Clears the current selection\n   */\n  public clearSelection() {\n    this.clearSelectedItems();\n    this.focusedItem = null;\n    this.initialSelectedItem = null;\n  }\n\n  /**\n   * Performs a shift-select operation, i.e. add all items between the previously selected and the provided\n   * item to the selection.\n   * @param item Optional item key to start the shift-select from. If not passed, the active item will be used.\n   */\n  public shiftSelect(item?: GroupedViewItemKey) {\n    const startShiftSelectItem = item ?? this.activeItem;\n    if (!startShiftSelectItem) {\n      return;\n    }\n\n    this.previouslyActiveItem = null;\n    this.activeItem = startShiftSelectItem;\n    this.focusedItem = startShiftSelectItem;\n\n    if (this.initialSelectedItem) {\n      this.setSelectedItems(this.getItemsBetween(startShiftSelectItem, this.initialSelectedItem));\n    } else {\n      this.setSelectedItems([startShiftSelectItem]);\n    }\n    this.initialSelectedItem = this.initialSelectedItem || startShiftSelectItem;\n  }\n\n  /**\n   * Performs a command-select operation, i.e. add to/remove the specific item from selection\n   * @param item Optional item key to command-select. If not passed, the active item will be used.\n   */\n  public cmdSelect(item?: GroupedViewItemKey) {\n    const startCmdSelectItem = item ?? this.activeItem;\n    if (!startCmdSelectItem || this.multiSelectDisabled) {\n      return;\n    }\n\n    let oldSelectedItems = this.selectedItems;\n    if (this.isSplitView && this.activeItem && !this.isSelected(this.activeItem)) {\n      // On a split view, we will consider the active item as selected\n      oldSelectedItems = [...oldSelectedItems, this.activeItem];\n    }\n\n    if (oldSelectedItems.includes(startCmdSelectItem)) {\n      const selectedItems = oldSelectedItems.filter(i => i !== startCmdSelectItem);\n      if (selectedItems.length > 0) {\n        this.focusedItem = selectedItems[selectedItems.length - 1];\n        this.setSelectedItems(selectedItems);\n      } else {\n        this.focusedItem = null;\n        this.initialSelectedItem = null;\n        this.clearSelectedItems();\n      }\n    } else {\n      this.activeItem = startCmdSelectItem;\n      this.focusedItem = startCmdSelectItem;\n      this.initialSelectedItem = startCmdSelectItem;\n      this.setSelectedItems([...oldSelectedItems, startCmdSelectItem]);\n    }\n  }\n  /**\n   * Selects all sub-items of a given root item\n   * @param root The root item key\n   */\n  public selectAllSubItems(root: GroupedViewItemKey) {\n    const rootItem = this.getItemForKey(root);\n    if (!rootItem?.subItems) {\n      return;\n    }\n\n    const allSubItemKeys: GroupedViewItemKey[] = [];\n    function collectKeys(items: GroupedViewItem<T>[]) {\n      for (const item of items) {\n        if (item.interactive) {\n          allSubItemKeys.push(item.key);\n        }\n        if (item.subItems) {\n          collectKeys(item.subItems);\n        }\n      }\n    }\n    collectKeys(rootItem.subItems);\n    this.setSelectedItems(allSubItemKeys);\n  }\n\n  /**\n   * Selects all items in the view\n   */\n  public selectAll() {\n    const allKeys: GroupedViewItemKey[] = [];\n    function collectKeys(items: GroupedViewItem<T>[]) {\n      for (const item of items) {\n        if (item.interactive) {\n          allKeys.push(item.key);\n        }\n        if (item.subItems) {\n          collectKeys(item.subItems);\n        }\n      }\n    }\n    collectKeys(this.data);\n    this.setSelectedItems(allKeys);\n    if (!this.activeItem) {\n      this.activeItem = allKeys[0];\n    }\n  }\n  /**\n   * Moves the active item to the end of the list\n   */\n  public goToEnd() {\n    this.activeItem = this.lastItem();\n    this.keyboardActive = true;\n  }\n\n  /**\n   * Moves the active item to the start of the list\n   */\n  public goToStart() {\n    this.activeItem = this.firstItem();\n    this.keyboardActive = true;\n  }\n\n  /**\n   * Gets the item for a specific key\n   * @param key The key of the item to retrieve\n   * @returns The item or null if not found\n   */\n  public getItemForKey(key: GroupedViewItemKey): GroupedViewItem<T> | null {\n    function findItem(items: GroupedViewItem<T>[]): GroupedViewItem<T> | null {\n      for (const item of items) {\n        if (item.key === key) {\n          return item;\n        }\n        if (item.subItems) {\n          const found = findItem(item.subItems);\n          if (found) {\n            return found;\n          }\n        }\n      }\n      return null;\n    }\n    return findItem(this.data);\n  }\n\n  /**\n   * Sets new data for the view\n   * @param data The new data to set\n   */\n  public setData(data: GroupedViewItem<T>[]) {\n    this.data = data;\n  }\n\n  /**\n   * Activates the next available item\n   * @param path The current path\n   * @param moveUpWithNavigationDirection Whether to move up based on navigation direction\n   */\n  public activateNextAvailableItem(path: PathToItem, moveUpWithNavigationDirection = false) {\n    let res = this.getItemForPath(path, true)?.key ?? null;\n    if (!res) {\n      const nextPath = this.findNextPath(path, Direction.DownRight, false, false);\n      res = (nextPath && this.getItemForPath(nextPath, true)?.key) ?? null;\n    }\n    if (!res || (moveUpWithNavigationDirection && this.navigationDirection === Direction.UpLeft)) {\n      const nextPath = this.findNextPath(path, Direction.UpLeft, false, false);\n      res = (nextPath && this.getItemForPath(nextPath, true)?.key) ?? null;\n    }\n    this.activeItem = res || this.firstItem();\n  }\n\n  /**\n   * Returns the item for a specific path\n   * @param path The path to the item.\n   * @param onlyInteractive If true, only returns interactive items. Default is false.\n   */\n  public getItemForPath(path: PathToItem, onlyInteractive: boolean): GroupedViewItem<T> | null {\n    return GroupedViewItemHelper.getItemForPath(this.data, path, onlyInteractive);\n  }\n\n  private findNextItemByKey(\n    currentKey: GroupedViewItemKey,\n    direction: Direction,\n    toEnd: boolean = false\n  ): GroupedViewItemKey | null {\n    const path = GroupedViewItemHelper.getPathForItem(this.data, currentKey);\n    const nextPath = path && this.findNextPath(path, direction, toEnd);\n    return (nextPath && this.getItemForPath(nextPath, true)?.key) || null;\n  }\n\n  private findNextPath(\n    currentPathToItem: PathToItem,\n    direction: Direction,\n    toEnd: boolean = false,\n    onlySiblings: boolean = false\n  ): PathToItem | null {\n    if (this.data.length === 0) {\n      return null;\n    }\n    const lastIndex = currentPathToItem.length - 1;\n    const parentPath = currentPathToItem.slice(0, -1);\n    const currentIndex = currentPathToItem[lastIndex];\n    const currentItem = this.getItemForPath(currentPathToItem, false);\n    if (!currentItem) {\n      if (currentPathToItem.length === 0 || Number.isNaN(currentIndex)) {\n        return null;\n      }\n      return this.findNextPath(\n        currentIndex >= 0\n          ? [...parentPath, currentIndex - 1]\n          : [...parentPath.slice(0, -1), parentPath[lastIndex - 1] + 1],\n        direction,\n        toEnd,\n        onlySiblings\n      );\n    }\n\n    if (toEnd) {\n      return direction === Direction.DownRight ? this.lastPath() : this.firstPath();\n    }\n\n    if (direction === Direction.DownRight) {\n      if (!onlySiblings) {\n        // Try to go to the first child of the current item\n        const firstChild = currentItem.subItems && this.firstPathInGroup(currentItem.subItems, currentPathToItem);\n\n        if (firstChild) {\n          return firstChild;\n        }\n      }\n      // Try to go to the next sibling\n      const [nextSiblingPath, nextSibling] = this.findNextSibling(currentPathToItem);\n      if (nextSibling) {\n        if (nextSibling.interactive) {\n          return nextSiblingPath;\n        } else {\n          return this.findNextPath(nextSiblingPath, direction);\n        }\n      }\n\n      // Go up and find the next available item\n      return this.findNextPath(parentPath, direction, toEnd, true);\n    } else {\n      if (currentIndex > 0) {\n        // Try to go to the previous sibling\n        const [previousSiblingPath, previousSibling] = this.findPreviousSibling(currentPathToItem);\n\n        if (previousSibling) {\n          if (previousSibling.interactive) {\n            return previousSiblingPath;\n          } else if (hasSomeInteractiveItem(previousSibling)) {\n            return this.findLastSubItem(previousSiblingPath);\n          } else {\n            return this.findNextPath(previousSiblingPath, direction);\n          }\n        }\n      }\n      const parentItem = this.getItemForPath(parentPath, false);\n\n      // If we're at the first child, go to the parent\n      if (parentItem?.interactive) {\n        return parentPath;\n      } else {\n        return parentPath.length > 0 ? this.findNextPath(parentPath, direction) : null;\n      }\n    }\n  }\n\n  private findNextSibling(path: PathToItem): [PathToItem, GroupedViewItem<T>] | [null, null] {\n    const parentPath = path.slice(0, -1);\n    const currentIndex = path[path.length - 1];\n    const nextSiblingPath = [...parentPath, currentIndex + 1];\n    const nextSibling = this.getItemForPath(nextSiblingPath, false);\n\n    if (nextSibling) {\n      return [nextSiblingPath, nextSibling];\n    }\n\n    return [null, null];\n  }\n\n  private findPreviousSibling(path: PathToItem): [PathToItem, GroupedViewItem<T>] | [null, null] {\n    const parentPath = path.slice(0, -1);\n    const currentIndex = path[path.length - 1];\n\n    if (currentIndex > 0) {\n      const previousSiblingPath = [...parentPath, currentIndex - 1];\n      const previousSibling = this.getItemForPath(previousSiblingPath, false);\n\n      if (previousSibling) {\n        return [previousSiblingPath, previousSibling];\n      }\n    }\n\n    return [null, null];\n  }\n\n  private findLastSubItem(path: PathToItem): PathToItem | null {\n    const item = this.getItemForPath(path, false);\n    if (item && item.subItems && item.subItems.length > 0) {\n      const lastInteractiveIndex = item.subItems.findLastIndex(hasSomeInteractiveItem);\n      return this.findLastSubItem([...path, lastInteractiveIndex]);\n    }\n    return item?.interactive ? path : null;\n  }\n\n  private firstItem(): GroupedViewItemKey | null {\n    const firstPath = this.firstPath();\n    return (firstPath && this.getItemForPath(firstPath, true)?.key) ?? null;\n  }\n\n  private firstPath() {\n    return this.firstPathInGroup(this.data);\n  }\n\n  private firstPathInGroup(items: GroupedViewItem<T>[], currentPath: PathToItem = []): PathToItem | null {\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      const path = [...currentPath, i];\n\n      // Check if the current item is interactive (not disabled)\n      if (item.interactive) {\n        return path;\n      }\n\n      // If the item has subitems, recursively search them\n      if (item.subItems && item.subItems.length > 0) {\n        const interactiveSubItem = this.firstPathInGroup(item.subItems, path);\n        if (interactiveSubItem) {\n          return interactiveSubItem;\n        }\n      }\n    }\n\n    // If no interactive item is found, return null\n    return null;\n  }\n\n  private lastItem(): GroupedViewItemKey | null {\n    const lastPath = this.lastPath();\n    return (lastPath && this.getItemForPath(lastPath, true)?.key) ?? null;\n  }\n\n  private lastPath() {\n    return this.lastItemInGroup(this.data);\n  }\n\n  private lastItemInGroup(items: GroupedViewItem<T>[], currentPath: PathToItem = []): PathToItem | null {\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n      const path = [...currentPath, i];\n\n      // If the item has subitems, recursively search them first\n      if (item.subItems && item.subItems.length > 0) {\n        const interactiveSubItem = this.lastItemInGroup(item.subItems, path);\n        if (interactiveSubItem) {\n          return interactiveSubItem;\n        }\n      }\n\n      // Check if the current item is interactive (not disabled)\n      if (item.interactive) {\n        return path;\n      }\n    }\n\n    // If no interactive item is found, return null\n    return null;\n  }\n\n  private getItemsBetween(startKey: GroupedViewItemKey, endKey: GroupedViewItemKey): GroupedViewItemKey[] {\n    const startPath = GroupedViewItemHelper.getPathForItem(this.data, startKey);\n    const endPath = GroupedViewItemHelper.getPathForItem(this.data, endKey);\n    return startPath && endPath\n      ? this.getPathsBetween(startPath, endPath).map(path => this.getItemForPath(path, true)!.key)\n      : [startKey];\n  }\n\n  private getPathsBetween(startPath_: PathToItem, endPath_: PathToItem): PathToItem[] {\n    const result: PathToItem[] = [];\n    let inRange = false;\n    const [startPath, endPath] = sortPaths([startPath_, endPath_]);\n    function traverse(currentItems: GroupedViewItem<T>[], currentPath: number[] = [], depth: number = 0) {\n      for (let i = 0; i < currentItems.length; i++) {\n        const item = currentItems[i];\n        const itemPath = [...currentPath, i];\n\n        // Check if we've reached the start or end path\n        if (pathIsEqual(itemPath, startPath)) {\n          inRange = true;\n        }\n\n        // If we're in range, add the item to the result\n        if (inRange && item.interactive) {\n          result.push(itemPath);\n        }\n\n        // If we've reached the end path, stop traversing\n        if (pathIsEqual(itemPath, endPath)) {\n          inRange = false;\n          return;\n        }\n\n        // Recursively traverse subItems if they exist\n        if (item.subItems && depth < Math.max(startPath.length, endPath.length)) {\n          traverse(item.subItems, itemPath, depth + 1);\n        }\n      }\n    }\n\n    traverse(this.data);\n    return sortPaths(result);\n  }\n\n  private clearSelectedItems() {\n    this.selectedItems = [];\n    this.selectedItemsSet.clear();\n    this.updateSelectedItemsKey();\n  }\n\n  private setSelectedItems(itemKeys: GroupedViewItemKey[]) {\n    this.selectedItems = itemKeys;\n    this.selectedItemsSet = new Set(itemKeys);\n    this.updateSelectedItemsKey();\n  }\n\n  private addSelectedItem(itemKey: GroupedViewItemKey) {\n    if (!this.isSelected(itemKey)) {\n      this.selectedItems.push(itemKey);\n      this.selectedItemsSet.add(itemKey);\n      this.updateSelectedItemsKey();\n    }\n  }\n\n  private updateSelectedItemsKey() {\n    this.selectedItemsKey = this.selectedItems.join(\"_\");\n  }\n\n  private multiSelectDisabled: boolean = false;\n  private isSplitView: boolean = false;\n  private data: GroupedViewItem<T>[] = [];\n  private selectedItemsSet: Set<GroupedViewItemKey> = new Set();\n}\n\n/** Direction of movement in a view */\nexport const Direction = {\n  UpLeft: \"up/left\",\n  DownRight: \"down/right\",\n} as const;\n\n/** Direction of movement in a view */\nexport type Direction = (typeof Direction)[keyof typeof Direction];\n\nfunction pathIsEqual(path1: PathToItem, path2: PathToItem): boolean {\n  return path1.length === path2.length && path1.every((v, i) => v === path2[i]);\n}\n\nfunction sortPaths(paths: PathToItem[]): PathToItem[] {\n  return paths.sort((a, b) => {\n    const minLength = Math.min(a.length, b.length);\n\n    for (let i = 0; i < minLength; i++) {\n      if (a[i] !== b[i]) {\n        return a[i] - b[i];\n      }\n    }\n\n    // If one path is a prefix of the other, the shorter one comes first\n    if (a.length !== b.length) {\n      return a.length - b.length;\n    }\n\n    // Paths are identical\n    return 0;\n  });\n}\n\nfunction hasSomeInteractiveItem<T>(item: GroupedViewItem<T>): boolean {\n  return Boolean(item.interactive || (item.subItems && item.subItems.some(hasSomeInteractiveItem)));\n}\n```\n\nimplement removeSelectedItem(itemKey)\n\nHere's the implementation of the `removeSelectedItem` method for the `GroupedViewState` class:\n\n```typescript\nprivate removeSelectedItem(itemKey: GroupedViewItemKey) {\n  const index = this.selectedItems.indexOf(itemKey);\n  if (index !== -1) {\n    this.selectedItems.splice(index, 1);\n    this.selectedItemsSet.delete(itemKey);\n    this.updateSelectedItemsKey();\n  }\n}\n```\n\nThis method does the following:\n\n1. It finds the index of the `itemKey` in the `selectedItems` array.\n2. If the item is found (index is not -1):\n   - It removes the item from the `selectedItems` array using `splice`.\n   - It removes the item from the `selectedItemsSet` using `delete`.\n   - It calls `updateSelectedItemsKey` to update the `selectedItemsKey` string.\n\nYou should add this method to the `GroupedViewState` class. Also, make sure to add it to the `makeObservable` call in the constructor if you want this method to be tracked by MobX:\n\n```typescript\nmakeObservable(this, {\n  // ... other observables and actions ...\n  removeSelectedItem: mobxAction,\n});\n```\n\nThis will ensure that when `removeSelectedItem` is called, it will trigger updates in any reactive contexts that depend on the selection state.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":283}}},{"id":{"replica_id":0,"value":42},"start":23626,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":284}}},{"id":{"replica_id":0,"value":55},"start":23665,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":285}}},{"id":{"replica_id":0,"value":56},"start":24854,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":286}}}],"summary":"Implement removeSelectedItem Method for GroupedViewState","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":23625},"icon":"File","label":"linear-app/orbiter/src/components/GroupedView/GroupedViewState.ts","metadata":{"path":"linear-app/orbiter/src/components/GroupedView/GroupedViewState.ts"}}]}