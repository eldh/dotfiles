{"id":"65d64c06-9f45-470d-b4fc-3e07a80f6c08","zed":"context","version":"0.4.0","text":"\n\n\n```tsx linear-app/client/src/routes/ScrollRestoration.tsx\nimport React, { useEffect, memo, useRef } from \"react\";\nimport { withRouter, type RouteComponentProps, useLocation } from \"react-router-dom\";\nimport type { Location } from \"history\";\nimport { usePrevious } from \"@linear/orbiter/hooks/react-use\";\n\nconst VIEW_ATTRIBUTE = \"data-restore-scroll-view\";\nconst DIRECTION_ATTRIBUTE = \"data-restore-scroll\";\n\ntype ScrollPosition = { x: number; y: number };\n\n/** Describes scroll restoration for a single element */\ntype ScrollItem = {\n  /** Value of the `data-restore-scroll-view` attribute */\n  id: string;\n  /** Value of restored scrolled position (x/y coordinates) */\n  scroll: ScrollPosition;\n};\n\ntype ScrollMap = Map<string, ScrollItem[]>;\n\ntype Props = RouteComponentProps & {\n  visitedRoutesMap: ScrollMap;\n};\n\n/**\n * A component that tracks the scroll position of the page / or container and restores it when the user navigates back.\n * Any element with the `data-restore-scroll-view` attribute set will automatically be restored to its previous scroll position\n * after a client-side navigation.\n * The view names passed as values of the data-restore-scroll-view attribute need to be unique per location pathname/state.\n * You can optionally specify the restoration direction if only one direction using data-restore-scroll should be restored.\n * Data for restoration can be accessed through the `useScrollRestoration` hook, e.g. when using virtual scrolling solutions.\n *\n * @example <div data-restore-scroll-view=\"some-view\" data-restore-scroll=\"horizontal\">\n */\nexport function ScrollRestoration(props: { children: React.ReactNode }) {\n  const visitedRoutesMap = useRef<ScrollMap>(new Map());\n  const location = useLocation();\n  const key = getKey(location);\n  const contextValue = React.useMemo(() => ({ restoredScrolls: visitedRoutesMap.current.get(key) ?? [] }), [key]);\n  return (\n    <>\n      <ScrollRestorationWithRouter visitedRoutesMap={visitedRoutesMap.current} />\n      <ScrollRestorationContext.Provider value={contextValue}>{props.children}</ScrollRestorationContext.Provider>\n    </>\n  );\n}\n\nconst ScrollRestorationWithRouter = withRouter(\n  memo(ScrollRestorationWithoutRouter, (prevProps, nextProps) => {\n    const { location: prevLocation, visitedRoutesMap } = prevProps;\n    const { location: nextLocation } = nextProps;\n\n    const key = getKey(prevLocation);\n\n    if (locationChanged(prevLocation, nextLocation)) {\n      const scrollItems = getScrollItems();\n\n      // Cache scroll positions for the current location\n      visitedRoutesMap.set(key, scrollItems);\n    }\n\n    return false;\n  })\n);\n\nfunction ScrollRestorationWithoutRouter({ history, visitedRoutesMap }: Props) {\n  const location = useLocation();\n  const prevLocation = usePrevious(location);\n  useEffect(() => {\n    if (locationChanged(prevLocation, location)) {\n      const key = getKey(location);\n      const scrollItems = visitedRoutesMap.get(key) ?? [];\n      restoreScroll(scrollItems);\n    }\n  }, [location, visitedRoutesMap]);\n\n  return null;\n}\n\n/** Restore scroll positions for all cached items. */\nconst restoreScroll = (items: ScrollItem[]) => {\n  window.requestAnimationFrame(() => {\n    // querySelector and scrollTo are separated into read/write steps to avoid layout thrashing\n    const elements = items.map(item => self.document.querySelector(`[${VIEW_ATTRIBUTE}=\"${item.id}\"]`));\n    items.forEach((item, i) => {\n      const element = elements[i];\n      const xScroll = item.scroll.x;\n      const yScroll = item.scroll.y;\n\n      if (!element) {\n        return;\n      }\n\n      if (element.getAttribute(DIRECTION_ATTRIBUTE) === \"horizontal\") {\n        element.scrollTo({ left: xScroll });\n      } else if (element.getAttribute(DIRECTION_ATTRIBUTE) === \"vertical\") {\n        element.scrollTo({ top: yScroll });\n      } else if (element.getAttribute(DIRECTION_ATTRIBUTE) !== \"none\") {\n        element.scrollTo({ left: xScroll, top: yScroll });\n      }\n    });\n  });\n};\n\n/** Collect scroll position from elements on the current page. */\nconst getScrollItems = (): ScrollItem[] => {\n  return Array.from(self.document.querySelectorAll(`[${VIEW_ATTRIBUTE}]`))\n    .map(element => {\n      const x = element.scrollLeft;\n      const y = element.scrollTop;\n      if (!x && !y) {\n        return undefined;\n      }\n      return {\n        id: element.getAttribute(VIEW_ATTRIBUTE) ?? \"\",\n        scroll: { x, y },\n      };\n    })\n    .concrete();\n};\n\nconst locationChanged = (prevLocation: Location, nextLocation: Location): boolean => {\n  return (\n    (nextLocation.pathname !== prevLocation.pathname ||\n      nextLocation.search !== prevLocation.search ||\n      nextLocation.state?.tabId !== prevLocation.state?.tabId) &&\n    nextLocation.hash === \"\"\n  );\n};\n\nconst getKey = (location: Location): string => {\n  const { pathname, state } = location;\n\n  // Serialize important parts of the location into the key. Order of the properties matter!\n  // We do not use `location.key`, as it only refers to a React Router navigation entry and is not stable\n  //\n  // We consider the tabId as part of the key, so that we can restore the scroll position for different tabs, but in\n  // some cases we don't have a tabId, so we default to first tab (which is different on web/electron).\n  return JSON.stringify({\n    pathname,\n    state: { ...state, tabId: state?.tabId !== undefined ? state.tabId : 0 },\n  });\n};\n\nconst ScrollRestorationContext = React.createContext<{\n  restoredScrolls: ScrollItem[];\n}>({ restoredScrolls: [] });\n\n/**\n * Exposes the scroll restoration values for the current route location. This can be useful\n * if the basic scroll restoration doesn't work (e.g. for some virtual scroll setups)\n */\nexport const useScrollRestoration = () => {\n  return React.useContext(ScrollRestorationContext);\n};\n```\ndiagnostics: linear-app/client/src/routes/ScrollRestoration.tsx\n```tsx\nimport React, { useEffect, memo, useRef } from \"react\";\nimport { withRouter, type RouteComponentProps, useLocation } from \"react-router-dom\";\n// error: Module '\"react-router-dom\"' has no exported member 'withRouter'.\nimport type { Location } from \"history\";\nimport { usePrevious } from \"@linear/orbiter/hooks/react-use\";\n```\n```tsx\nimport React, { useEffect, memo, useRef } from \"react\";\nimport { withRouter, type RouteComponentProps, useLocation } from \"react-router-dom\";\n// error: Module '\"react-router-dom\"' has no exported member 'RouteComponentProps'.\nimport type { Location } from \"history\";\nimport { usePrevious } from \"@linear/orbiter/hooks/react-use\";\n```\n```tsx\n  const prevLocation = usePrevious(location);\n  useEffect(() => {\n    if (locationChanged(prevLocation, location)) {\n// error: Argument of type 'Location<any> | undefined' is not assignable to parameter of type 'Location'.\n//          Type 'undefined' is not assignable to type 'Location<CustomHistoryState>'.\n      const key = getKey(location);\n      const scrollItems = visitedRoutesMap.get(key) ?? [];\n```\n\nrewrite this component to work with react-router 6\nCertainly! Here's a rewritten version of the ScrollRestoration component that works with React Router 6:\n\n```tsx\nimport React, { useEffect, memo, useRef, createContext, useContext } from \"react\";\nimport { useLocation, useNavigationType } from \"react-router-dom\";\nimport type { Location } from \"history\";\n\nconst VIEW_ATTRIBUTE = \"data-restore-scroll-view\";\nconst DIRECTION_ATTRIBUTE = \"data-restore-scroll\";\n\ntype ScrollPosition = { x: number; y: number };\n\ntype ScrollItem = {\n  id: string;\n  scroll: ScrollPosition;\n};\n\ntype ScrollMap = Map<string, ScrollItem[]>;\n\nconst ScrollRestorationContext = createContext<{\n  restoredScrolls: ScrollItem[];\n}>({ restoredScrolls: [] });\n\nexport function ScrollRestoration({ children }: { children: React.ReactNode }) {\n  const visitedRoutesMap = useRef<ScrollMap>(new Map());\n  const location = useLocation();\n  const navigationType = useNavigationType();\n  const prevLocation = useRef<Location>(location);\n\n  const key = getKey(location);\n  const contextValue = React.useMemo(() => ({ restoredScrolls: visitedRoutesMap.current.get(key) ?? [] }), [key]);\n\n  useEffect(() => {\n    if (locationChanged(prevLocation.current, location)) {\n      const scrollItems = getScrollItems();\n      visitedRoutesMap.current.set(getKey(prevLocation.current), scrollItems);\n\n      if (navigationType === 'POP') {\n        const key = getKey(location);\n        const scrollItems = visitedRoutesMap.current.get(key) ?? [];\n        restoreScroll(scrollItems);\n      }\n    }\n    prevLocation.current = location;\n  }, [location, navigationType]);\n\n  return (\n    <ScrollRestorationContext.Provider value={contextValue}>\n      {children}\n    </ScrollRestorationContext.Provider>\n  );\n}\n\nconst restoreScroll = (items: ScrollItem[]) => {\n  window.requestAnimationFrame(() => {\n    const elements = items.map(item => document.querySelector(`[${VIEW_ATTRIBUTE}=\"${item.id}\"]`));\n    items.forEach((item, i) => {\n      const element = elements[i];\n      const { x: xScroll, y: yScroll } = item.scroll;\n\n      if (!element) return;\n\n      if (element.getAttribute(DIRECTION_ATTRIBUTE) === \"horizontal\") {\n        element.scrollTo({ left: xScroll });\n      } else if (element.getAttribute(DIRECTION_ATTRIBUTE) === \"vertical\") {\n        element.scrollTo({ top: yScroll });\n      } else if (element.getAttribute(DIRECTION_ATTRIBUTE) !== \"none\") {\n        element.scrollTo({ left: xScroll, top: yScroll });\n      }\n    });\n  });\n};\n\nconst getScrollItems = (): ScrollItem[] => {\n  return Array.from(document.querySelectorAll(`[${VIEW_ATTRIBUTE}]`))\n    .map(element => {\n      const x = element.scrollLeft;\n      const y = element.scrollTop;\n      if (!x && !y) return undefined;\n      return {\n        id: element.getAttribute(VIEW_ATTRIBUTE) ?? \"\",\n        scroll: { x, y },\n      };\n    })\n    .filter((item): item is ScrollItem => item !== undefined);\n};\n\nconst locationChanged = (prevLocation: Location, nextLocation: Location): boolean => {\n  return (\n    (nextLocation.pathname !== prevLocation.pathname ||\n      nextLocation.search !== prevLocation.search ||\n      (nextLocation.state as any)?.tabId !== (prevLocation.state as any)?.tabId) &&\n    nextLocation.hash === \"\"\n  );\n};\n\nconst getKey = (location: Location): string => {\n  const { pathname, state } = location;\n  return JSON.stringify({\n    pathname,\n    state: { ...(state as any), tabId: (state as any)?.tabId !== undefined ? (state as any).tabId : 0 },\n  });\n};\n\nexport const useScrollRestoration = () => {\n  return useContext(ScrollRestorationContext);\n};\n```\n\nKey changes:\n\n1. Removed `withRouter` and `RouteComponentProps` as they're not used in React Router 6.\n2. Used `useNavigationType` to detect POP navigation (back/forward) instead of comparing locations.\n3. Simplified the component structure by merging `ScrollRestorationWithRouter` and `ScrollRestorationWithoutRouter` into a single `ScrollRestoration` component.\n4. Used `useRef` to keep track of the previous location instead of `usePrevious` hook.\n5. Adjusted type assertions for location state, as React Router 6 doesn't provide strong typing for location state out of the box.\n6. Replaced `self.document` with `document` for simplicity.\n7. Used `filter` instead of `concrete()` to remove undefined items from `getScrollItems` result.\n\nThis version should work with React Router 6 while maintaining the same functionality as the original component.\n```ts linear-app/client/src/hooks/usePromptOnNavigation.ts\nimport * as React from \"react\";\nimport { __RouterContext, useLocation, type StaticContext } from \"react-router\";\nimport type { RouteComponentProps } from \"react-router-dom\";\nimport type { Action, Location, TransitionPromptHook } from \"history\";\nimport { FileDownloadHelper } from \"~/helpers/FileHelper\";\nimport { Electron } from \"~/electron/Electron\";\nimport type { CustomHistoryState } from \"~/typings/custom-history-state\";\nimport { Signal } from \"~/utils/Signal\";\n\n/**\n * Prevents navigation by showing a prompt to the user. If the user accepts they will then navigate.\n *\n * If you want to allow certain navigation (like saving or cancelling a form) you can imperatively disable/enable the\n * prompt as needed. See example below.\n *\n * @example\n * <PromptOnNavigation when={someBooleanCheck} />\n *\n * @example\n * <PromptOnNavigation message=\"Do you want to leave this page?\" when={props => {\n *  return props.currentLocation.pathname === \"/some-path\" && props.nextLocation.pathname === \"/some-other-path\"\n *    && props.historyAction === \"POP\";\n * } />\n *\n * @example\n * const promptHandle = React.useRef<PromptOnNavigationHandle>(null);\n * const someAction = () => {\n *  promptHandle.current?.disable();\n *  // Perform action which triggers navigation, but no prompt will be shown\n * }\n * <PromptOnNavigation ref={promptHandle} />\n */\nexport const PromptOnNavigation = React.forwardRef((props: PromptOnNavigationProps, ref) => {\n  usePromptOnNavigation(props, ref);\n  return null;\n});\n\n/**\n * Prevents navigation by showing a prompt to the user. If the user accepts they will then navigate.\n *\n * @example\n * usePromptOnNavigation({when: someBooleanCheck});\n *\n * @example\n * usePromptOnNavigation({\n *   message: \"Do you want to leave this page?\",\n *   when: props => {\n *     return props.currentLocation.pathname === \"/some-path\" && props.nextLocation.pathname === \"/some-other-path\"\n *       && props.historyAction === \"POP\";\n *   }\n * })\n *\n * @example\n * const promptHandle = React.useRef<PromptOnNavigationHandle>(null);\n * const someAction = () => {\n *  promptHandle.current?.disable();\n *  // Perform action which triggers navigation, but no prompt will be shown\n * }\n * usePromptOnNavigation({when: someBooleanCheck}, promptHandle);\n */\nexport function usePromptOnNavigation(props: PromptOnNavigationProps, ref?: React.ForwardedRef<unknown>) {\n  const disabled = React.useRef(false);\n  React.useImperativeHandle(ref, () => {\n    return {\n      async disable(fn) {\n        disabled.current = true;\n        if (fn) {\n          try {\n            await fn();\n          } catch (e) {\n            // Reenable the prompt if the function fails (e.g. saving of form fails), but rethrow the error.\n            disabled.current = false;\n            throw e;\n          }\n        }\n      },\n      enable() {\n        disabled.current = false;\n      },\n    } as PromptOnNavigationHandle;\n  });\n\n  usePromptOnLocationChange(props, disabled);\n  usePromptBeforeUnload(props);\n}\n\n/**\n * Signal that is fired when a navigation prompt is displayed\n *\n * This is useful when either displaying the prompt or cancelling the navigation has side effects that need to be handled elsewhere.\n * At the time of adding this, it's used for one particular scenario: navigating away from a page that has unsaved changes using desktop tabs.\n * In that case, we need to prevent the tabs drag&drop from kicking in, and we need to roll back the active tab change if the user decides to\n * cancel navigation.\n */\nexport const navigationPromptSignal = new Signal<void>();\n\nfunction usePromptOnLocationChange(props: PromptOnNavigationProps, disabled: React.RefObject<boolean>) {\n  const routerContext = React.useContext(__RouterContext);\n  const blockers = React.useContext(navigationBlockerContext);\n\n  React.useEffect(() => {\n    if (!props.when || routerContext.staticContext) {\n      return;\n    }\n\n    const blocker = { when: props.when, message: props.message, disabled };\n\n    blockers.add(routerContext, blocker);\n    return () => {\n      blockers.remove(routerContext, blocker);\n    };\n  }, [routerContext.location, props.when, props.message]);\n}\n\nfunction usePromptBeforeUnload(props: PromptOnNavigationProps) {\n  const location = useLocation();\n  React.useEffect(() => {\n    if (!props.when) {\n      return;\n    }\n\n    const handler = Electron.isElectron ? beforeunloadElectron(props, location) : beforeunload(props, location);\n    window.addEventListener(\"beforeunload\", handler);\n    return () => {\n      window.removeEventListener(\"beforeunload\", handler);\n    };\n  }, [location, props.message, props.when]);\n\n  return null;\n}\n\nconst beforeunload = (props: PromptOnNavigationProps, currentLocation: Location) => (event: BeforeUnloadEvent) => {\n  if (\n    resolveWhen(props.when, {\n      type: \"unload\",\n      currentLocation,\n    }) &&\n    !FileDownloadHelper.isDownloading\n  ) {\n    // Cancel the event as stated by the standard.\n    event.preventDefault();\n    // Chrome requires returnValue to be set.\n    event.returnValue = \"\";\n  }\n};\n\nlet showExitPrompt = true;\n\n// Electron implementation of beforeunload callback\nconst beforeunloadElectron =\n  (props: PromptOnNavigationProps, currentLocation: Location) => (event: BeforeUnloadEvent) => {\n    if (resolveWhen(props.when, { type: \"unload\", currentLocation })) {\n      if (showExitPrompt && \"confirm\" in Electron.bridge) {\n        // Prevents the window from closing\n        event.preventDefault();\n        event.returnValue = false;\n        void Electron.bridge.confirm(props.message ?? DEFAULT_PROMPT_ON_NAVIGATION_MESSAGE).then(confirmed => {\n          if (confirmed) {\n            showExitPrompt = false;\n            const newLocation = self.document.activeElement?.getAttribute(\"href\");\n            if (newLocation) {\n              window.location.href = newLocation;\n            } else {\n              window.location.reload();\n            }\n          }\n        });\n      }\n    }\n  };\n\nconst DEFAULT_PROMPT_ON_NAVIGATION_MESSAGE = \"Do you want to leave this page? Changes you made may not be saved.\";\n\nfunction resolveWhen(when: When | undefined, navigationProps: NavigationProps): boolean {\n  if (!when) {\n    return false;\n  }\n\n  if (typeof when === \"function\") {\n    return when(navigationProps);\n  } else {\n    return when;\n  }\n}\n\n/**\n * An imperative handle to disable or enable the prompt.\n */\nexport type PromptOnNavigationHandle = {\n  /** Disables the prompt. You can provide a function which will be wrapped in a try/catch block. If the function fails\n   * then the prompt will automatically be reenabled. */\n  disable(fn?: () => Promise<void> | void): void;\n  /** Enables the prompt. */\n  enable(): void;\n};\n\ntype PromptOnNavigationProps = {\n  /** The message to display to the user. Note that in some browsers on window close the message is not customizable and\n   * will display a default message. */\n  message?: string;\n  /** A condition that must be fulfilled to prompt user. If false navigation is not blocked. A function can also be\n   * specified that will be run at navigation time to figure out whether to prompt. This function will receive\n   * information about the navigation action and location. */\n  when?: When;\n};\n\ntype When = boolean | ((props: NavigationProps) => boolean);\ntype NavigationProps =\n  | {\n      /** This is a client side navigation. */\n      type: \"navigation\";\n      /** The current location. */\n      currentLocation: Location;\n      /** The next location. */\n      nextLocation: Location;\n      /** The action. */\n      historyAction: Action;\n    }\n  | {\n      /** This is a page unload. */\n      type: \"unload\";\n      /** The current location. */\n      currentLocation: Location;\n    };\n\ntype Context = RouteComponentProps<{}, StaticContext, CustomHistoryState>;\ntype Blocker = { when: When; message: string | undefined; disabled: React.RefObject<boolean> };\n\n/**\n * Manages blockers.\n *\n * This is required because you can only register a single blocker on the history object. With our API it's very easy to\n * have multiple components on the page individually blocking on some condition. This class exists to combine all the\n * blockers that might be rendered at any time and register them as a single blocker on the history object. Every time a\n * blocker is added or removed the blockers are recombined and registered on the history object.\n *\n * If a single blocker blocks then the user will be prompted with the message of that blocker. If multiple blockers\n * block then the user will be prompted with a default message that they'll lose their changes.\n */\nclass Blockers {\n  private unblock?: () => void;\n  private blockers: Blocker[] = [];\n\n  /** Adds a blocker to the global instance */\n  public add(context: Context, blocker: Blocker) {\n    this.blockers.push(blocker);\n    this.register(context);\n  }\n\n  /** Removes a blocker to the global instance */\n  public remove(context: Context, blocker: Blocker) {\n    this.blockers = this.blockers.filter(b => b !== blocker);\n    this.register(context);\n  }\n\n  private register(context: Context) {\n    this.unblock?.();\n    this.unblock = context.history.block(this.blocker(context));\n  }\n\n  private blocker(context: Context) {\n    return ((nextLocation, action) => {\n      const blockers = this.blockers;\n      const blockMessages = [];\n\n      for (const blocker of blockers) {\n        const { when, message, disabled } = blocker;\n        if (disabled.current) {\n          continue;\n        }\n\n        // If we stay on the same page, we don't want to prompt\n        if (context.location.pathname === nextLocation.pathname) {\n          continue;\n        }\n\n        const shouldBlock = resolveWhen(when, {\n          type: \"navigation\",\n          currentLocation: context.location,\n          nextLocation,\n          historyAction: action,\n        });\n\n        if (shouldBlock) {\n          blockMessages.push(message ?? DEFAULT_PROMPT_ON_NAVIGATION_MESSAGE);\n        }\n      }\n\n      if (blockMessages.length) {\n        navigationPromptSignal.fire();\n      }\n\n      return blockMessages.length === 0\n        ? undefined\n        : blockMessages.length === 1\n        ? blockMessages[0]\n        : DEFAULT_PROMPT_ON_NAVIGATION_MESSAGE;\n    }) satisfies TransitionPromptHook<CustomHistoryState>;\n  }\n}\n\nconst navigationBlockerContext = React.createContext(new Blockers());\n```\ndiagnostics: linear-app/client/src/hooks/usePromptOnNavigation.ts\n```typescript\nimport * as React from \"react\";\nimport { __RouterContext, useLocation, type StaticContext } from \"react-router\";\n// error: Module '\"react-router\"' has no exported member '__RouterContext'.\nimport type { RouteComponentProps } from \"react-router-dom\";\nimport type { Action, Location, TransitionPromptHook } from \"history\";\n```\n```typescript\nimport * as React from \"react\";\nimport { __RouterContext, useLocation, type StaticContext } from \"react-router\";\n// error: Module '\"react-router\"' has no exported member 'StaticContext'.\nimport type { RouteComponentProps } from \"react-router-dom\";\nimport type { Action, Location, TransitionPromptHook } from \"history\";\n```\n```typescript\nimport * as React from \"react\";\nimport { __RouterContext, useLocation, type StaticContext } from \"react-router\";\nimport type { RouteComponentProps } from \"react-router-dom\";\n// error: Module '\"react-router-dom\"' has no exported member 'RouteComponentProps'.\nimport type { Action, Location, TransitionPromptHook } from \"history\";\nimport { FileDownloadHelper } from \"~/helpers/FileHelper\";\n```\n```typescript\n\n  React.useEffect(() => {\n    if (!props.when || routerContext.staticContext) {\n// error: 'routerContext' is of type 'unknown'.\n      return;\n    }\n```\n```typescript\n      blockers.remove(routerContext, blocker);\n    };\n  }, [routerContext.location, props.when, props.message]);\n// error: 'routerContext' is of type 'unknown'.\n}\n\n```\n\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":71}},"image_offsets":[]},{"id":{"replica_id":0,"value":41},"start":7015,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":72}},"image_offsets":[]},{"id":{"replica_id":0,"value":42},"start":11406,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":73}},"image_offsets":[]}],"summary":"React Router 6 Scroll Restoration Component","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":6963},"icon":"File","label":"linear-app/client/src/routes/ScrollRestoration.tsx"},{"range":{"start":5810,"end":6963},"icon":"ExclamationTriangle","label":"Diagnostics (linear-app/client/src/routes/ScrollRestoration.tsx): 3 errors"},{"range":{"start":5874,"end":6205},"icon":"XCircle","label":"Module '\"react-router-dom\"' has no exported member 'withRouter'."},{"range":{"start":6206,"end":6546},"icon":"XCircle","label":"Module '\"react-router-dom\"' has no exported member 'RouteComponentProps'."},{"range":{"start":6547,"end":6962},"icon":"XCircle","label":"Argument of type 'Location<any> | undefined' is not assignable to parameter of type 'Location'.\n  Type 'undefined' is not assignable to type 'Location<CustomHistoryState>'."},{"range":{"start":11406,"end":23281},"icon":"File","label":"linear-app/client/src/hooks/usePromptOnNavigation.ts"},{"range":{"start":21784,"end":23281},"icon":"ExclamationTriangle","label":"Diagnostics (linear-app/client/src/hooks/usePromptOnNavigation.ts): 5 errors"},{"range":{"start":21850,"end":22188},"icon":"XCircle","label":"Module '\"react-router\"' has no exported member '__RouterContext'."},{"range":{"start":22189,"end":22525},"icon":"XCircle","label":"Module '\"react-router\"' has no exported member 'StaticContext'."},{"range":{"start":22526,"end":22931},"icon":"XCircle","label":"Module '\"react-router-dom\"' has no exported member 'RouteComponentProps'."},{"range":{"start":22932,"end":23098},"icon":"XCircle","label":"'routerContext' is of type 'unknown'."},{"range":{"start":23099,"end":23280},"icon":"XCircle","label":"'routerContext' is of type 'unknown'."}]}