{"id":"e19b16ff-2907-4d39-afc7-ba0db5deacf7","zed":"context","version":"0.4.0","text":"\n\n\n```ts linear-app/client/src/hooks/usePromptOnNavigation.ts\nimport * as React from \"react\";\nimport { __RouterContext, useLocation, type StaticContext } from \"react-router\";\nimport type { RouteComponentProps } from \"react-router-dom\";\nimport type { Action, Location, TransitionPromptHook } from \"history\";\nimport { FileDownloadHelper } from \"~/helpers/FileHelper\";\nimport { Electron } from \"~/electron/Electron\";\nimport type { CustomHistoryState } from \"~/typings/custom-history-state\";\nimport { Signal } from \"~/utils/Signal\";\n\n/**\n * Prevents navigation by showing a prompt to the user. If the user accepts they will then navigate.\n *\n * If you want to allow certain navigation (like saving or cancelling a form) you can imperatively disable/enable the\n * prompt as needed. See example below.\n *\n * @example\n * <PromptOnNavigation when={someBooleanCheck} />\n *\n * @example\n * <PromptOnNavigation message=\"Do you want to leave this page?\" when={props => {\n *  return props.currentLocation.pathname === \"/some-path\" && props.nextLocation.pathname === \"/some-other-path\"\n *    && props.historyAction === \"POP\";\n * } />\n *\n * @example\n * const promptHandle = React.useRef<PromptOnNavigationHandle>(null);\n * const someAction = () => {\n *  promptHandle.current?.disable();\n *  // Perform action which triggers navigation, but no prompt will be shown\n * }\n * <PromptOnNavigation ref={promptHandle} />\n */\nexport const PromptOnNavigation = React.forwardRef((props: PromptOnNavigationProps, ref) => {\n  usePromptOnNavigation(props, ref);\n  return null;\n});\n\n/**\n * Prevents navigation by showing a prompt to the user. If the user accepts they will then navigate.\n *\n * @example\n * usePromptOnNavigation({when: someBooleanCheck});\n *\n * @example\n * usePromptOnNavigation({\n *   message: \"Do you want to leave this page?\",\n *   when: props => {\n *     return props.currentLocation.pathname === \"/some-path\" && props.nextLocation.pathname === \"/some-other-path\"\n *       && props.historyAction === \"POP\";\n *   }\n * })\n *\n * @example\n * const promptHandle = React.useRef<PromptOnNavigationHandle>(null);\n * const someAction = () => {\n *  promptHandle.current?.disable();\n *  // Perform action which triggers navigation, but no prompt will be shown\n * }\n * usePromptOnNavigation({when: someBooleanCheck}, promptHandle);\n */\nexport function usePromptOnNavigation(props: PromptOnNavigationProps, ref?: React.ForwardedRef<unknown>) {\n  const disabled = React.useRef(false);\n  React.useImperativeHandle(ref, () => {\n    return {\n      async disable(fn) {\n        disabled.current = true;\n        if (fn) {\n          try {\n            await fn();\n          } catch (e) {\n            // Reenable the prompt if the function fails (e.g. saving of form fails), but rethrow the error.\n            disabled.current = false;\n            throw e;\n          }\n        }\n      },\n      enable() {\n        disabled.current = false;\n      },\n    } as PromptOnNavigationHandle;\n  });\n\n  usePromptOnLocationChange(props, disabled);\n  usePromptBeforeUnload(props);\n}\n\n/**\n * Signal that is fired when a navigation prompt is displayed\n *\n * This is useful when either displaying the prompt or cancelling the navigation has side effects that need to be handled elsewhere.\n * At the time of adding this, it's used for one particular scenario: navigating away from a page that has unsaved changes using desktop tabs.\n * In that case, we need to prevent the tabs drag&drop from kicking in, and we need to roll back the active tab change if the user decides to\n * cancel navigation.\n */\nexport const navigationPromptSignal = new Signal<void>();\n\nfunction usePromptOnLocationChange(props: PromptOnNavigationProps, disabled: React.RefObject<boolean>) {\n  const routerContext = React.useContext(__RouterContext);\n  const blockers = React.useContext(navigationBlockerContext);\n\n  React.useEffect(() => {\n    if (!props.when || routerContext.staticContext) {\n      return;\n    }\n\n    const blocker = { when: props.when, message: props.message, disabled };\n\n    blockers.add(routerContext, blocker);\n    return () => {\n      blockers.remove(routerContext, blocker);\n    };\n  }, [routerContext.location, props.when, props.message]);\n}\n\nfunction usePromptBeforeUnload(props: PromptOnNavigationProps) {\n  const location = useLocation();\n  React.useEffect(() => {\n    if (!props.when) {\n      return;\n    }\n\n    const handler = Electron.isElectron ? beforeunloadElectron(props, location) : beforeunload(props, location);\n    window.addEventListener(\"beforeunload\", handler);\n    return () => {\n      window.removeEventListener(\"beforeunload\", handler);\n    };\n  }, [location, props.message, props.when]);\n\n  return null;\n}\n\nconst beforeunload = (props: PromptOnNavigationProps, currentLocation: Location) => (event: BeforeUnloadEvent) => {\n  if (\n    resolveWhen(props.when, {\n      type: \"unload\",\n      currentLocation,\n    }) &&\n    !FileDownloadHelper.isDownloading\n  ) {\n    // Cancel the event as stated by the standard.\n    event.preventDefault();\n    // Chrome requires returnValue to be set.\n    event.returnValue = \"\";\n  }\n};\n\nlet showExitPrompt = true;\n\n// Electron implementation of beforeunload callback\nconst beforeunloadElectron =\n  (props: PromptOnNavigationProps, currentLocation: Location) => (event: BeforeUnloadEvent) => {\n    if (resolveWhen(props.when, { type: \"unload\", currentLocation })) {\n      if (showExitPrompt && \"confirm\" in Electron.bridge) {\n        // Prevents the window from closing\n        event.preventDefault();\n        event.returnValue = false;\n        void Electron.bridge.confirm(props.message ?? DEFAULT_PROMPT_ON_NAVIGATION_MESSAGE).then(confirmed => {\n          if (confirmed) {\n            showExitPrompt = false;\n            const newLocation = self.document.activeElement?.getAttribute(\"href\");\n            if (newLocation) {\n              window.location.href = newLocation;\n            } else {\n              window.location.reload();\n            }\n          }\n        });\n      }\n    }\n  };\n\nconst DEFAULT_PROMPT_ON_NAVIGATION_MESSAGE = \"Do you want to leave this page? Changes you made may not be saved.\";\n\nfunction resolveWhen(when: When | undefined, navigationProps: NavigationProps): boolean {\n  if (!when) {\n    return false;\n  }\n\n  if (typeof when === \"function\") {\n    return when(navigationProps);\n  } else {\n    return when;\n  }\n}\n\n/**\n * An imperative handle to disable or enable the prompt.\n */\nexport type PromptOnNavigationHandle = {\n  /** Disables the prompt. You can provide a function which will be wrapped in a try/catch block. If the function fails\n   * then the prompt will automatically be reenabled. */\n  disable(fn?: () => Promise<void> | void): void;\n  /** Enables the prompt. */\n  enable(): void;\n};\n\ntype PromptOnNavigationProps = {\n  /** The message to display to the user. Note that in some browsers on window close the message is not customizable and\n   * will display a default message. */\n  message?: string;\n  /** A condition that must be fulfilled to prompt user. If false navigation is not blocked. A function can also be\n   * specified that will be run at navigation time to figure out whether to prompt. This function will receive\n   * information about the navigation action and location. */\n  when?: When;\n};\n\ntype When = boolean | ((props: NavigationProps) => boolean);\ntype NavigationProps =\n  | {\n      /** This is a client side navigation. */\n      type: \"navigation\";\n      /** The current location. */\n      currentLocation: Location;\n      /** The next location. */\n      nextLocation: Location;\n      /** The action. */\n      historyAction: Action;\n    }\n  | {\n      /** This is a page unload. */\n      type: \"unload\";\n      /** The current location. */\n      currentLocation: Location;\n    };\n\ntype Context = RouteComponentProps<{}, StaticContext, CustomHistoryState>;\ntype Blocker = { when: When; message: string | undefined; disabled: React.RefObject<boolean> };\n\n/**\n * Manages blockers.\n *\n * This is required because you can only register a single blocker on the history object. With our API it's very easy to\n * have multiple components on the page individually blocking on some condition. This class exists to combine all the\n * blockers that might be rendered at any time and register them as a single blocker on the history object. Every time a\n * blocker is added or removed the blockers are recombined and registered on the history object.\n *\n * If a single blocker blocks then the user will be prompted with the message of that blocker. If multiple blockers\n * block then the user will be prompted with a default message that they'll lose their changes.\n */\nclass Blockers {\n  private unblock?: () => void;\n  private blockers: Blocker[] = [];\n\n  /** Adds a blocker to the global instance */\n  public add(context: Context, blocker: Blocker) {\n    this.blockers.push(blocker);\n    this.register(context);\n  }\n\n  /** Removes a blocker to the global instance */\n  public remove(context: Context, blocker: Blocker) {\n    this.blockers = this.blockers.filter(b => b !== blocker);\n    this.register(context);\n  }\n\n  private register(context: Context) {\n    this.unblock?.();\n    this.unblock = context.history.block(this.blocker(context));\n  }\n\n  private blocker(context: Context) {\n    return ((nextLocation, action) => {\n      const blockers = this.blockers;\n      const blockMessages = [];\n\n      for (const blocker of blockers) {\n        const { when, message, disabled } = blocker;\n        if (disabled.current) {\n          continue;\n        }\n\n        // If we stay on the same page, we don't want to prompt\n        if (context.location.pathname === nextLocation.pathname) {\n          continue;\n        }\n\n        const shouldBlock = resolveWhen(when, {\n          type: \"navigation\",\n          currentLocation: context.location,\n          nextLocation,\n          historyAction: action,\n        });\n\n        if (shouldBlock) {\n          blockMessages.push(message ?? DEFAULT_PROMPT_ON_NAVIGATION_MESSAGE);\n        }\n      }\n\n      if (blockMessages.length) {\n        navigationPromptSignal.fire();\n      }\n\n      return blockMessages.length === 0\n        ? undefined\n        : blockMessages.length === 1\n        ? blockMessages[0]\n        : DEFAULT_PROMPT_ON_NAVIGATION_MESSAGE;\n    }) satisfies TransitionPromptHook<CustomHistoryState>;\n  }\n}\n\nconst navigationBlockerContext = React.createContext(new Blockers());\n```\ndiagnostics: linear-app/client/src/hooks/usePromptOnNavigation.ts\n```typescript\nimport * as React from \"react\";\nimport { __RouterContext, useLocation, type StaticContext } from \"react-router\";\n// error: Module '\"react-router\"' has no exported member '__RouterContext'.\nimport type { RouteComponentProps } from \"react-router-dom\";\nimport type { Action, Location, TransitionPromptHook } from \"history\";\n```\n```typescript\nimport * as React from \"react\";\nimport { __RouterContext, useLocation, type StaticContext } from \"react-router\";\n// error: Module '\"react-router\"' has no exported member 'StaticContext'.\nimport type { RouteComponentProps } from \"react-router-dom\";\nimport type { Action, Location, TransitionPromptHook } from \"history\";\n```\n```typescript\nimport * as React from \"react\";\nimport { __RouterContext, useLocation, type StaticContext } from \"react-router\";\nimport type { RouteComponentProps } from \"react-router-dom\";\n// error: Module '\"react-router-dom\"' has no exported member 'RouteComponentProps'.\nimport type { Action, Location, TransitionPromptHook } from \"history\";\nimport { FileDownloadHelper } from \"~/helpers/FileHelper\";\n```\n```typescript\n\n  React.useEffect(() => {\n    if (!props.when || routerContext.staticContext) {\n// error: 'routerContext' is of type 'unknown'.\n      return;\n    }\n```\n```typescript\n      blockers.remove(routerContext, blocker);\n    };\n  }, [routerContext.location, props.when, props.message]);\n// error: 'routerContext' is of type 'unknown'.\n}\n\n```\n\nrewrite this component to work with react-router 6. document all exports\nHere's a rewritten version of the component to work with React Router v6, along with documentation for all exports:\n\n```typescript\nimport * as React from \"react\";\nimport { useLocation, useNavigate, UNSAFE_NavigationContext } from \"react-router-dom\";\nimport type { Location, To } from \"react-router-dom\";\nimport { FileDownloadHelper } from \"~/helpers/FileHelper\";\nimport { Electron } from \"~/electron/Electron\";\nimport type { CustomHistoryState } from \"~/typings/custom-history-state\";\nimport { Signal } from \"~/utils/Signal\";\n\n/**\n * Signal that is fired when a navigation prompt is displayed\n */\nexport const navigationPromptSignal = new Signal<void>();\n\n/**\n * Props for PromptOnNavigation component and usePromptOnNavigation hook\n */\nexport interface PromptOnNavigationProps {\n  /** The message to display to the user */\n  message?: string;\n  /** A condition that must be fulfilled to prompt user */\n  when?: When;\n}\n\n/**\n * An imperative handle to disable or enable the prompt\n */\nexport interface PromptOnNavigationHandle {\n  disable(fn?: () => Promise<void> | void): void;\n  enable(): void;\n}\n\ntype When = boolean | ((props: NavigationProps) => boolean);\n\ntype NavigationProps = {\n  currentLocation: Location;\n  nextLocation: Location;\n};\n\nconst DEFAULT_PROMPT_MESSAGE = \"Are you sure you want to leave this page? You may have unsaved changes.\";\n\n/**\n * A component that prevents navigation by showing a prompt to the user\n */\nexport const PromptOnNavigation = React.forwardRef<PromptOnNavigationHandle, PromptOnNavigationProps>((props, ref) => {\n  usePromptOnNavigation(props, ref);\n  return null;\n});\n\n/**\n * A hook that prevents navigation by showing a prompt to the user\n */\nexport function usePromptOnNavigation(\n  props: PromptOnNavigationProps,\n  ref?: React.ForwardedRef<PromptOnNavigationHandle>\n) {\n  const navigate = useNavigate();\n  const currentLocation = useLocation();\n  const navigationContext = React.useContext(UNSAFE_NavigationContext);\n\n  const [isBlocked, setIsBlocked] = React.useState(false);\n\n  React.useEffect(() => {\n    if (!props.when) {\n      return;\n    }\n\n    const unblock = navigationContext.navigator.block((tx) => {\n      const autoUnblockingTx = {\n        ...tx,\n        retry() {\n          unblock();\n          tx.retry();\n        },\n      };\n\n      const shouldBlock =\n        typeof props.when === \"function\"\n          ? props.when({\n              currentLocation,\n              nextLocation: tx.location,\n            })\n          : props.when;\n\n      if (shouldBlock) {\n        setIsBlocked(true);\n        navigationPromptSignal.fire();\n      } else {\n        autoUnblockingTx.retry();\n      }\n    });\n\n    return unblock;\n  }, [props.when, currentLocation, navigationContext.navigator]);\n\n  const confirmNavigation = React.useCallback(() => {\n    setIsBlocked(false);\n    navigate(navigationContext.location as To);\n  }, [navigate, navigationContext.location]);\n\n  const cancelNavigation = React.useCallback(() => {\n    setIsBlocked(false);\n  }, []);\n\n  React.useEffect(() => {\n    if (isBlocked) {\n      const message = props.message || DEFAULT_PROMPT_MESSAGE;\n      const confirmed = window.confirm(message);\n      if (confirmed) {\n        confirmNavigation();\n      } else {\n        cancelNavigation();\n      }\n    }\n  }, [isBlocked, props.message, confirmNavigation, cancelNavigation]);\n\n  React.useImperativeHandle(ref, () => ({\n    disable: async (fn?: () => Promise<void> | void) => {\n      setIsBlocked(false);\n      if (fn) {\n        try {\n          await fn();\n        } catch (e) {\n          setIsBlocked(true);\n          throw e;\n        }\n      }\n    },\n    enable: () => {\n      setIsBlocked(true);\n    },\n  }));\n\n  usePromptBeforeUnload(props);\n}\n\nfunction usePromptBeforeUnload(props: PromptOnNavigationProps) {\n  const location = useLocation();\n\n  React.useEffect(() => {\n    if (!props.when) {\n      return;\n    }\n\n    const handler = Electron.isElectron ? beforeunloadElectron(props, location) : beforeunload(props, location);\n    window.addEventListener(\"beforeunload\", handler);\n    return () => {\n      window.removeEventListener(\"beforeunload\", handler);\n    };\n  }, [location, props.message, props.when]);\n}\n\nconst beforeunload = (props: PromptOnNavigationProps, currentLocation: Location) => (event: BeforeUnloadEvent) => {\n  if (\n    resolveWhen(props.when, {\n      currentLocation,\n      nextLocation: currentLocation,\n    }) &&\n    !FileDownloadHelper.isDownloading\n  ) {\n    event.preventDefault();\n    event.returnValue = \"\";\n  }\n};\n\nlet showExitPrompt = true;\n\nconst beforeunloadElectron =\n  (props: PromptOnNavigationProps, currentLocation: Location) => (event: BeforeUnloadEvent) => {\n    if (\n      resolveWhen(props.when, {\n        currentLocation,\n        nextLocation: currentLocation,\n      })\n    ) {\n      if (showExitPrompt && \"confirm\" in Electron.bridge) {\n        event.preventDefault();\n        event.returnValue = false;\n        void Electron.bridge.confirm(props.message ?? DEFAULT_PROMPT_MESSAGE).then((confirmed) => {\n          if (confirmed) {\n            showExitPrompt = false;\n            const newLocation = self.document.activeElement?.getAttribute(\"href\");\n            if (newLocation) {\n              window.location.href = newLocation;\n            } else {\n              window.location.reload();\n            }\n          }\n        });\n      }\n    }\n  };\n\nfunction resolveWhen(when: When | undefined, navigationProps: NavigationProps): boolean {\n  if (!when) {\n    return false;\n  }\n\n  return typeof when === \"function\" ? when(navigationProps) : when;\n}\n\n```\n\nExported items:\n\n1. `navigationPromptSignal`: A `Signal` instance that fires when a navigation prompt is displayed.\n\n2. `PromptOnNavigationProps`: Interface for the props of the `PromptOnNavigation` component and `usePromptOnNavigation` hook.\n\n3. `PromptOnNavigationHandle`: Interface for the imperative handle to disable or enable the prompt.\n\n4. `PromptOnNavigation`: A React component that prevents navigation by showing a prompt to the user.\n\n5. `usePromptOnNavigation`: A custom hook that prevents navigation by showing a prompt to the user.\n\nThis rewrite adapts the component to work with React Router v6 by using the new `useNavigate` hook and the `UNSAFE_NavigationContext`. It also simplifies the implementation by removing the `Blockers` class and using React's built-in state management instead.\n\nThe core functionality remains the same: it prevents navigation when certain conditions are met and prompts the user before allowing the navigation to proceed. The implementation for Electron-specific behavior and `beforeunload` event handling is kept intact.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3830}},"image_offsets":[]},{"id":{"replica_id":0,"value":20},"start":11952,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3831}},"image_offsets":[]},{"id":{"replica_id":0,"value":21},"start":18584,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3832}},"image_offsets":[]}],"summary":"React Router Navigation Prompt Hook","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":11878},"icon":"File","label":"linear-app/client/src/hooks/usePromptOnNavigation.ts"},{"range":{"start":10381,"end":11878},"icon":"ExclamationTriangle","label":"Diagnostics (linear-app/client/src/hooks/usePromptOnNavigation.ts): 5 errors"},{"range":{"start":10447,"end":10785},"icon":"XCircle","label":"Module '\"react-router\"' has no exported member '__RouterContext'."},{"range":{"start":10786,"end":11122},"icon":"XCircle","label":"Module '\"react-router\"' has no exported member 'StaticContext'."},{"range":{"start":11123,"end":11528},"icon":"XCircle","label":"Module '\"react-router-dom\"' has no exported member 'RouteComponentProps'."},{"range":{"start":11529,"end":11695},"icon":"XCircle","label":"'routerContext' is of type 'unknown'."},{"range":{"start":11696,"end":11877},"icon":"XCircle","label":"'routerContext' is of type 'unknown'."}]}