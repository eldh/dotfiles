{"id":"3cc2eb98-9ba0-4fd3-99f4-e22154f1015c","zed":"context","version":"0.4.0","text":"\n\n\n```ts linear-app/orbiter/src/utils/ThemeHelper.ts\nimport type { Color, Theme } from \"../styles/Theme\";\nimport { ColorConverter } from \"./ColorConverter\";\n\n/**\n * Returns a theme object based on the theme input provided.\n *\n * @param customColor Custom colors to override base theme\n * @return Custom theme based on the colors provided\n */\nexport namespace ThemeHelper {\n  /**\n   * Unmemoized version of the function which returns a theme object based on theme input.\n   */\n  export function generateThemeUnmemoized(input: ThemeInput): Theme {\n    const bgBase = input.base;\n    const light = bgBase[0] > 50;\n    const veryLight = light && bgBase[0] > 98 && bgBase[1] < 8;\n    const veryDark = !light && bgBase[0] < 5 && bgBase[1] < 8;\n\n    const bgContrastBoost = ((light ? -1 : 1) * input.contrast) / 30;\n\n    const bg = (\n      base: ColorConverter.LCH,\n      adjustments: ColorConverter.LCHAdjustments,\n      adjustTo?: ColorConverter.LCHAdjustments\n    ) => {\n      const retVal = ColorConverter.adjust(\n        base,\n        mapValues(adjustments, v => v && v * bgContrastBoost)\n      );\n      return adjustTo ? ColorConverter.adjustTo(retVal, adjustTo) : retVal;\n    };\n    const controlContrastBoost = ((light ? -0.8 : 1) * input.contrast) / 70;\n    const control = (\n      base: ColorConverter.LCH,\n      adjustments: ColorConverter.LCHAdjustments,\n      adjustTo?: ColorConverter.LCHAdjustments\n    ) => {\n      const retVal = ColorConverter.adjust(\n        base,\n        mapValues(adjustments, v => v && v * controlContrastBoost)\n      );\n      return adjustTo ? ColorConverter.adjustTo(retVal, adjustTo) : retVal;\n    };\n\n    const borderContrastBoost = ((light ? -0.9 : 0.8) * (input.contrast + Math.max(input.contrast - 30, 0) * 0.1)) / 10;\n    const border = (\n      base: ColorConverter.LCH,\n      adjustments: ColorConverter.LCHAdjustments,\n      adjustTo?: ColorConverter.LCHAdjustments\n    ) => {\n      const retVal = ColorConverter.adjust(base, {\n        ...adjustments,\n        l: adjustments.l && adjustments.l * borderContrastBoost,\n        c: (adjustments.c ?? 0) * borderContrastBoost,\n      });\n      return adjustTo ? ColorConverter.adjustTo(retVal, adjustTo) : retVal;\n    };\n\n    const textContrastBoost = ((light ? -1 : 1) * (3 + (100 - input.contrast) / 70)) / 4;\n    const text = (\n      base: ColorConverter.LCH,\n      adjustments: ColorConverter.LCHAdjustments,\n      adjustTo?: ColorConverter.LCHAdjustments\n    ) => {\n      const retVal = ColorConverter.adjust(ColorConverter.getTextColor(base), {\n        ...adjustments,\n        l: adjustments.l && adjustments.l * textContrastBoost,\n      });\n      return adjustTo ? ColorConverter.adjustTo(retVal, adjustTo) : retVal;\n    };\n\n    const shadowContrastBoost = Math.max(1, 1 + Math.max(input.contrast - 30, 0) / (light ? 30 : 10));\n\n    const shadow = (a: number) => {\n      return ColorConverter.toCss(input.colorFormat, [0, 0, 0, a * shadowContrastBoost]);\n    };\n\n    const textMultiplier = (1 + Math.abs(bgBase[0] - 50) / 50) / 2;\n\n    const bgBaseHover = bg(bgBase, light ? { l: 1.25 } : { l: veryDark ? 2 : 1.5, c: 1 });\n\n    const bgSub = bg(bgBase, light ? { l: 5 } : { l: -2, c: -2 });\n    const bgSubHover = bg(bgSub, light ? { l: 2 } : { l: veryDark ? 3 : 2.5, c: 3 });\n\n    const bgShade = bg(bgBase, veryLight ? { l: 4.5, c: -2 } : light ? { l: -5 } : { l: 5, c: 2 });\n    const bgShadeHover = bg(bgShade, light ? { l: 2 } : { l: veryDark ? 3 : 2.5, c: 1 });\n\n    const bgBorder = border(bgBase, { l: 3.5, c: 1 });\n    const bgBorderHover = border(bgBorder, { l: 1 });\n\n    const bgBorderThin = border(bgBase, { l: 4, c: 1 });\n\n    const bgBorderFaint = border(bgBase, light ? { l: 1.5, c: 1 } : { l: 1.75, c: 1 });\n    const bgBorderFaintHover = border(bgBorderFaint, { l: 1 });\n    const bgBorderFaintThin = border(bgBase, light ? { l: 2.5, c: 1 } : { l: 2, c: 1 });\n\n    const bgBorderSolid = border(bgBase, { l: 5, c: 1 });\n    const bgBorderSolidHover = border(bgBase, { l: 6, c: 1 });\n    const bgBorderSolidThin = border(bgBase, { l: 5, c: 1 });\n\n    const bgSelected = ColorConverter.mix(bgBase, input.accent, (1 + bgBase[1] / 30) * (light ? 0.18 : 0.05));\n    const bgSelectedHover = bg(bgSelected, light ? { l: 2 } : { l: 2.5, c: 2 });\n\n    const labelTitle = text(bgBase, { l: light ? -10 * textMultiplier : 10 }, { c: 0 });\n    const labelBase = text(bgBase, { l: (light ? -20 : -10) * textMultiplier, c: 1 });\n    const labelMuted = text(bgBase, { l: (light ? -40 : -40) * textMultiplier, c: 1 });\n    const labelFaint = text(bgBase, { l: (light ? -66 : -66) * textMultiplier, c: 1 });\n    const labelLink = text(bgBase, { l: (light ? -45 : -45) * textMultiplier }, { h: input.accent[2], c: 70 });\n\n    const controlPrimary = input.accent;\n    const controlSecondary = control(bgBase, light ? { l: -6 } : { l: 15, c: 6 });\n\n    const controlTertiary = control(bgBase, light ? {} : { l: 5, c: 1 });\n    const controlTertiarySelected = control(bgBase, light ? { l: 15, c: -3 } : { l: 10, c: 5 });\n\n    const naiveFocusColor = input.baseTheme ? ColorConverter.fromCss(input.baseTheme.color.focusColor) : input.accent;\n\n    const accentCanBeUsedForFocus =\n      naiveFocusColor[1] > 50 && (light ? naiveFocusColor[0] < 90 : naiveFocusColor[0] > 30);\n    const focusColor: ColorConverter.LCH = accentCanBeUsedForFocus\n      ? naiveFocusColor\n      : ColorConverter.adjustTo(naiveFocusColor, light ? { l: 70, c: 90 } : { l: 50, c: 120 });\n\n    const redBase: ColorConverter.LCH = [58, 67, 29];\n    const yellowBase: ColorConverter.LCH = [80, 100, 85];\n    const greenBase: ColorConverter.LCH = [60, 64.37, 141.95];\n    const tealBase: ColorConverter.LCH = [67.5, 39, 217];\n    const orangeBase: ColorConverter.LCH = [66, 73, 48];\n    const purpleBase: ColorConverter.LCH = [48, 59.31, 288.43];\n    const blueBase: ColorConverter.LCH = [80, 100, 262];\n    const colorBgMixRatio = light ? 0.6 : 0.5;\n\n    const blueBg = ColorConverter.mix(bgBase, blueBase, colorBgMixRatio);\n    const greenBg = ColorConverter.mix(bgBase, greenBase, colorBgMixRatio);\n    const orangeBg = ColorConverter.mix(bgBase, orangeBase, colorBgMixRatio);\n    const purpleBg = ColorConverter.mix(bgBase, purpleBase, colorBgMixRatio);\n    const redBg = ColorConverter.mix(bgBase, redBase, colorBgMixRatio);\n    const tealBg = ColorConverter.mix(bgBase, tealBase, colorBgMixRatio);\n    const yellowBg = ColorConverter.mix(bgBase, yellowBase, colorBgMixRatio);\n    const lchColors: Record<keyof Color, ColorConverter.LCH> = {\n      bgSub,\n      bgSubHover,\n      bgBase,\n      bgBaseHover,\n      bgShade,\n      bgShadeHover,\n      bgSelected,\n      bgSelectedHover,\n      bgFocus: bg(bgBase, { l: light ? 4 : 8, c: light ? undefined : 2.5 }),\n\n      bgBorder,\n      bgBorderHover,\n      bgBorderThin,\n      bgBorderFaint,\n      bgBorderFaintHover,\n      bgBorderFaintThin,\n      bgBorderSolid,\n      bgBorderSolidHover,\n      bgBorderSolidThin,\n      bgSelectedBorder: border(bgSelected, { l: 3.5, c: 1 }),\n      bgSelectedBorderHover: border(bgSelected, { l: 4.5, c: 1 }),\n\n      labelBase,\n      labelFaint,\n      labelLink,\n      labelMuted,\n      labelTitle,\n\n      bgModalOverlay: light\n        ? [0, 0, 0, 0.1 * shadowContrastBoost]\n        : ColorConverter.adjustTo(bgBase, { a: 0.15 * shadowContrastBoost }),\n\n      controlSecondaryHighlight: control(controlSecondary, { l: veryLight ? 15 : light ? -15 : 8, c: 2 }),\n      controlLabel: text(input.accent, {}, { c: Math.min(5, input.accent[1]) }),\n      controlSelectLabel: labelTitle,\n      controlSelectedBg: controlTertiarySelected,\n\n      controlPrimary,\n      controlPrimaryHover: bg(controlPrimary, { l: light ? 3 : 5, c: 2 }),\n      controlPrimaryLabel: text(input.accent, {}, { c: Math.min(5, input.accent[1]) }),\n\n      controlSecondary,\n      controlSecondaryHover: control(controlSecondary, { l: veryLight ? 8 : light ? -15 : 8, c: 2 }),\n      controlSecondaryLabel: labelBase,\n\n      controlTertiary,\n      controlTertiaryHover: control(\n        controlTertiary,\n        veryLight ? { l: 10 } : light ? { l: -15 } : veryDark ? { l: 8, a: 0.3 } : { l: 4, a: 0.2 }\n      ),\n      controlTertiaryLabel: labelBase,\n      controlTertiarySelected,\n\n      scrollbarBg: ColorConverter.adjust(labelFaint, { l: light ? 0.3 : 0.4 }),\n      scrollbarBgHover: ColorConverter.adjust(labelFaint, { l: 0.8 }),\n      scrollbarBgActive: labelFaint,\n\n      blueBase,\n      blueBaseHover: bg(blueBase, { l: 5 }),\n      blueBg,\n      blueMid: bg(blueBase, { l: 8 }),\n      blueText: text(blueBg, { l: -20 }, { c: 80 }),\n      blueForeground: ColorConverter.getTextColor(blueBg),\n\n      greenBase,\n      greenBaseHover: bg(greenBase, { l: 5 }),\n      greenBg,\n      greenMid: bg(greenBase, { l: 8 }),\n      greenText: text(greenBg, { l: -20 }, { c: 80 }),\n      greenForeground: ColorConverter.getTextColor(greenBg),\n\n      orangeBase,\n      orangeBaseHover: bg(orangeBase, { l: 5 }),\n      orangeBg,\n      orangeMid: bg(orangeBase, { l: 8 }),\n      orangeText: text(orangeBg, { l: -20 }, { c: 80 }),\n      orangeForeground: ColorConverter.getTextColor(orangeBg),\n\n      purpleBase,\n      purpleBaseHover: bg(purpleBase, { l: 5 }),\n      purpleBg,\n      purpleMid: bg(purpleBase, { l: 8 }),\n      purpleText: text(purpleBg, { l: -20 }, { c: 80 }),\n      purpleForeground: ColorConverter.getTextColor(purpleBg),\n\n      redBase,\n      redBaseHover: bg(redBase, { l: 5 }),\n      redBg,\n      redMid: bg(redBase, { l: 8 }),\n      redText: text(redBg, { l: -20 }, { c: 80 }),\n      redForeground: ColorConverter.getTextColor(redBg),\n\n      tealBase,\n      tealBaseHover: bg(tealBase, { l: 5 }),\n      tealBg,\n      tealMid: bg(tealBase, { l: 8 }),\n      tealText: text(tealBg, { l: -20 }, { c: 80 }),\n      tealForeground: ColorConverter.getTextColor(tealBg),\n\n      yellowBase,\n      yellowBaseHover: bg(yellowBase, { l: 5 }),\n      yellowBg,\n      yellowMid: bg(yellowBase, { l: 8 }),\n      yellowText: text(yellowBg, { l: -20 }, { c: 80 }),\n      yellowForeground: ColorConverter.getTextColor(yellowBg),\n\n      scrollBackground: light ? [100, 0, 0, 0] : [0, 0, 0, 0.004],\n      shadowColor: border(light ? [0, 0, 0, 0.03] : [0, 0, 0, 0.15], { l: 1 }),\n      textHighlight: light ? [96, 20, 90] : [30, 35, 80],\n      focusColor,\n      githubLogo: labelMuted,\n      sidebarLinkBg: bg(bgBase, { l: light ? 2 : 4, c: light ? undefined : 2 }),\n    };\n\n    const themeColor: Color = mapValues(lchColors, c => ColorConverter.toCss(input.colorFormat, c));\n\n    let elevatedTheme: Theme, subTheme: Theme, sidebarTheme: Theme, menuTheme: Theme, selectedTheme: Theme;\n\n    const shadow02 = shadow(0.02);\n    const shadow04 = shadow(0.04);\n    const shadow06 = shadow(0.06);\n    const shadow07 = shadow(0.07);\n    const shadow08 = shadow(0.08);\n    const shadow1 = shadow(0.1);\n    const shadow125 = shadow(0.125);\n    const shadow2 = shadow(0.2);\n\n    const theme: Theme = {\n      focusColor: themeColor.focusColor,\n      shadowColor: themeColor.shadowColor,\n      contrast: input.contrast,\n      colorFormat: input.colorFormat,\n\n      focusShadow: `0 0 0 1px ${themeColor.focusColor}`,\n      shadowLow: light\n        ? `0px 4px 4px -1px ${shadow02}, 0px 1px 1px 0px ${shadow06}`\n        : `0px 4px 4px -1px ${shadow04}, 0px 1px 1px 0px ${shadow08}`,\n      shadowBorder: \"0 0 0 0.5px \" + themeColor.bgBorder,\n      shadowMedium: light\n        ? `0 3px 8px ${shadow07}, 0 2px 5px ${shadow07}, 0 1px 1px ${shadow07}`\n        : `0 3px 8px ${shadow125}, 0 2px 5px ${shadow125}, 0 1px 1px ${shadow125}`,\n      shadowHigh: light\n        ? `0 4px 30px ${shadow125}, 0 3px 17px ${shadow04}, 0 2px 8px ${shadow04},  0 1px 1px ${shadow04}`\n        : `0 4px 40px ${shadow1}, 0 3px 20px ${shadow125},0 3px 12px ${shadow125}, 0 2px 8px ${shadow125}, 0 1px 1px ${shadow125}`,\n      shadowPage: light\n        ? `0px 4px 4px -1px ${shadow02}, 0px 1px 1px 0px ${shadow06}`\n        : `0 3px 8px ${shadow125}, 0 2px 5px ${shadow125}, 0 1px 1px ${shadow125}`,\n      shadowInset: light\n        ? `0 1px 1px inset ${shadow07}, 0 1px 3px inset ${shadow07}, 0 2px 5px inset ${shadow1}`\n        : `0 1px 1px inset ${shadow07}, 0 1px 3px inset ${shadow07}, 0 2px 5px inset ${shadow1}`,\n      boxDragShadow: light ? `0px 9px 17px ${shadow125}` : `0px 2px 8px ${shadow2}`,\n\n      inputPadding: \"6px 12px\",\n      inputBackground: themeColor.bgBase,\n      inputBorder: `1px solid ${themeColor.bgBorder}`,\n      inputBorderRadius: \"5px\",\n      inputFontSize: \"0.8125rem\",\n\n      color: themeColor,\n      isDark: !light,\n      highlightVariant: c =>\n        ColorConverter.toCss(\n          input.colorFormat,\n          ColorConverter.adjust(ColorConverter.fromCss(c), veryLight ? { l: -8 } : { l: 8, c: 5 })\n        ),\n      elevatedTheme: () => {\n        // Don't calculate elevated theme for sub theme, just use base theme.\n        if (!elevatedTheme) {\n          elevatedTheme =\n            input.elevation === -1 && input.baseTheme\n              ? input.baseTheme\n              : generateTheme({\n                  ...input,\n                  elevation: (input.elevation ?? 0) + 1,\n                  baseTheme: theme,\n                  _themeType: \"elevated\",\n                  base: bg(lchColors.bgBase, {\n                    l: light ? -8 : 3,\n                    c: light && !veryLight ? 0 : 1,\n                  }),\n                });\n        }\n        return elevatedTheme;\n      },\n      subTheme: () =>\n        // Don't calculate sub theme for elevated theme, just use base theme.\n        {\n          if (!subTheme) {\n            subTheme =\n              !veryLight && input.elevation === 1 && input.baseTheme\n                ? input.baseTheme\n                : {\n                    ...generateTheme({\n                      ...input,\n                      elevation: (input.elevation ?? 0) - 1,\n                      base: bgSub,\n                      baseTheme: theme,\n                      _themeType: \"sub\",\n                    }),\n                  };\n          }\n          return subTheme;\n        },\n      sidebarTheme: () => {\n        if (!sidebarTheme) {\n          sidebarTheme = input.sidebarInput\n            ? generateTheme({ ...input, ...input.sidebarInput, _themeType: \"sidebar\" })\n            : theme.subTheme();\n          const base = input.sidebarInput ? sidebarTheme.elevatedTheme() : theme;\n          const sidebarIsLight = input.sidebarInput ? input.sidebarInput.base[0] > 50 : light;\n          const sidebarIsVeryLight = input.sidebarInput\n            ? sidebarIsLight && input.sidebarInput.base[0] > 98 && input.sidebarInput.base[1] < 8\n            : veryLight;\n          sidebarTheme.color.controlTertiarySelected = sidebarIsLight ? shadow06 : base.color.bgShade;\n          sidebarTheme.color.controlTertiaryHover = sidebarIsLight ? shadow06 : base.color.controlSecondary;\n\n          sidebarTheme.color.controlSecondary = sidebarIsVeryLight\n            ? base.color.bgBase\n            : sidebarIsLight\n            ? base.color.bgShade\n            : base.color.controlSecondary;\n          sidebarTheme.color.controlSecondaryHover = sidebarIsVeryLight\n            ? base.color.bgBaseHover\n            : sidebarIsLight\n            ? base.color.bgShadeHover\n            : base.color.controlSecondaryHover;\n        }\n        return sidebarTheme;\n      },\n      menuTheme: () => {\n        if (!menuTheme) {\n          // If the current theme is not base or elevated, use the base command menu theme.\n          const useBaseTheme = theme.baseTheme !== undefined && ![\"base\", \"elevated\"].includes(input._themeType ?? \"\");\n          menuTheme =\n            (useBaseTheme && theme.baseTheme?.menuTheme()) ||\n            generateTheme({\n              ...input,\n              baseTheme: theme,\n              _themeType: \"menu\",\n              base: bg(lchColors.bgBase, {\n                l: light ? -8 : 5,\n                c: light && !veryLight ? 0 : 1,\n              }),\n            });\n        }\n        return menuTheme;\n      },\n      selectedTheme: () => {\n        if (!selectedTheme) {\n          selectedTheme = generateTheme({\n            ...input,\n            base: lchColors.bgSelected,\n            baseTheme: theme,\n            _themeType: \"selected\",\n          });\n        }\n        return selectedTheme;\n      },\n      baseTheme: input.baseTheme,\n    };\n    return theme;\n  }\n\n  /**\n   * Memoized version of above function which returns a theme object based on theme input.\n   *\n   * This memoizes based on the resolver which created a string from the custom colors + whether or not the theme is for\n   * the sidebar.\n   *\n   * @param input Input to generate the theme from\n   * @return Custom theme based on the input provided\n   */\n  export const generateTheme = memoize(\n    ThemeHelper.generateThemeUnmemoized,\n    (input: ThemeInput) => Object.values(input).join(\"_\") + Object.values(input.sidebarInput ?? {}).join(\"_\")\n  );\n\n  /**\n   * Input to generate a theme from.\n   */\n  export type ThemeInput = {\n    contrast: number;\n    accent: ColorConverter.LCH;\n    base: ColorConverter.LCH;\n    colorFormat: ColorConverter.ColorFormat;\n    elevation?: number;\n    baseTheme?: Theme;\n    sidebarInput?: Pick<ThemeInput, \"contrast\" | \"base\" | \"accent\">;\n    _themeType?: \"base\" | \"elevated\" | \"sub\" | \"sidebar\" | \"menu\" | \"selected\";\n  };\n}\n\nfunction mapValues<T extends Object, U>(\n  obj: T,\n  iteratee: (value: T[keyof T], key: keyof T) => U\n): { [K in keyof T]: U } {\n  const result = {} as { [K in keyof T]: U };\n\n  Object.keys(obj).forEach(key => {\n    const typedKey = key as keyof T;\n    result[typedKey] = iteratee(obj[typedKey], typedKey);\n  });\n  return result;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Memoizes a function based on the resolver provided\n */\nexport function memoize<T extends (...args: any) => any>(func: T, resolver: (...args: Parameters<T>) => string): T {\n  const cache = new Map<string, ReturnType<T>>();\n  return ((...args2: Parameters<T>) => {\n    const key = resolver(...args2);\n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n    const result = func(...(args2 as any));\n    cache.set(key, result);\n    return result;\n  }) as T;\n}\n```\n\nwrite a function that returns the lightest (assuming the text color is light) background color that has suffecient contrast against a given reference color. The function should take the base color and the reference text color as arguments and use the `ColorConverter.sufficientContrastForText(color1: LCH, color2: LCH)` function to check if the contrast is sufficient. If no such color exists, the function should return undefined. The chroma of the input color should ideally not be changed, but if necessary it can be decreased.\n\n\nHere's a function that finds the lightest background color with sufficient contrast against a given reference text color:\n\n```typescript\nimport { ColorConverter } from \"./ColorConverter\";\n\n/**\n * Finds the lightest background color with sufficient contrast against a reference text color.\n * @param baseColor The base color to start from (LCH format).\n * @param referenceTextColor The reference text color to compare against (LCH format).\n * @param step The step size for lightness adjustment (default: 0.5).\n * @param maxIterations Maximum number of iterations to prevent infinite loops (default: 200).\n * @returns The lightest background color with sufficient contrast, or undefined if not found.\n */\nexport function findLightestSufficientContrastBackground(\n  baseColor: ColorConverter.LCH,\n  referenceTextColor: ColorConverter.LCH,\n  step: number = 0.5,\n  maxIterations: number = 200\n): ColorConverter.LCH | undefined {\n  let [l, c, h] = baseColor;\n  let currentColor: ColorConverter.LCH = [l, c, h];\n  let iterations = 0;\n\n  // First, try increasing lightness without changing chroma\n  while (l <= 100 && iterations < maxIterations) {\n    if (ColorConverter.sufficientContrastForText(currentColor, referenceTextColor)) {\n      return currentColor;\n    }\n    l = Math.min(l + step, 100);\n    currentColor = [l, c, h];\n    iterations++;\n  }\n\n  // If not found, reset lightness and try decreasing chroma\n  l = baseColor[0];\n  while (c >= 0 && iterations < maxIterations) {\n    currentColor = [l, c, h];\n    while (l <= 100 && iterations < maxIterations) {\n      if (ColorConverter.sufficientContrastForText(currentColor, referenceTextColor)) {\n        return currentColor;\n      }\n      l = Math.min(l + step, 100);\n      currentColor = [l, c, h];\n      iterations++;\n    }\n    c = Math.max(c - step, 0);\n    l = baseColor[0]; // Reset lightness for next chroma iteration\n  }\n\n  // If no color with sufficient contrast is found, return undefined\n  return undefined;\n}\n```\n\nThis function does the following:\n\n1. It starts with the base color and tries to increase its lightness while maintaining the original chroma and hue.\n\n2. If increasing lightness alone doesn't achieve sufficient contrast, it resets the lightness to the original value and starts decreasing the chroma while again increasing lightness.\n\n3. It uses a step size (default 0.5) to incrementally adjust the lightness and chroma.\n\n4. It includes a maximum iteration count to prevent infinite loops in case no solution is found.\n\n5. If a color with sufficient contrast is found, it returns that color.\n\n6. If no color with sufficient contrast is found after exploring all possibilities, it returns undefined.\n\nYou can use this function like this:\n\n```typescript\nconst baseColor: ColorConverter.LCH = [50, 30, 180]; // Example base color\nconst referenceTextColor: ColorConverter.LCH = [20, 0, 0]; // Example text color (dark)\n\nconst result = findLightestSufficientContrastBackground(baseColor, referenceTextColor);\n\nif (result) {\n  console.log(\"Lightest background color with sufficient contrast:\", result);\n} else {\n  console.log(\"No background color with sufficient contrast found.\");\n}\n```\n\nThis function prioritizes maintaining the original chroma, only reducing it if necessary. It always tries to find the lightest possible color that meets the contrast requirements.\nMake sure it is as fast as possible, assuming checking contrast is an expensive operation.\nCertainly! To optimize for performance, we can make several improvements, especially considering that checking contrast might be an expensive operation. Here's an optimized version of the function:\n\n```typescript\nimport { ColorConverter } from \"./ColorConverter\";\n\n/**\n * Finds the lightest background color with sufficient contrast against a reference text color.\n * @param baseColor The base color to start from (LCH format).\n * @param referenceTextColor The reference text color to compare against (LCH format).\n * @returns The lightest background color with sufficient contrast, or undefined if not found.\n */\nexport function findLightestSufficientContrastBackground(\n  baseColor: ColorConverter.LCH,\n  referenceTextColor: ColorConverter.LCH\n): ColorConverter.LCH | undefined {\n  const [baseL, baseC, baseH] = baseColor;\n  \n  // Binary search for lightness\n  let minL = baseL;\n  let maxL = 100;\n  let bestL = maxL;\n  let hasValidColor = false;\n\n  while (maxL - minL > 0.1) {\n    const midL = (minL + maxL) / 2;\n    const currentColor: ColorConverter.LCH = [midL, baseC, baseH];\n\n    if (ColorConverter.sufficientContrastForText(currentColor, referenceTextColor)) {\n      hasValidColor = true;\n      bestL = midL;\n      maxL = midL;\n    } else {\n      minL = midL;\n    }\n  }\n\n  if (hasValidColor) {\n    return [bestL, baseC, baseH];\n  }\n\n  // If not found, try reducing chroma\n  const chromaSteps = [baseC * 0.75, baseC * 0.5, baseC * 0.25, 0];\n  for (const c of chromaSteps) {\n    minL = baseL;\n    maxL = 100;\n    bestL = maxL;\n    hasValidColor = false;\n\n    while (maxL - minL > 0.1) {\n      const midL = (minL + maxL) / 2;\n      const currentColor: ColorConverter.LCH = [midL, c, baseH];\n\n      if (ColorConverter.sufficientContrastForText(currentColor, referenceTextColor)) {\n        hasValidColor = true;\n        bestL = midL;\n        maxL = midL;\n      } else {\n        minL = midL;\n      }\n    }\n\n    if (hasValidColor) {\n      return [bestL, c, baseH];\n    }\n  }\n\n  return undefined;\n}\n```\n\nKey optimizations in this version:\n\n1. **Binary search**: Instead of incrementing lightness linearly, we use a binary search to find the lightest sufficient color much faster. This reduces the number of contrast checks significantly.\n\n2. **Discrete chroma steps**: Rather than decreasing chroma gradually, we check a few discrete steps (75%, 50%, 25%, and 0% of the original chroma). This further reduces the number of iterations.\n\n3. **Early return**: We return as soon as we find a valid color, avoiding unnecessary iterations.\n\n4. **Precision limit**: We stop the binary search when the lightness range becomes very small (0.1), which is precise enough for practical purposes.\n\n5. **Removed max iterations**: With binary search, we don't need to worry about infinite loops, so we removed the iteration counter.\n\nThis optimized version should be significantly faster, especially for cases where the contrast check is an expensive operation. It makes fewer contrast checks while still finding a good approximation of the lightest sufficient background color.\n\nYou can use this function the same way as before:\n\n```typescript\nconst baseColor: ColorConverter.LCH = [50, 30, 180];\nconst referenceTextColor: ColorConverter.LCH = [20, 0, 0];\n\nconst result = findLightestSufficientContrastBackground(baseColor, referenceTextColor);\n\nif (result) {\n  console.log(\"Lightest background color with sufficient contrast:\", result);\n} else {\n  console.log(\"No background color with sufficient contrast found.\");\n}\n```\n\nThis optimized version should provide a good balance between speed and accuracy for finding the lightest background color with sufficient contrast.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":436}}},{"id":{"replica_id":0,"value":307},"start":18653,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":437}}},{"id":{"replica_id":0,"value":308},"start":21993,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":438}}},{"id":{"replica_id":0,"value":428},"start":22084,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":439}}},{"id":{"replica_id":0,"value":429},"start":25742,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":440}}}],"summary":"Adaptive Background Color Generator Function","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":18119},"icon":"File","label":"linear-app/orbiter/src/utils/ThemeHelper.ts","metadata":{"path":"linear-app/orbiter/src/utils/ThemeHelper.ts"}}]}