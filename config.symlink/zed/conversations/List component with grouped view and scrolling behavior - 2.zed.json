{"id":"80d2c639-efa7-4dba-b488-d56d5b7781de","zed":"context","version":"0.4.0","text":"\n\n\n```tsx linear-app/client/src/components/List/ListNew.tsx\nimport * as React from \"react\";\nimport { useHistory, useLocation } from \"react-router-dom\";\nimport debounce from \"lodash/debounce\";\nimport styled from \"styled-components\";\nimport { color, screenSize } from \"@linear/orbiter\";\nimport { Flex } from \"@linear/orbiter/components/Flex\";\nimport { GroupedList, type ListCellProps } from \"@linear/orbiter/components/GroupedView/GroupedList\";\nimport { GroupedViewDataContext } from \"@linear/orbiter/components/GroupedView/GroupedViewDataContext\";\nimport { useGroupedViewState } from \"@linear/orbiter/components/GroupedView/GroupedViewState\";\nimport type { GroupedViewItem, GroupedViewItemKey } from \"@linear/orbiter/components/GroupedView/GroupedViewTypes\";\nimport { useComponentHeight } from \"@linear/orbiter/hooks/useComponentSize\";\nimport { useKeyPressEvent } from \"@linear/orbiter/hooks/useKeyPressEvent\";\nimport { KeyboardHelper } from \"@linear/orbiter/utils/KeyboardHelper\";\nimport { GroupedViewItemHelper } from \"@linear/orbiter/components/GroupedView/GroupedViewItemHelper\";\nimport { useAsRef } from \"@linear/orbiter/hooks/useAsRef\";\nimport { groupCountsToRows } from \"~/components/List/ListHelpers\";\nimport type {\n  AnyGroupedDataProvider,\n  ProviderItem,\n} from \"~/components/List/components/dataProviders/GroupedViewDataProvider\";\nimport type { ListItemData } from \"~/components/List/hooks/useListNavigation\";\nimport { suspenseObserver } from \"~/components/suspenseObserver\";\nimport type { ViewSelectionProps } from \"~/hooks/selection/GroupedViewSelectionTypes\";\nimport { useWithinNavigationStack } from \"~/hooks/useWithinNavigationStack\";\nimport { Issue } from \"~/models/Issue\";\nimport { resolvePromises } from \"~/models/hydration/resolvePromise\";\nimport { useGroupedViewSelectionActions } from \"~/hooks/selection/useGroupedViewSelectionActionsNew\";\nimport { IssueWidget } from \"../IssueWidget/IssueWidget\";\nimport { listColumnStyles, useListColumnWidths } from \"./components/ListColumn\";\n\nimport type { IssueListGroupDivider } from \"./components/IssueListGroupDivider\";\nimport { IssueListGroupRow } from \"./components/IssueListGroupRow\";\nimport { type ListItemRendererProps, ListCell } from \"./components/ListCellNew\";\n\n/** Props for List component */\nexport type ListProps = {\n  /** The data provider for the list or a function that generates the data provider. */\n  provider: AnyGroupedDataProvider;\n  /** Empty state component. Displays while the list is empty and not loading */\n  emptyPlaceholder: React.ReactNode;\n  /** Optional flag to indicate if data is loading.  */\n  loading?: boolean;\n  /**\n   * Called when items are rendered. `lastItem` is the key of the last visible item. Debounced to avoid excessive calls.\n   */\n  onItemsRendered?(lastItem: GroupedViewItemKey): void;\n  /**\n   * Is the list rendered in a split view?\n   * This changes the behaviour of the list in a few ways â€”\n   * clicks and hover specifically works differently.\n   */\n  splitView?: boolean;\n  /**\n   * If set the list will activate and scroll to item with the given key.\n   */\n  initialActiveItemKey?: string;\n  /** Optional header element */\n  header?: React.ReactNode;\n  /** Ref to access methods from the navigation state */\n  navigationStateRef?: React.RefObject<ListNavigationRef>;\n  /** Whether list cell should handle long press. Defaults to false */\n  withLongPress?: boolean;\n  /** Optional dependencies that when changed will re-calculate the column widths */\n  columnWidthsDeps?: unknown[];\n} & Pick<ViewSelectionProps, \"onLeaveList\">;\n\n/**\n * Page-size virtualized list component, that has support for selection, navigating between items etc. Driven by `GroupedDataProvider`.\n */\nexport const List = suspenseObserver(\n  React.forwardRef(function List_(props: ListProps, outerRef: React.RefObject<HTMLDivElement>) {\n    const { provider, emptyPlaceholder, onItemsRendered, loading, header, columnWidthsDeps = [] } = props;\n\n    if (provider.hydrate) {\n      resolvePromises(provider.hydrate());\n    }\n\n    const itemsKey = React.useMemo(\n      () =>\n        provider.groupCounts.reduce(\n          (memo, _, index) => memo + provider.modelsForGroup(index).reduce((memo2, model) => memo2 + model.id, \"\"),\n          \"\"\n        ),\n      [provider]\n    );\n\n    const rows = React.useMemo(() => {\n      return groupCountsToRows(provider.groupCounts);\n    }, [provider.groupCounts.map(x => x.toString()).join(\"\")]);\n\n    const isWithinNavigationStack = useWithinNavigationStack();\n    const innerRef = React.useRef<HTMLDivElement>(null);\n    const finalRef = outerRef || innerRef;\n    const height = useComponentHeight(finalRef) || window.innerHeight;\n    const location = useLocation();\n    const [highlightEnabled, setHighlightEnabled] = React.useState(false);\n\n    const outerScrollContainerRef = React.useRef<HTMLDivElement>();\n\n    const scrollbarOffset = outerScrollContainerRef.current\n      ? outerScrollContainerRef.current.offsetWidth - outerScrollContainerRef.current.clientWidth\n      : undefined;\n\n    // Get widths for columns rendered in the list\n    const [widths, handleColumnWidthsUpdate] = useListColumnWidths(\n      finalRef,\n      [itemsKey, provider.viewPreferences?.serializedSettings],\n      [location.pathname, ...columnWidthsDeps],\n      scrollbarOffset\n    );\n\n    const handleItemsRendered = React.useMemo(\n      () =>\n        debounce((lastItem: GroupedViewItemKey) => {\n          handleColumnWidthsUpdate();\n          onItemsRendered?.(lastItem);\n        }, 50),\n      [onItemsRendered, scrollbarOffset]\n    );\n\n    // Handle the case where we're coming out of the navigation stack and there's no overflow.\n    // Then handleItemsRendered and thus handleColumnWidthsUpdate would't be called when the list is rendered, so widths wouldn't be calculated.\n    React.useLayoutEffect(() => {\n      if (!isWithinNavigationStack && Object.keys(widths).length === 0) {\n        handleColumnWidthsUpdate();\n      }\n    }, [isWithinNavigationStack]);\n\n    const hasAnyActualRows = rows.some(([, indexInGroup]) => indexInGroup !== -1);\n    const displayEmptyState = !hasAnyActualRows && !loading;\n\n    const data = React.useMemo(() => {\n      const items: GroupedViewItem<ProviderItem>[] = [];\n      for (let i = 0; i < provider.groupCounts.length; i++) {\n        const modelsInGroup = provider.modelsForGroup(i);\n        const groupHeader = provider.modelForGroup(i);\n        if (groupHeader) {\n          items.push({\n            key: groupHeader.id as GroupedViewItemKey,\n            interactive: false,\n            textContent: \"\",\n            data: groupHeader,\n            subItems: modelsInGroup.map(model => ({\n              key: model.id as GroupedViewItemKey,\n              textContent: \"\",\n              interactive: true,\n              data: model,\n            })),\n          });\n        }\n      }\n      return items;\n    }, [provider]);\n    const viewState = useGroupedViewState(data);\n    useGroupedViewSelectionActions({ viewState, isDisabled: isWithinNavigationStack });\n\n    // TODO update this, probably pull out to own hook.\n    const activeItemRef = useAsRef(viewState.activeItem);\n    const history = useHistory();\n    useKeyPressEvent(KeyboardHelper.isEnter, () => {\n      if (activeItemRef.current) {\n        const path = GroupedViewItemHelper.getPathForItem(data, activeItemRef.current);\n        if (path) {\n          const pathname = provider.path({ groupIndex: path[0], indexInGroup: path[1] });\n          if (!pathname) {\n            return;\n          }\n          const existingHistoryState = { ...(history.location.state || {}) };\n          delete existingHistoryState.favoriteId;\n          const newHistoryState = { ...existingHistoryState };\n\n          typeof pathname === \"string\" ? history.push({ pathname, state: newHistoryState }) : history.push(pathname);\n          provider.handleNavigateToItem?.({ groupIndex: path[0], indexInGroup: path[1] });\n        }\n      }\n    });\n\n    const [scrolling, setScrolling] = React.useState(false);\n\n    const onScroll = React.useCallback(() => {\n      finalRef.current?\n      let scrollTimeout = setTimeout(() => {\n        setScrolling(false);\n      }, 30);\n      const lastRenderedElement = finalRef.current?.querySelectorAll(\"[data-list-key]\");\n      const key = lastRenderedElement?.[lastRenderedElement.length - 1]?.getAttribute(\n        \"data-list-key\"\n      ) as GroupedViewItemKey | null;\n      if (key) {\n        handleItemsRendered(key);\n      }\n      return () => {\n        clearTimeout(scrollTimeout);\n      };\n    }, []);\n\n    if (displayEmptyState) {\n      return <>{emptyPlaceholder}</>;\n    }\n    return (\n      <OuterContainer $disableMinWidth={props.splitView || false}>\n        <Container\n          ref={finalRef}\n          auto\n          column\n          grow={1}\n          $widths={widths}\n          onMouseMove={() => setHighlightEnabled(true)}\n          onClick={() => {\n            // De-select items when clicking on the list empty space, but not on an item\n            viewState.deactivate();\n          }}\n        >\n          {header}\n          <ListContainer $highlightEnabled={highlightEnabled} $scrolling={scrolling}>\n            <GroupedViewDataContext.Provider value={{ state: viewState, data, provider }}>\n              <GroupedList\n                data={data}\n                height={height}\n                heightPerLevel={[36, 44]}\n                stickyHeaderLevels={1}\n                overscan={500}\n                onScroll={onScroll}\n                itemComponent={ListItem}\n              />\n            </GroupedViewDataContext.Provider>\n          </ListContainer>\n        </Container>\n      </OuterContainer>\n    );\n  })\n);\n\nfunction ListItem(props: ListCellProps<Issue | IssueListGroupDivider>) {\n  // TODO generalize\n  const { item, path, style } = props;\n  const { data } = item;\n  return (\n    <ListCell\n      style={style}\n      item={item}\n      legacyItem={{ groupIndex: path[0], indexInGroup: path[1] ?? -1 }}\n      childComponent={\n        (data instanceof Issue\n          ? IssueWidget\n          : IssueListGroupRow) as unknown as React.ComponentType<ListItemRendererProps>\n      }\n    />\n  );\n}\n\n/** Ref to access select parts of the list navigation controls. Used for external components when they need to manipulate selection, active items etc. */\ntype ListNavigationRef = Pick<ListItemData, \"clearSelection\" | \"deactivateItem\" | \"activateItem\" | \"getActiveItem\">;\n\nconst OuterContainer = styled.div<{ $disableMinWidth: boolean }>`\n  overflow-x: auto;\n  flex-grow: 1;\n  ${props => (props.$disableMinWidth ? \"\" : \"min-width: 575px;\")}\n  ${screenSize.laptop} {\n    min-width: auto;\n  }\n`;\n\nconst Container = styled(Flex)<{ $widths: Record<string, number> }>`\n  height: 100%;\n  overflow: hidden;\n  width: 100%;\n  ${listColumnStyles}\n`;\n\nconst ListContainer = styled.div<{ $highlightEnabled: boolean; $scrolling: boolean }>`\n  --element-hover-color: ${props => (props.$highlightEnabled ? props.theme.color.bgBaseHover : \"inherit\")};\n  --a-pointer-events: ${props => (props.$scrolling ? \"none\" : \"initial\")};\n  --a-bg: ${props => (props.$scrolling ? \"red\" : \"transparent\")};\n  background-color: ${color(\"bgBase\")};\n  &:focus {\n    outline: none;\n  }\n  a {\n    pointer-events: var(--a-pointer-events);\n    background-color: var(--a-bg);\n  }\n`;\n```\ndiagnostics: linear-app/client/src/components/List/ListNew.tsx\n```tsx\n    const onScroll = React.useCallback(() => {\n      finalRef.current?\n      let scrollTimeout = setTimeout(() => {\n// error: Cannot find name 'let'.\n        setScrolling(false);\n      }, 30);\n```\n```tsx\n    const onScroll = React.useCallback(() => {\n      finalRef.current?\n      let scrollTimeout = setTimeout(() => {\n// error: Parsing error: ':' expected.\n        setScrolling(false);\n      }, 30);\n```\n```tsx\n    const onScroll = React.useCallback(() => {\n      finalRef.current?\n      let scrollTimeout = setTimeout(() => {\n// error: ':' expected.\n        setScrolling(false);\n      }, 30);\n```\n```tsx\n    const onScroll = React.useCallback(() => {\n      finalRef.current?\n      let scrollTimeout = setTimeout(() => {\n// error: Cannot find name 'scrollTimeout'.\n        setScrolling(false);\n      }, 30);\n```\n```tsx\n      }\n      return () => {\n        clearTimeout(scrollTimeout);\n// error: Cannot find name 'scrollTimeout'.\n      };\n    }, []);\n```\n```tsx\n    const onScroll = React.useCallback(() => {\n      finalRef.current?\n      let scrollTimeout = setTimeout(() => {\n// error: Cannot find name 'let'.\n        setScrolling(false);\n      }, 30);\n```\n```tsx\n    const onScroll = React.useCallback(() => {\n      finalRef.current?\n      let scrollTimeout = setTimeout(() => {\n// error: Parsing error: ':' expected.\n        setScrolling(false);\n      }, 30);\n```\n```tsx\n    const onScroll = React.useCallback(() => {\n      finalRef.current?\n      let scrollTimeout = setTimeout(() => {\n// error: ':' expected.\n        setScrolling(false);\n      }, 30);\n```\n```tsx\n    const onScroll = React.useCallback(() => {\n      finalRef.current?\n      let scrollTimeout = setTimeout(() => {\n// error: Cannot find name 'scrollTimeout'.\n        setScrolling(false);\n      }, 30);\n```\n```tsx\n      }\n      return () => {\n        clearTimeout(scrollTimeout);\n// error: Cannot find name 'scrollTimeout'.\n      };\n    }, []);\n```\n\nset a css variable, \"--a-bg\", on finalRef.current on scroll. emove when scrolling stops\nTo set a CSS variable on `finalRef.current` during scroll and remove it when scrolling stops, you can modify the `onScroll` function as follows:\n\n```typescript\nconst onScroll = React.useCallback(() => {\n  if (finalRef.current) {\n    finalRef.current.style.setProperty('--a-bg', 'red');\n    setScrolling(true);\n\n    const scrollTimeout = setTimeout(() => {\n      setScrolling(false);\n      if (finalRef.current) {\n        finalRef.current.style.removeProperty('--a-bg');\n      }\n    }, 30);\n\n    return () => {\n      clearTimeout(scrollTimeout);\n    };\n  }\n}, []);\n```\n\nThis modification:\n\n1. Sets the `--a-bg` CSS variable to 'red' when scrolling starts.\n2. Uses `setScrolling(true)` to indicate that scrolling has started.\n3. Sets a timeout to remove the CSS variable and set `scrolling` to false after 30ms of inactivity.\n4. Clears the timeout if the component unmounts or if another scroll event occurs before the timeout completes.\n\nAlso, make sure to update the styled component to use this variable:\n\n```typescript\nconst ListContainer = styled.div<{ $highlightEnabled: boolean; $scrolling: boolean }>`\n  // ... other styles ...\n  a {\n    pointer-events: ${props => (props.$scrolling ? \"none\" : \"initial\")};\n    background-color: var(--a-bg, transparent);\n  }\n`;\n```\n\nThis change will set the background color to red during scrolling and revert to transparent when scrolling stops, while also disabling pointer events during scrolling.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":100}},"image_offsets":[]},{"id":{"replica_id":0,"value":38},"start":13367,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":101}},"image_offsets":[]},{"id":{"replica_id":0,"value":39},"start":14808,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":102}},"image_offsets":[]}],"summary":"List component with grouped view and scrolling behavior","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":13278},"icon":"File","label":"linear-app/client/src/components/List/ListNew.tsx"},{"range":{"start":11289,"end":13278},"icon":"ExclamationTriangle","label":"Diagnostics (linear-app/client/src/components/List/ListNew.tsx): 5 errors"},{"range":{"start":11352,"end":11555},"icon":"XCircle","label":"Cannot find name 'let'."},{"range":{"start":11556,"end":11764},"icon":"XCircle","label":"Parsing error: ':' expected."},{"range":{"start":11765,"end":11958},"icon":"XCircle","label":"':' expected."},{"range":{"start":11959,"end":12172},"icon":"XCircle","label":"Cannot find name 'scrollTimeout'."},{"range":{"start":12173,"end":12314},"icon":"XCircle","label":"Cannot find name 'scrollTimeout'."},{"range":{"start":12315,"end":12518},"icon":"XCircle","label":"Cannot find name 'let'."},{"range":{"start":12519,"end":12727},"icon":"XCircle","label":"Parsing error: ':' expected."},{"range":{"start":12728,"end":12921},"icon":"XCircle","label":"':' expected."},{"range":{"start":12922,"end":13135},"icon":"XCircle","label":"Cannot find name 'scrollTimeout'."},{"range":{"start":13136,"end":13277},"icon":"XCircle","label":"Cannot find name 'scrollTimeout'."}]}