{"id":"b7c64a26-f14e-4a53-a2e1-aa06c62c9648","zed":"context","version":"0.4.0","text":"\n\n\n```ts linear-app/orbiter/src/components/useGroupedViewState.ts\nimport * as  React from \"react\";\nimport { GroupedViewItem, GroupedListRef } from \"./GroupedList\";\nimport { action, makeObservable, observable } from \"mobx\";\n\nexport function useGroupedViewState<T>(listId: string, data: GroupedViewItem<T>[], listRef: React.RefObject<GroupedListRef>) {\n  const [state, setState] = React.useState(() => new GroupedViewState({ data }))\n  React.useEffect(() => {\n    function keyListener(event: KeyboardEvent) {\n      if (event.key === \"ArrowDown\") {\n        console.log(\"ArrowDown\");\n        state.updateState({ type: \"moveActive\", payload: { direction: Direction.DownRight } });\n      } else if (event.key === \"ArrowUp\") {\n        console.log(\"ArrowUp\");\n      }\n    }\n    listRef.current?.domRef.current?.addEventListener(\"keypress\", keyListener)\n  }, []);\n\n  React.useEffect(() => {\n    // TODO: Update state when data changes isntead of replace\n    setState(new GroupedViewState({ data }))\n  }, [data])\n\n  return state;\n}\n\n\nclass GroupedViewState {\n  constructor(options: { initialActiveItem?: PathToItem, data: GroupedViewItem<unknown>[] }) {\n    if (options.initialActiveItem) {\n      this.activeItem = options.initialActiveItem;\n    }\n    if (options.data) {\n      this.data = options.data;\n    }\n    makeObservable(this, {\n      updateState: action,\n      activeItem: observable,\n      focusedItem: observable,\n      keyboardActive: observable,\n      initialSelectedItem: observable,\n      selectedItems: observable,\n      navigationDirection: observable,\n    });\n  }\n  public focusedItem: PathToItem | null = null;\n  public activeItem: PathToItem | null = null;\n  public previouslyActiveItem: PathToItem | null = null;\n  public keyboardActive: boolean = false;\n  public initialSelectedItem: PathToItem | null = null;\n  public selectedItems: PathToItem[] = [];\n  public navigationDirection: Direction = Direction.DownRight;\n\n  public updateState(action: GroupedViewAction): void {\n    switch (action.type) {\n      case \"moveActive\":\n        this.moveActive(action.payload);\n        break;\n      case \"activate\":\n        this.activate(action.payload);\n        break;\n      case \"addToSelection\":\n        this.addToSelection(action.payload);\n        break;\n      case \"tabPress\":\n        this.handleTabPress(action.payload);\n        break;\n      case \"select\":\n        this.select(action.payload);\n        break;\n      case \"selectBetween\":\n        this.selectBetween(action.payload);\n        break;\n      case \"deactivate\":\n        this.deactivate();\n        break;\n      case \"focus\":\n        this.focus(action.payload);\n        break;\n      case \"navigateToActive\":\n        // This action might require external handling\n        break;\n      case \"clearSelection\":\n        this.clearSelection();\n        break;\n      case \"shiftSelect\":\n        this.shiftSelect(action.payload);\n        break;\n      case \"cmdSelect\":\n        this.cmdSelect(action.payload);\n        break;\n      case \"selectAllInGroup\":\n        this.selectAllInGroup(action.payload);\n        break;\n      case \"selectAll\":\n        this.selectAll();\n        break;\n      case \"goToEnd\":\n        this.goToEnd();\n        break;\n      case \"goToStart\":\n        this.goToStart();\n        break;\n      case \"clearKeyboardActive\":\n        this.clearKeyboardActive();\n        break;\n      case \"setKeyboardActive\":\n        this.setKeyboardActive();\n        break;\n      case \"activateNextAvailableItem\":\n        this.activateNextAvailableItem(action.payload);\n        break;\n      case \"openSelectionInTabs\":\n        // This action might require external handling\n        break;\n      default:\n        console.warn(\"Unhandled action type:\", (action as any).type);\n    }\n  }\n\n  private moveActive(payload: { direction: Direction; toEnd?: boolean; navigate?: boolean; shouldClearSelection?: boolean; isDebounced?: boolean; isPending?: boolean }) {\n    ·\n  }\n\n  private activate(payload: { item: PathToItem; keyboardActive: boolean; navigate?: boolean | \"refresh\"; shouldClearSelection?: boolean; maintainDirection?: boolean }) {\n    this.activeItem = payload.item;\n    this.keyboardActive = payload.keyboardActive;\n    if (payload.shouldClearSelection) {\n      this.selectedItems = [];\n    }\n  }\n\n  private addToSelection(payload: { direction: Direction; selectActiveItemImmediately?: boolean }) {\n    // Implement add to selection logic\n  }\n\n  private handleTabPress(event: React.KeyboardEvent | KeyboardEvent) {\n    // Implement tab press logic\n  }\n\n  private select(items: PathToItem[]) {\n    this.selectedItems = items;\n    if (items.length > 0) {\n      this.activeItem = items[0];\n      this.focusedItem = items[0];\n    }\n  }\n\n  private selectBetween(items: [PathToItem, PathToItem]) {\n    // Implement select between logic\n    const [start, end] = items;\n    const startIndex = this.selectedItems.findIndex(item => item === start);\n    const endIndex = this.selectedItems.findIndex(item => item === end);\n\n    if (startIndex !== -1 && endIndex !== -1) {\n      const selectedRange = this.selectedItems.slice(\n        Math.min(startIndex, endIndex),\n        Math.max(startIndex, endIndex) + 1\n      );\n      this.selectedItems = selectedRange;\n    } else {\n      // If either start or end is not in the current selection, select just these two items\n      this.selectedItems = [start, end];\n    }\n\n    this.activeItem = end;\n    this.focusedItem = end;\n  }\n\n  private deactivate() {\n    this.previouslyActiveItem = this.activeItem;\n    this.activeItem = null;\n    this.keyboardActive = false;\n  }\n\n  private focus(payload: { item: PathToItem }) {\n    this.focusedItem = payload.item;\n    this.activeItem = payload.item;\n    this.keyboardActive = true;\n  }\n\n  private clearSelection() {\n    this.selectedItems = [];\n    this.focusedItem = null;\n    this.keyboardActive = false;\n  }\n\n  private shiftSelect(item?: PathToItem) {\n    const startShiftSelectItem = item ?? this.activeItem;\n    if (!startShiftSelectItem) {\n      return;\n    }\n\n    this.previouslyActiveItem = null;\n    this.initialSelectedItem = this.initialSelectedItem || startShiftSelectItem;\n    this.activeItem = startShiftSelectItem;\n    this.focusedItem = startShiftSelectItem;\n\n    if (this.initialSelectedItem) {\n      this.selectedItems = this.getItemsBetween(\n        startShiftSelectItem,\n        this.initialSelectedItem\n      );\n    } else {\n      this.selectedItems = [startShiftSelectItem];\n    }\n  }\n\n  private cmdSelect(item?: PathToItem) {\n    const startCmdSelectItem = item ?? this.activeItem;\n    if (!startCmdSelectItem || this.multiSelectDisabled) {\n      return;\n    }\n\n    const oldSelectedItems = this.isSplitView && this.activeItem\n      ? this.uniqueItems([...this.selectedItems, this.activeItem])\n      : this.selectedItems;\n\n    if (this.isItemInSelection(startCmdSelectItem, oldSelectedItems)) {\n      const selectedItems = oldSelectedItems.filter(i => !this.areItemsEqual(i, startCmdSelectItem));\n      if (selectedItems.length > 0) {\n        this.focusedItem = selectedItems[selectedItems.length - 1];\n        this.selectedItems = selectedItems;\n      } else {\n        this.focusedItem = null;\n        this.initialSelectedItem = null;\n        this.selectedItems = [];\n      }\n    } else {\n      this.activeItem = startCmdSelectItem;\n      this.focusedItem = startCmdSelectItem;\n      this.initialSelectedItem = startCmdSelectItem;\n      this.selectedItems = [...oldSelectedItems, startCmdSelectItem].sort(this.itemSort);\n    }\n  }\n\n  private selectAllInGroup(payload: PathToItem) {\n    let pathToItems: PathToItem[] = []\n    let rootItem = this.getItemForPath(payload);\n    if (!rootItem?.subItems) {\n      return;\n    }\n    function selectAllItems(items: GroupedViewItem<unknown>[], parentPath: PathToItem = []) {\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const path = [...parentPath, i];\n        pathToItems.push(path);\n        if (item.subItems) {\n          selectAllItems(item.subItems, path);\n        }\n      }\n    }\n    selectAllItems(rootItem.subItems, payload);\n    this.selectedItems = pathToItems;\n  }\n\n  private getItemForPath(payload: PathToItem): GroupedViewItem<unknown> | null {\n    let items = this.data;\n    for (const index of payload) {\n      if (items[index] && items[index].subItems) {\n        items = items[index].subItems;\n      } else {\n        return items[index] ?? null;\n      }\n    }\n    return null\n  }\n\n\n  private selectAll() {\n    let pathToItems: PathToItem[] = []\n    function selectAllItems(items: GroupedViewItem<unknown>[], parentPath: PathToItem = []) {\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const path = [...parentPath, i];\n        pathToItems.push(path);\n        if (item.subItems) {\n          selectAllItems(item.subItems, path);\n        }\n      }\n    }\n    selectAllItems(this.data);\n    this.selectedItems = pathToItems;\n  }\n\n  private goToEnd() {\n    // TODO, this requires actual data, which isn't added yet\n  }\n\n  private goToStart() {\n    // TODO, this requires actual data, which isn't added yet\n  }\n\n  private uniqueItems(items: PathToItem[]): PathToItem[] {\n    return items.filter((item, index, self) =>\n      index === self.findIndex((t) => this.areItemsEqual(t, item))\n    );\n  }\n\n  private isItemInSelection(item: PathToItem, selection: PathToItem[]): boolean {\n    return selection.some(selectedItem => this.areItemsEqual(selectedItem, item));\n  }\n\n  private areItemsEqual(a: PathToItem, b: PathToItem): boolean {\n    return a.length === b.length && a.every((value, index) => value === b[index]);\n  }\n\n  private itemSort(a: PathToItem, b: PathToItem): number {\n    for (let i = 0; i < Math.min(a.length, b.length); i++) {\n      if (a[i] !== b[i]) return a[i] - b[i];\n    }\n    return a.length - b.length;\n  }\n\n  private getItemsBetween(from: PathToItem, to: PathToItem): PathToItem[] {\n    // This is a simplified version. You'll need to implement the full logic\n    // based on your specific data structure and requirements.\n    const start = Math.min(from[0], to[0]);\n    const end = Math.max(from[0], to[0]);\n    const items: PathToItem[] = [];\n\n    for (let i = start; i <= end; i++) {\n      items.push([i]);\n    }\n\n    return items;\n  }\n\n  private clearKeyboardActive() {\n    this.keyboardActive = false;\n  }\n\n  private setKeyboardActive() {\n    this.keyboardActive = true;\n  }\n\n  private activateNextAvailableItem(item: PathToItem) {\n    // Implement activate next available item logic\n  }\n  /* How many dimensions are displayed in the view. Boards have two, lists only one.  */\n  private dimensions: number;\n  /* is it possible to multi-select. */\n  private multiSelectDisabled: boolean = false;\n  /**\n   * Is the view a split view. This affects some activation & selection behaviour.\n   * TODO: Maybe remove\n   */\n  private isSplitView: boolean = false;\n  /** THe data displayed in the view. TODO: Maybe replace with provider. */\n  private data: GroupedViewItem<unknown>[] = []\n}\n\ntype PathToItem = number[];\n\n// Combined direction for moving active/selection. Up/Down for vertical, Left/Right for horizontal.\nexport const Direction = {\n  UpLeft: \"up/left\",\n  DownRight: \"down/right\",\n} as const;\nexport type Direction = (typeof Direction)[keyof typeof Direction];\n\n\n\n/**\n * Actions for controlling view selection\n */\nexport type GroupedViewAction =\n  | {\n    // Move the active item in a given direction. If we're at the end of the dimension, the active doesn't move.\n    type: \"moveActive\";\n    payload: {\n      direction: Direction;\n      toEnd?: boolean;\n      navigate?: boolean;\n      shouldClearSelection?: boolean;\n      isDebounced?: boolean;\n      isPending?: boolean;\n    };\n  }\n  | {\n    // Activate a specific item. Used for hovering the list, pressing up/down on keyboard etc.\n    type: \"activate\";\n    payload: {\n      item: PathToItem;\n      keyboardActive: boolean;\n      navigate?: boolean | \"refresh\";\n      shouldClearSelection?: boolean;\n      maintainDirection?: boolean;\n    };\n  }\n  | {\n    // Add an item to the selection.\n    type: \"addToSelection\"; payload: {\n      direction: Direction;\n      /**\n      * If no item is selected but there's an active item, this flag controls wether to select both the active and the next item,\n      * or just the active item.\n      */\n      selectActiveItemImmediately?: boolean\n    }\n  }\n  | {\n    // Moves the active & focused item one step.\n    type: \"tabPress\"; payload: React.KeyboardEvent | KeyboardEvent\n  }\n  | { type: \"select\"; payload: PathToItem[]; allowWithInPageFind?: boolean }\n  | { type: \"selectBetween\"; payload: [PathToItem, PathToItem] }\n  | { type: \"deactivate\"; allowWithInPageFind?: boolean }\n  | { type: \"focus\"; payload: { item: PathToItem } }\n  | { type: \"navigateToActive\"; payload: { replace: boolean } }\n  | { type: \"clearSelection\" }\n  | { type: \"shiftSelect\"; payload?: PathToItem }\n  | { type: \"cmdSelect\"; payload?: PathToItem }\n  | { type: \"selectAllInGroup\"; payload: PathToItem }\n  | { type: \"selectAll\" }\n  | { type: \"goToEnd\" }\n  | { type: \"goToStart\" }\n  | { type: \"clearKeyboardActive\" }\n  | { type: \"setKeyboardActive\" }\n  | { type: \"activateNextAvailableItem\"; payload: PathToItem }\n  | { type: \"openSelectionInTabs\" };\n```\ndiagnostics: linear-app/orbiter/src/components/useGroupedViewState.ts\n```typescript\n\n  private moveActive(payload: { direction: Direction; toEnd?: boolean; navigate?: boolean; shouldClearSelection?: boolean; isDebounced?: boolean; isPending?: boolean }) {\n    ·\n// error: Invalid character.\n  }\n\n```\n\nImplement moveActive. For now, you can assume all items is rendered in a nested list. For example if [1,4,3] is the path to the last item in group [1,4], then moving down would take you to [1,5] (assuming that item exists).\nThank you for providing the context. I'll implement the `moveActive` method based on your requirements. Here's an implementation that assumes items are rendered in a nested list:\n\n```typescript\nprivate moveActive(payload: { direction: Direction; toEnd?: boolean; navigate?: boolean; shouldClearSelection?: boolean; isDebounced?: boolean; isPending?: boolean }) {\n  if (!this.activeItem) {\n    // If no active item, activate the first item\n    this.activeItem = [0];\n    return;\n  }\n\n  const newActiveItem = this.findNextItem(this.activeItem, payload.direction, payload.toEnd);\n\n  if (newActiveItem) {\n    this.activeItem = newActiveItem;\n    this.focusedItem = newActiveItem;\n    this.keyboardActive = true;\n\n    if (payload.shouldClearSelection) {\n      this.selectedItems = [];\n    }\n\n    // You might want to implement navigation logic here if payload.navigate is true\n  }\n}\n\nprivate findNextItem(currentItem: PathToItem, direction: Direction, toEnd: boolean = false): PathToItem | null {\n  const lastIndex = currentItem.length - 1;\n  const parentPath = currentItem.slice(0, -1);\n  const currentIndex = currentItem[lastIndex];\n\n  if (direction === Direction.DownRight) {\n    if (toEnd) {\n      return this.findLastItem(parentPath);\n    }\n\n    // Try to go to the first child of the current item\n    const firstChild = this.getFirstChild(currentItem);\n    if (firstChild) return firstChild;\n\n    // Try to go to the next sibling\n    const nextSibling = this.getNextSibling(currentItem);\n    if (nextSibling) return nextSibling;\n\n    // Go up and find the next available item\n    return this.findNextAvailableItem(parentPath);\n  } else { // Direction.UpLeft\n    if (toEnd) {\n      return this.findFirstItem();\n    }\n\n    if (currentIndex > 0) {\n      // Go to the previous sibling's last descendant\n      const previousSibling = [...parentPath, currentIndex - 1];\n      return this.findLastDescendant(previousSibling);\n    }\n\n    // If we're at the first child, go to the parent\n    return parentPath.length > 0 ? parentPath : null;\n  }\n}\n\nprivate getFirstChild(path: PathToItem): PathToItem | null {\n  const item = this.getItemForPath(path);\n  return item && item.subItems && item.subItems.length > 0 ? [...path, 0] : null;\n}\n\nprivate getNextSibling(path: PathToItem): PathToItem | null {\n  const parentPath = path.slice(0, -1);\n  const currentIndex = path[path.length - 1];\n  const parentItem = this.getItemForPath(parentPath);\n  \n  if (parentItem && parentItem.subItems && currentIndex < parentItem.subItems.length - 1) {\n    return [...parentPath, currentIndex + 1];\n  }\n  \n  return null;\n}\n\nprivate findNextAvailableItem(path: PathToItem): PathToItem | null {\n  if (path.length === 0) return null;\n\n  const parentPath = path.slice(0, -1);\n  const currentIndex = path[path.length - 1];\n  const nextSibling = this.getNextSibling(path);\n\n  if (nextSibling) return nextSibling;\n\n  return this.findNextAvailableItem(parentPath);\n}\n\nprivate findLastItem(path: PathToItem): PathToItem {\n  const item = this.getItemForPath(path);\n  if (item && item.subItems && item.subItems.length > 0) {\n    return this.findLastItem([...path, item.subItems.length - 1]);\n  }\n  return path;\n}\n\nprivate findFirstItem(): PathToItem {\n  return [0];\n}\n\nprivate findLastDescendant(path: PathToItem): PathToItem {\n  const item = this.getItemForPath(path);\n  if (item && item.subItems && item.subItems.length > 0) {\n    return this.findLastDescendant([...path, item.subItems.length - 1]);\n  }\n  return path;\n}\n```\n\nThis implementation does the following:\n\n1. If there's no active item, it activates the first item.\n2. It uses a helper method `findNextItem` to determine the next item based on the current active item and the direction.\n3. When moving down/right:\n   - It first tries to go to the first child of the current item.\n   - If there's no child, it tries to go to the next sibling.\n   - If there's no next sibling, it goes up the tree to find the next available item.\n4. When moving up/left:\n   - It goes to the previous sibling's last descendant.\n   - If it's already at the first child, it goes to the parent.\n5. It handles the `toEnd` flag by finding the last or first item in the list.\n6. It updates the `activeItem`, `focusedItem`, and `keyboardActive` properties.\n7. It clears the selection if `shouldClearSelection` is true.\n\nNote that this implementation assumes that the `getItemForPath` method is correctly implemented to return the item at a given path. You might need to adjust some details based on your specific data structure and requirements.\nImplement firstInteractiveItem\nCertainly! The `firstInteractiveItem` method should find the first item in the grouped view that can be interacted with. This is typically the first non-disabled item in the list. Here's an implementation of `firstInteractiveItem` that you can add to your `GroupedViewState` class:\n\n```typescript\nprivate firstInteractiveItem(): PathToItem | null {\n  return this.findFirstInteractiveItem(this.data);\n}\n\nprivate findFirstInteractiveItem(items: GroupedViewItem<unknown>[], currentPath: PathToItem = []): PathToItem | null {\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const path = [...currentPath, i];\n\n    // Check if the current item is interactive (not disabled)\n    if (!item.disabled) {\n      return path;\n    }\n\n    // If the item has subitems, recursively search them\n    if (item.subItems && item.subItems.length > 0) {\n      const interactiveSubItem = this.findFirstInteractiveItem(item.subItems, path);\n      if (interactiveSubItem) {\n        return interactiveSubItem;\n      }\n    }\n  }\n\n  // If no interactive item is found, return null\n  return null;\n}\n```\n\nThis implementation does the following:\n\n1. The `firstInteractiveItem` method serves as the entry point and starts the search from the root of the data.\n\n2. The `findFirstInteractiveItem` method does the actual recursive search:\n   - It iterates through the items at the current level.\n   - For each item, it first checks if the item is not disabled. If it's not disabled, it returns the path to this item.\n   - If the current item is disabled but has subitems, it recursively searches the subitems.\n   - If no interactive item is found at the current level or in any subitems, it returns null.\n\n3. The method builds the path to each item as it traverses the tree structure.\n\n4. It returns the path to the first non-disabled item it finds, or null if no such item exists.\n\nYou can use this method in various scenarios, such as:\n\n- When initializing the view, to set the initial active item:\n\n```typescript\nconstructor(options: { initialActiveItem?: PathToItem, data: GroupedViewItem<unknown>[] }) {\n  // ...existing code...\n  \n  if (!this.activeItem) {\n    this.activeItem = this.firstInteractiveItem();\n  }\n}\n```\n\n- In the `moveActive` method, when there's no current active item:\n\n```typescript\nprivate moveActive(payload: { direction: Direction; toEnd?: boolean; navigate?: boolean; shouldClearSelection?: boolean; isDebounced?: boolean; isPending?: boolean }) {\n  if (!this.activeItem) {\n    const firstItem = this.firstInteractiveItem();\n    if (firstItem) {\n      this.activeItem = firstItem;\n      this.focusedItem = firstItem;\n      this.keyboardActive = true;\n    }\n    return;\n  }\n  \n  // ... rest of the moveActive implementation ...\n}\n```\n\nThis implementation ensures that the view always starts with or moves to an item that can be interacted with, improving the user experience by avoiding disabled or non-interactive items.\nimplement findLastInteractiveItem\nCertainly! Here's an implementation of `findLastInteractiveItem` that finds the last interactive (non-disabled) item in the grouped view:\n\n```typescript\nprivate lastInteractiveItem(): PathToItem | null {\n  return this.findLastInteractiveItem(this.data);\n}\n\nprivate findLastInteractiveItem(items: GroupedViewItem<unknown>[], currentPath: PathToItem = []): PathToItem | null {\n  for (let i = items.length - 1; i >= 0; i--) {\n    const item = items[i];\n    const path = [...currentPath, i];\n\n    // If the item has subitems, recursively search them first\n    if (item.subItems && item.subItems.length > 0) {\n      const interactiveSubItem = this.findLastInteractiveItem(item.subItems, path);\n      if (interactiveSubItem) {\n        return interactiveSubItem;\n      }\n    }\n\n    // Check if the current item is interactive (not disabled)\n    if (!item.disabled) {\n      return path;\n    }\n  }\n\n  // If no interactive item is found, return null\n  return null;\n}\n```\n\nThis implementation is similar to `findFirstInteractiveItem`, but with a few key differences:\n\n1. The `lastInteractiveItem` method serves as the entry point and starts the search from the root of the data.\n\n2. The `findLastInteractiveItem` method does the actual recursive search:\n   - It iterates through the items at the current level in reverse order (from last to first).\n   - For each item, it first checks if the item has subitems. If it does, it recursively searches the subitems first. This ensures we find the last interactive item in the deepest level.\n   - If no interactive item is found in the subitems (or there are no subitems), it checks if the current item is not disabled. If it's not disabled, it returns the path to this item.\n   - If no interactive item is found at the current level or in any subitems, it returns null.\n\n3. The method builds the path to each item as it traverses the tree structure.\n\n4. It returns the path to the last non-disabled item it finds, or null if no such item exists.\n\nYou can use this method in various scenarios, such as:\n\n- In the `goToEnd` method:\n\n```typescript\nprivate goToEnd() {\n  const lastItem = this.lastInteractiveItem();\n  if (lastItem) {\n    this.activeItem = lastItem;\n    this.focusedItem = lastItem;\n    this.keyboardActive = true;\n  }\n}\n```\n\n- In the `moveActive` method, when moving to the end:\n\n```typescript\nprivate moveActive(payload: { direction: Direction; toEnd?: boolean; navigate?: boolean; shouldClearSelection?: boolean; isDebounced?: boolean; isPending?: boolean }) {\n  if (payload.toEnd) {\n    if (payload.direction === Direction.DownRight) {\n      const lastItem = this.lastInteractiveItem();\n      if (lastItem) {\n        this.activeItem = lastItem;\n        this.focusedItem = lastItem;\n        this.keyboardActive = true;\n      }\n      return;\n    }\n    // ... handle toEnd for UpLeft direction ...\n  }\n  \n  // ... rest of the moveActive implementation ...\n}\n```\n\nThis implementation ensures that when you need to move to or select the last item, you're always getting the last interactive item, improving the user experience by avoiding disabled or non-interactive items at the end of the list.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":217}},"image_offsets":[]},{"id":{"replica_id":0,"value":94},"start":13768,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":218}},"image_offsets":[]},{"id":{"replica_id":0,"value":95},"start":18311,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":219}},"image_offsets":[]},{"id":{"replica_id":0,"value":142},"start":18342,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":220}},"image_offsets":[]},{"id":{"replica_id":0,"value":143},"start":21280,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":221}},"image_offsets":[]},{"id":{"replica_id":0,"value":177},"start":21314,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":222}},"image_offsets":[]},{"id":{"replica_id":0,"value":178},"start":24456,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":223}},"image_offsets":[]}],"summary":"Grouped view state management with keyboard navigation","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":13543},"icon":"File","label":"linear-app/orbiter/src/components/useGroupedViewState.ts"},{"range":{"start":13242,"end":13543},"icon":"ExclamationTriangle","label":"Diagnostics (linear-app/orbiter/src/components/useGroupedViewState.ts): 1 errors"},{"range":{"start":13312,"end":13542},"icon":"XCircle","label":"Invalid character."}]}