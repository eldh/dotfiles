{"id":"8ba536ee-c772-43b1-b36c-dafed464df6a","zed":"context","version":"0.4.0","text":"\n\n\n```tsx linear-app/orbiter/src/components/GroupedList.tsx\nimport * as React from \"react\";\nimport mergeRefs from \"react-merge-refs\";\nimport debounce from \"lodash/debounce\";\nimport styled from \"styled-components\";\n\n/** Type for grouped list items. This is the format we expect list data to be in. */\nexport type GroupedListItem<T> = {\n  id: string;\n  textContent: string;\n  data: T;\n  subItems?: GroupedListItem<T>[];\n};\n\n/** Props that will be passed to list cells */\nexport type ListCellProps<T> = {\n  /** The item to render */\n  item: GroupedListItem<T>;\n  style: React.CSSProperties;\n};\n\n/**\n * Type passed to the ref of the GroupedList component.\n */\nexport type GroupedListRef = {\n  /** Callback to scroll to a specific pixel offset in the list */\n  scrollTo: (offsetPx: number) => void;\n  /** Callback to scroll to a specific id in the list. */\n  scrollToId: (id: string) => void;\n};\n\n/**\n * Grouped virtualized list component.\n */\nexport const GroupedList = React.forwardRef(function GroupedList_<T>(\n  props: GroupedListProps<T>,\n  forwardedRef: React.Ref<GroupedListRef>\n) {\n  // const start = performance.now();\n  const {\n    data,\n    height,\n    overscan,\n    paddingEnd,\n    paddingStart,\n    className,\n    style,\n    heightPerLevel,\n    rendererPerLevel,\n    stickyHeaderLevels,\n    onScroll: onScrollProp,\n    outerRef,\n    outerElementType,\n  } = props;\n\n  const ref = React.useRef<HTMLDivElement>(null);\n\n  const [scrollTop, setScrollTop] = React.useState(0);\n  React.useEffect(() => {\n    if (ref.current) {\n      function updateScrollTop() {\n        if (ref.current) {\n          onScrollProp?.({ scrollOffset: ref.current.scrollTop });\n          setScrollTop(ref.current.scrollTop);\n        }\n      }\n      const listener = debounce(updateScrollTop, 10, { leading: true, trailing: true });\n\n      ref.current.addEventListener(\"scroll\", listener, { passive: true });\n      return () => {\n        ref.current?.removeEventListener(\"scroll\", listener);\n      };\n    }\n    return;\n  }, [ref]);\n\n  const [nestedHeights, heightsAbove] = React.useMemo(() => {\n    // let now = performance.now();\n    const groupHeightMap: Record<string, number> = {};\n    const heightAboveMap: Record<string, number> = {};\n    let heightAbove = 0;\n    function getFullHeight(item_: GroupedListItem<T>, level: number): number {\n      // First set the height above the current item.\n      heightAboveMap[item_.id] = heightAbove;\n      heightAbove += props.heightPerLevel[level];\n\n      // Then calculate the full height of the current item including sub-items.\n      let groupHeight = props.heightPerLevel[level];\n      if (item_.subItems) {\n        for (const subItem of item_.subItems) {\n          const subItemHeight = getFullHeight(subItem, level + 1);\n          if (subItem.subItems) {\n            // Only cache the height if it's not a leaf node.\n            // Leaf node heights are trivial to calculate.\n            groupHeightMap[subItem.id] = subItemHeight;\n          }\n          groupHeight += subItemHeight;\n        }\n      }\n      return groupHeight;\n    }\n    for (let i = 0, l = data.length; i < l; ++i) {\n      const item = data[i];\n      if (item.subItems) {\n        groupHeightMap[item.id] = getFullHeight(item, 0);\n      } else {\n        heightAboveMap[item.id] = heightAbove;\n        heightAbove += heightPerLevel[0];\n      }\n    }\n    // console.log(\"nestedHeights\", performance.now() - now);\n\n    return [groupHeightMap, heightAboveMap];\n  }, [data, props.heightPerLevel]);\n\n  React.useImperativeHandle(forwardedRef, () => ({\n    scrollTo: (offset: number, options?: ScrollIntoViewOptions) => {\n      if (ref.current) {\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n      }\n    },\n    scrollToId: (id, options?: ScrollIntoViewOptions) => {\n      if (ref.current) {\n        const offset = heightsAbove[id];\n        // TODO add height of any sticky headers aboveconst calculateStickyHeaderHeight = (itemId: string) => {\n          let stickyHeaderHeight = 0;\n          const itemLevel = heightsAbove[itemId] ? heightPerLevel.findIndex((h, i) => heightsAbove[itemId] < sum(heightPerLevel.slice(0, i + 1))) : 0;\n\n          for (let i = 0; i < Math.min(stickyHeaderLevels, itemLevel); i++) {\n            stickyHeaderHeight += heightPerLevel[i];\n          }\n\n          return stickyHeaderHeight;\n        };\n\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n        offset -= stickyHeaderHeight;\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n      }\n    },\n  }));\n\n  return (\n    <ListWrapper\n      as={outerElementType}\n      $height={height}\n      $paddingTop={paddingStart}\n      $paddingBottom={paddingEnd}\n      ref={outerRef ? mergeRefs([ref, outerRef]) : ref}\n      className={className}\n      style={style}\n    >\n      <NestedGroupItems\n        scrollTop={scrollTop}\n        listHeight={height}\n        heightAbove={0}\n        items={data}\n        overscan={overscan}\n        nestedHeights={nestedHeights}\n        heightPerLevel={heightPerLevel}\n        rendererPerLevel={rendererPerLevel}\n        stickyHeaderLevels={stickyHeaderLevels}\n        level={0}\n      />\n    </ListWrapper>\n  );\n});\n\nconst GroupItem = React.memo(function GroupItem_<T>(props: GroupItemProps<T>) {\n  const {\n    item,\n    heightPerLevel,\n    heightAbove,\n    rendererPerLevel,\n    level,\n    listHeight,\n    nestedHeights,\n    overscan,\n    scrollTop,\n    stickyHeaderLevels,\n  } = props;\n\n  const isSticky = level <= stickyHeaderLevels - 1;\n  const height = heightPerLevel[level];\n  const Component = rendererPerLevel[level] || rendererPerLevel[rendererPerLevel.length - 1];\n\n  // Potential todo: move these to be class styles on the list wrapper\n  const style: React.CSSProperties = {\n    position: isSticky ? \"sticky\" : \"static\",\n    zIndex: isSticky ? heightPerLevel.length - level : 0,\n    top: isSticky ? sum(heightPerLevel.slice(0, level)) : 0,\n    height,\n  };\n\n  if (item.subItems) {\n    return (\n      <div className=\"item\">\n        <Component item={item} style={style} />\n        <NestedGroupItems\n          items={item.subItems}\n          heightAbove={heightAbove + heightPerLevel[level]}\n          heightPerLevel={heightPerLevel}\n          rendererPerLevel={rendererPerLevel}\n          listHeight={listHeight}\n          nestedHeights={nestedHeights}\n          overscan={overscan}\n          scrollTop={scrollTop}\n          stickyHeaderLevels={stickyHeaderLevels}\n          level={level + 1}\n        />\n      </div>\n    );\n  } else {\n    return <Component item={item} style={style} />;\n  }\n});\n\nconst NestedGroupItems = React.memo(function NestedGroupItems_<T>(props: GroupItemsProps<T>) {\n  const { items, heightAbove, listHeight: viewportHeight, overscan, scrollTop, level } = props;\n  const comps = [];\n  let padAbove = 0;\n  let padBelow = 0;\n  let cumulativeHeight = heightAbove;\n  for (let i = 0, l = items.length; i < l; ++i) {\n    const item = items[i];\n    // The full height of nested groups are pre-calculated and stored in the nestedHeights object.\n    // Other items are calculated on the fly.\n    const itemHeight = props.nestedHeights[item.id] ?? props.heightPerLevel[level];\n    if (cumulativeHeight > scrollTop + viewportHeight + overscan) {\n      padBelow += itemHeight;\n    } else {\n      if (cumulativeHeight + itemHeight < scrollTop - overscan) {\n        padAbove += itemHeight;\n      } else {\n        comps.push(<GroupItem key={item.id} {...props} item={item} heightAbove={cumulativeHeight} />);\n      }\n    }\n    cumulativeHeight += itemHeight;\n  }\n\n  return (\n    <>\n      {padAbove > 0 ? <div className=\"padAbove\" style={{ height: padAbove }} /> : null}\n      {comps}\n      {padBelow > 0 ? <div className=\"padBelow\" style={{ height: padBelow }} /> : null}\n    </>\n  );\n});\n\ntype GroupedListProps<T> = {\n  /**\n   * Data for the list\n   */\n  data: GroupedListItem<T>[];\n  /** Height of the list */\n  height: number;\n  /** Number of pixels to overscan (render outside of the visible frame) */\n  overscan: number;\n  /** Components to render the list cells. */\n  rendererPerLevel: ListCell<T>[];\n  /** How many levels of headers should be sticky */\n  stickyHeaderLevels: number;\n  /** For lists where items in each level have a uniform height, this array will be used to calculate the item heights. */\n  heightPerLevel: number[];\n\n  /** CSS classname */\n  className?: string;\n  /** CSS style */\n  style?: React.CSSProperties;\n  /** Padding that will be added at the start of the inner container. */\n  paddingStart?: number;\n  /** Padding that will be added at the end of the inner container. */\n  paddingEnd?: number;\n  /** Set the scrollTop/scrollLeft of the outer container during the initial mount and render the correct range of\n   * elements based on it. */\n  initialScrollOffset?: number;\n  /** Called at the same time a native `onScroll` on the outer element would. */\n  onScroll?: (args: {\n    /** Same as `scrollTop` */\n    scrollOffset: number;\n  }) => void;\n  /**\n   * Called each time the range of rendered items changes, try to debounce it if possible.\n   */\n  onItemsRendered?: () => void;\n  /** The React ref of the outer container, the one with a scrollbar. */\n  outerRef?: React.RefCallback<HTMLElement | null> | React.MutableRefObject<HTMLElement | null>;\n  /** The React component to use for the outer container, default to \"div\". */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  outerElementType?: keyof JSX.IntrinsicElements | React.ComponentType<any>;\n};\n\ntype GroupItemsProps<T> = Pick<GroupedListProps<T>, \"overscan\" | \"heightPerLevel\" | \"stickyHeaderLevels\"> & {\n  /** The items to render */\n  items: GroupedListItem<T>[];\n  /** Array of renderers for each level of the list */\n  rendererPerLevel: ListCell<T>[];\n  /** Height of the list items above */\n  heightAbove: number;\n  /** Scroll top in the list container */\n  scrollTop: number;\n  /** Height of the list  */\n  listHeight: number;\n  /** All pre-calculated heights in the list */\n  nestedHeights: Record<string, number>;\n  /** The level of the current group */\n  level: number;\n};\n\ntype GroupItemProps<T> = Omit<GroupItemsProps<T>, \"data\"> & {\n  /** The item to render */\n  item: GroupedListItem<T>;\n};\n\ntype ListCell<T> = React.ComponentType<ListCellProps<T>>;\nfunction sum(arr: number[]): number {\n  return arr.reduce((a, b) => a + b, 0);\n}\n\nconst ListWrapper = styled.div<{ $height: number; $paddingTop?: number; $paddingBottom?: number }>`\n  display: block;\n  position: relative;\n  height: ${props => props.$height}px;\n  overflow: auto;\n  padding: ${props => props.$paddingTop ?? 0}px 0 ${props => props.$paddingBottom ?? 0}px 0;\n`;\n```\ndiagnostics: linear-app/orbiter/src/components/GroupedList.tsx\n```tsx\n * Grouped virtualized list component.\n */\nexport const GroupedList = React.forwardRef(function GroupedList_<T>(\n// error: Argument of type '<T>(props: GroupedListProps<T>, forwardedRef: React.Ref<GroupedListRef>) => void' is not assignable to parameter of type 'ForwardRefRenderFunction<GroupedListRef, GroupedListProps<unknown>>'.\n//          Type 'void' is not assignable to type 'ReactElement<any, string | JSXElementConstructor<any>> | null'.\n  props: GroupedListProps<T>,\n  forwardedRef: React.Ref<GroupedListRef>\n```\n```tsx\n  }, [data, props.heightPerLevel]);\n\n  React.useImperativeHandle(forwardedRef, () => ({\n// error: Left side of comma operator is unused and has no side effects.\n    scrollTo: (offset: number, options?: ScrollIntoViewOptions) => {\n      if (ref.current) {\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n      }\n    },\n    scrollToId: (id, options?: ScrollIntoViewOptions) => {\n      if (ref.current) {\n        const offset = heightsAbove[id];\n        // TODO add height of any sticky headers aboveconst calculateStickyHeaderHeight = (itemId: string) => {\n          let stickyHeaderHeight = 0;\n          const itemLevel = heightsAbove[itemId] ? heightPerLevel.findIndex((h, i) => heightsAbove[itemId] < sum(heightPerLevel.slice(0, i + 1))) : 0;\n\n          for (let i = 0; i < Math.min(stickyHeaderLevels, itemLevel); i++) {\n            stickyHeaderHeight += heightPerLevel[i];\n          }\n\n          return stickyHeaderHeight;\n        };\n\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n        offset -= stickyHeaderHeight;\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n      }\n    },\n  }));\n\n```\n```tsx\n      }\n    },\n    scrollToId: (id, options?: ScrollIntoViewOptions) => {\n// error: Parameter 'id' implicitly has an 'any' type.\n      if (ref.current) {\n        const offset = heightsAbove[id];\n```\n```tsx\n        // TODO add height of any sticky headers aboveconst calculateStickyHeaderHeight = (itemId: string) => {\n          let stickyHeaderHeight = 0;\n          const itemLevel = heightsAbove[itemId] ? heightPerLevel.findIndex((h, i) => heightsAbove[itemId] < sum(heightPerLevel.slice(0, i + 1))) : 0;\n// error: Cannot find name 'itemId'.\n\n          for (let i = 0; i < Math.min(stickyHeaderLevels, itemLevel); i++) {\n```\n```tsx\n        // TODO add height of any sticky headers aboveconst calculateStickyHeaderHeight = (itemId: string) => {\n          let stickyHeaderHeight = 0;\n          const itemLevel = heightsAbove[itemId] ? heightPerLevel.findIndex((h, i) => heightsAbove[itemId] < sum(heightPerLevel.slice(0, i + 1))) : 0;\n// error: Cannot find name 'itemId'.\n\n          for (let i = 0; i < Math.min(stickyHeaderLevels, itemLevel); i++) {\n```\n```tsx\n        };\n\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n// error: Cannot find name 'calculateStickyHeaderHeight'. Did you mean 'stickyHeaderHeight'?\n        offset -= stickyHeaderHeight;\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n```\n```tsx\n\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n        offset -= stickyHeaderHeight;\n// error: Cannot find name 'offset'.\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n      }\n```\n```tsx\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n        offset -= stickyHeaderHeight;\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n// error: 'ref.current' is possibly 'null'.\n      }\n    },\n```\n```tsx\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n        offset -= stickyHeaderHeight;\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n// error: Cannot find name 'offset'.\n      }\n    },\n```\n```tsx\n      }\n    },\n  }));\n// error: Parsing error: Expression expected.\n\n  return (\n```\n```tsx\n      }\n    },\n  }));\n// error: Expression expected.\n\n  return (\n```\n```tsx\n      }\n    },\n  }));\n// error: ',' expected.\n\n  return (\n```\n```tsx\n    </ListWrapper>\n  );\n});\n// error: Declaration or statement expected.\n\nconst GroupItem = React.memo(function GroupItem_<T>(props: GroupItemProps<T>) {\n```\n```tsx\n    </ListWrapper>\n  );\n});\n// error: Declaration or statement expected.\n\nconst GroupItem = React.memo(function GroupItem_<T>(props: GroupItemProps<T>) {\n```\n```tsx\n * Grouped virtualized list component.\n */\nexport const GroupedList = React.forwardRef(function GroupedList_<T>(\n// error: Argument of type '<T>(props: GroupedListProps<T>, forwardedRef: React.Ref<GroupedListRef>) => void' is not assignable to parameter of type 'ForwardRefRenderFunction<GroupedListRef, GroupedListProps<unknown>>'.\n//          Type 'void' is not assignable to type 'ReactElement<any, string | JSXElementConstructor<any>> | null'.\n  props: GroupedListProps<T>,\n  forwardedRef: React.Ref<GroupedListRef>\n```\n```tsx\n  }, [data, props.heightPerLevel]);\n\n  React.useImperativeHandle(forwardedRef, () => ({\n// error: Left side of comma operator is unused and has no side effects.\n    scrollTo: (offset: number, options?: ScrollIntoViewOptions) => {\n      if (ref.current) {\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n      }\n    },\n    scrollToId: (id, options?: ScrollIntoViewOptions) => {\n      if (ref.current) {\n        const offset = heightsAbove[id];\n        // TODO add height of any sticky headers aboveconst calculateStickyHeaderHeight = (itemId: string) => {\n          let stickyHeaderHeight = 0;\n          const itemLevel = heightsAbove[itemId] ? heightPerLevel.findIndex((h, i) => heightsAbove[itemId] < sum(heightPerLevel.slice(0, i + 1))) : 0;\n\n          for (let i = 0; i < Math.min(stickyHeaderLevels, itemLevel); i++) {\n            stickyHeaderHeight += heightPerLevel[i];\n          }\n\n          return stickyHeaderHeight;\n        };\n\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n        offset -= stickyHeaderHeight;\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n      }\n    },\n  }));\n\n```\n```tsx\n      }\n    },\n    scrollToId: (id, options?: ScrollIntoViewOptions) => {\n// error: Parameter 'id' implicitly has an 'any' type.\n      if (ref.current) {\n        const offset = heightsAbove[id];\n```\n```tsx\n        // TODO add height of any sticky headers aboveconst calculateStickyHeaderHeight = (itemId: string) => {\n          let stickyHeaderHeight = 0;\n          const itemLevel = heightsAbove[itemId] ? heightPerLevel.findIndex((h, i) => heightsAbove[itemId] < sum(heightPerLevel.slice(0, i + 1))) : 0;\n// error: Cannot find name 'itemId'.\n\n          for (let i = 0; i < Math.min(stickyHeaderLevels, itemLevel); i++) {\n```\n```tsx\n        // TODO add height of any sticky headers aboveconst calculateStickyHeaderHeight = (itemId: string) => {\n          let stickyHeaderHeight = 0;\n          const itemLevel = heightsAbove[itemId] ? heightPerLevel.findIndex((h, i) => heightsAbove[itemId] < sum(heightPerLevel.slice(0, i + 1))) : 0;\n// error: Cannot find name 'itemId'.\n\n          for (let i = 0; i < Math.min(stickyHeaderLevels, itemLevel); i++) {\n```\n```tsx\n        };\n\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n// error: Cannot find name 'calculateStickyHeaderHeight'. Did you mean 'stickyHeaderHeight'?\n        offset -= stickyHeaderHeight;\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n```\n```tsx\n\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n        offset -= stickyHeaderHeight;\n// error: Cannot find name 'offset'.\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n      }\n```\n```tsx\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n        offset -= stickyHeaderHeight;\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n// error: 'ref.current' is possibly 'null'.\n      }\n    },\n```\n```tsx\n        const stickyHeaderHeight = calculateStickyHeaderHeight(id);\n        offset -= stickyHeaderHeight;\n        ref.current.scrollTo({ top: offset, ...(options || {}) });\n// error: Cannot find name 'offset'.\n      }\n    },\n```\n```tsx\n      }\n    },\n  }));\n// error: Parsing error: Expression expected.\n\n  return (\n```\n```tsx\n      }\n    },\n  }));\n// error: Expression expected.\n\n  return (\n```\n```tsx\n      }\n    },\n  }));\n// error: ',' expected.\n\n  return (\n```\n```tsx\n    </ListWrapper>\n  );\n});\n// error: Declaration or statement expected.\n\nconst GroupItem = React.memo(function GroupItem_<T>(props: GroupItemProps<T>) {\n```\n```tsx\n    </ListWrapper>\n  );\n});\n// error: Declaration or statement expected.\n\nconst GroupItem = React.memo(function GroupItem_<T>(props: GroupItemProps<T>) {\n```\n\nwrite a function to get the offset of a specific item by it's id, including the height of any sticky headers that are visible above the item in question\nHere's a function to get the offset of a specific item by its ID, including the height of any sticky headers visible above the item:\n\n```typescript\nfunction getOffsetById(id: string, props: GroupedListProps<unknown>, heightsAbove: Record<string, number>): number {\n  const { data, heightPerLevel, stickyHeaderLevels } = props;\n\n  // Find the item and its level\n  let itemLevel = 0;\n  let item: GroupedListItem<unknown> | undefined;\n  \n  function findItem(items: GroupedListItem<unknown>[], level: number): boolean {\n    for (const currentItem of items) {\n      if (currentItem.id === id) {\n        item = currentItem;\n        itemLevel = level;\n        return true;\n      }\n      if (currentItem.subItems && findItem(currentItem.subItems, level + 1)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  findItem(data, 0);\n\n  if (!item) {\n    throw new Error(`Item with id ${id} not found`);\n  }\n\n  // Calculate the offset\n  let offset = heightsAbove[id];\n\n  // Calculate the height of sticky headers above the item\n  let stickyHeaderHeight = 0;\n  for (let i = 0; i < Math.min(stickyHeaderLevels, itemLevel); i++) {\n    stickyHeaderHeight += heightPerLevel[i];\n  }\n\n  // Subtract the sticky header height from the offset\n  offset -= stickyHeaderHeight;\n\n  return offset;\n}\n```\n\nYou can then use this function in your `scrollToId` method:\n\n```typescript\nscrollToId: (id: string, options?: ScrollIntoViewOptions) => {\n  if (ref.current) {\n    const offset = getOffsetById(id, props, heightsAbove);\n    ref.current.scrollTo({ top: offset, ...(options || {}) });\n  }\n},\n```\n\nThis function does the following:\n\n1. It first searches for the item with the given ID in the data structure, keeping track of its level.\n2. Once the item is found, it gets the initial offset from the `heightsAbove` object.\n3. It then calculates the total height of sticky headers that would be visible above this item, based on the item's level and the `stickyHeaderLevels` prop.\n4. Finally, it subtracts the sticky header height from the initial offset to get the correct scroll position.\n\nThis approach ensures that when scrolling to an item, any sticky headers above it are taken into account, preventing the item from being hidden behind these headers.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":182}},"image_offsets":[]},{"id":{"replica_id":0,"value":140},"start":19487,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":183}},"image_offsets":[]},{"id":{"replica_id":0,"value":141},"start":21725,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":184}},"image_offsets":[]}],"summary":"Grouped virtualized list component with sticky headers","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":3,"end":19333},"icon":"File","label":"linear-app/orbiter/src/components/GroupedList.tsx"},{"range":{"start":10628,"end":19333},"icon":"ExclamationTriangle","label":"Diagnostics (linear-app/orbiter/src/components/GroupedList.tsx): 14 errors"},{"range":{"start":10691,"end":11221},"icon":"XCircle","label":"Argument of type '<T>(props: GroupedListProps<T>, forwardedRef: React.Ref<GroupedListRef>) => void' is not assignable to parameter of type 'ForwardRefRenderFunction<GroupedListRef, GroupedListProps<unknown>>'.\n  Type 'void' is not assignable to type 'ReactElement<any, string | JSXElementConstructor<any>> | null'."},{"range":{"start":11222,"end":12385},"icon":"XCircle","label":"Left side of comma operator is unused and has no side effects."},{"range":{"start":12386,"end":12591},"icon":"XCircle","label":"Parameter 'id' implicitly has an 'any' type."},{"range":{"start":12592,"end":13019},"icon":"XCircle","label":"Cannot find name 'itemId'."},{"range":{"start":13020,"end":13447},"icon":"XCircle","label":"Cannot find name 'itemId'."},{"range":{"start":13448,"end":13736},"icon":"XCircle","label":"Cannot find name 'calculateStickyHeaderHeight'. Did you mean 'stickyHeaderHeight'?"},{"range":{"start":13737,"end":13966},"icon":"XCircle","label":"Cannot find name 'offset'."},{"range":{"start":13967,"end":14209},"icon":"XCircle","label":"'ref.current' is possibly 'null'."},{"range":{"start":14210,"end":14445},"icon":"XCircle","label":"Cannot find name 'offset'."},{"range":{"start":14446,"end":14536},"icon":"XCircle","label":"Parsing error: Expression expected."},{"range":{"start":14537,"end":14612},"icon":"XCircle","label":"Expression expected."},{"range":{"start":14613,"end":14681},"icon":"XCircle","label":"',' expected."},{"range":{"start":14682,"end":14846},"icon":"XCircle","label":"Declaration or statement expected."},{"range":{"start":14847,"end":15011},"icon":"XCircle","label":"Declaration or statement expected."},{"range":{"start":15012,"end":15542},"icon":"XCircle","label":"Argument of type '<T>(props: GroupedListProps<T>, forwardedRef: React.Ref<GroupedListRef>) => void' is not assignable to parameter of type 'ForwardRefRenderFunction<GroupedListRef, GroupedListProps<unknown>>'.\n  Type 'void' is not assignable to type 'ReactElement<any, string | JSXElementConstructor<any>> | null'."},{"range":{"start":15543,"end":16706},"icon":"XCircle","label":"Left side of comma operator is unused and has no side effects."},{"range":{"start":16707,"end":16912},"icon":"XCircle","label":"Parameter 'id' implicitly has an 'any' type."},{"range":{"start":16913,"end":17340},"icon":"XCircle","label":"Cannot find name 'itemId'."},{"range":{"start":17341,"end":17768},"icon":"XCircle","label":"Cannot find name 'itemId'."},{"range":{"start":17769,"end":18057},"icon":"XCircle","label":"Cannot find name 'calculateStickyHeaderHeight'. Did you mean 'stickyHeaderHeight'?"},{"range":{"start":18058,"end":18287},"icon":"XCircle","label":"Cannot find name 'offset'."},{"range":{"start":18288,"end":18530},"icon":"XCircle","label":"'ref.current' is possibly 'null'."},{"range":{"start":18531,"end":18766},"icon":"XCircle","label":"Cannot find name 'offset'."},{"range":{"start":18767,"end":18857},"icon":"XCircle","label":"Parsing error: Expression expected."},{"range":{"start":18858,"end":18933},"icon":"XCircle","label":"Expression expected."},{"range":{"start":18934,"end":19002},"icon":"XCircle","label":"',' expected."},{"range":{"start":19003,"end":19167},"icon":"XCircle","label":"Declaration or statement expected."},{"range":{"start":19168,"end":19332},"icon":"XCircle","label":"Declaration or statement expected."}]}